img_filename(const char *mapimgfile, enum imageformat format,
                         char *filename, size_t filename_len)
{
  fc_assert_ret_val(imageformat_is_valid(format) , FALSE);
  fc_snprintf(filename, filename_len, "%s.map.%s", mapimgfile,
              imageformat_name(format));
  return TRUE;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
sigar_net_interface_list_get(sigar_t *sigar,
                                 sigar_net_interface_list_t *iflist)
{
    int n, lastlen=0;
    struct ifreq *ifr;
    struct ifconf ifc;
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        return errno;
    } 
    for (;;) {
        if (!sigar->ifconf_buf || lastlen) {
            sigar->ifconf_len += sizeof(struct ifreq) * SIGAR_NET_IFLIST_MAX;
            sigar->ifconf_buf = realloc(sigar->ifconf_buf, sigar->ifconf_len);
        }
        ifc.ifc_len = sigar->ifconf_len;
        ifc.ifc_buf = sigar->ifconf_buf;
        if (ioctl(sock, MY_SIOCGIFCONF, &ifc) < 0) {
            /* EINVAL should mean num_interfaces > ifc.ifc_len */
            if ((errno != EINVAL) ||
                (lastlen == ifc.ifc_len))
            {
                free(ifc.ifc_buf);
                return errno;
            }
        }
        if (ifc.ifc_len < sigar->ifconf_len) {
            break; /* got em all */
        }
        if (ifc.ifc_len != lastlen) {
            /* might be more */
            lastlen = ifc.ifc_len;
            continue;
        }
        break;
    }
    close(sock);
    iflist->number = 0;
    iflist->size = ifc.ifc_len;
    iflist->data = malloc(sizeof(*(iflist->data)) *
                          iflist->size);
    ifr = ifc.ifc_req;
    for (n = 0; n < ifc.ifc_len; n += sizeof(struct ifreq), ifr++) {
#if defined(_AIX) || defined(__osf__) /* pass the bourbon */
        if (ifr->ifr_addr.sa_family != AF_LINK) {
            /* XXX: dunno if this is right.
             * otherwise end up with two 'en0' and three 'lo0'
             * with the same ip address.
             */
            continue;
        }
#   ifdef __osf__
        /* weed out "sl0", "tun0" and the like */
        /* XXX must be a better way to check this */
        if (!sigar_netif_configured(sigar, ifr->ifr_name)) {
            continue;
        }
#   endif        
#endif
        iflist->data[iflist->number++] =
            sigar_strdup(ifr->ifr_name);
    }
#ifdef __linux__
    proc_net_interface_list_get(sigar, iflist);
#endif
    return SIGAR_OK;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
OperandsComplete() const {
  unsigned short NumOperands = TID->getNumOperands();
  if (!TID->isVariadic() && getNumOperands()-NumImplicitOps >= NumOperands)
    return true;  // Broken: we have all the operands of this instruction!
  return false;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
maybe_adjust_types_for_deduction (unification_kind_t strict,
				  tree* parm,
				  tree* arg,
				  tree arg_expr)
{
  int result = 0;
  switch (strict)
    {
    case DEDUCE_CALL:
      break;
    case DEDUCE_CONV:
      {
	/* Swap PARM and ARG throughout the remainder of this
	   function; the handling is precisely symmetric since PARM
	   will initialize ARG rather than vice versa.  */
	tree* temp = parm;
	parm = arg;
	arg = temp;
	break;
      }
    case DEDUCE_EXACT:
      /* Core issue #873: Do the DR606 thing (see below) for these cases,
	 too, but here handle it by stripping the reference from PARM
	 rather than by adding it to ARG.  */
      if (TREE_CODE (*parm) == REFERENCE_TYPE
	  && TYPE_REF_IS_RVALUE (*parm)
	  && TREE_CODE (TREE_TYPE (*parm)) == TEMPLATE_TYPE_PARM
	  && cp_type_quals (TREE_TYPE (*parm)) == TYPE_UNQUALIFIED
	  && TREE_CODE (*arg) == REFERENCE_TYPE
	  && !TYPE_REF_IS_RVALUE (*arg))
	*parm = TREE_TYPE (*parm);
      /* Nothing else to do in this case.  */
      return 0;
    default:
      gcc_unreachable ();
    }
  if (TREE_CODE (*parm) != REFERENCE_TYPE)
    {
      /* [temp.deduct.call]
	 If P is not a reference type:
	 --If A is an array type, the pointer type produced by the
	 array-to-pointer standard conversion (_conv.array_) is
	 used in place of A for type deduction; otherwise,
	 --If A is a function type, the pointer type produced by
	 the function-to-pointer standard conversion
	 (_conv.func_) is used in place of A for type deduction;
	 otherwise,
	 --If A is a cv-qualified type, the top level
	 cv-qualifiers of A's type are ignored for type
	 deduction.  */
      if (TREE_CODE (*arg) == ARRAY_TYPE)
	*arg = build_pointer_type (TREE_TYPE (*arg));
      else if (TREE_CODE (*arg) == FUNCTION_TYPE)
	*arg = build_pointer_type (*arg);
      else
	*arg = TYPE_MAIN_VARIANT (*arg);
    }
  /* From C++0x [14.8.2.1/3 temp.deduct.call] (after DR606), "If P is
     of the form T&&, where T is a template parameter, and the argument
     is an lvalue, T is deduced as A& */
  if (TREE_CODE (*parm) == REFERENCE_TYPE
      && TYPE_REF_IS_RVALUE (*parm)
      && TREE_CODE (TREE_TYPE (*parm)) == TEMPLATE_TYPE_PARM
      && cp_type_quals (TREE_TYPE (*parm)) == TYPE_UNQUALIFIED
      && (arg_expr ? real_lvalue_p (arg_expr)
	  /* try_one_overload doesn't provide an arg_expr, but
	     functions are always lvalues.  */
	  : TREE_CODE (*arg) == FUNCTION_TYPE))
    *arg = build_reference_type (*arg);
  /* [temp.deduct.call]
     If P is a cv-qualified type, the top level cv-qualifiers
     of P's type are ignored for type deduction.  If P is a
     reference type, the type referred to by P is used for
     type deduction.  */
  *parm = TYPE_MAIN_VARIANT (*parm);
  if (TREE_CODE (*parm) == REFERENCE_TYPE)
    {
      *parm = TREE_TYPE (*parm);
      result |= UNIFY_ALLOW_OUTER_MORE_CV_QUAL;
    }
  /* DR 322. For conversion deduction, remove a reference type on parm
     too (which has been swapped into ARG).  */
  if (strict == DEDUCE_CONV && TREE_CODE (*arg) == REFERENCE_TYPE)
    *arg = TREE_TYPE (*arg);
  return result;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
GaussianSetHistogram(struct histogram_s *h, float mean, float sd)
{
  int   sc;
  int   hsize, idx;
  int   nbins;
  float delta;
  UnfitHistogram(h);
  h->fit_type          = HISTFIT_GAUSSIAN;
  h->param[GAUSS_MEAN] = mean;
  h->param[GAUSS_SD]   = sd;
  /* Calculate the expected values for the histogram.
   */
  hsize     = h->max - h->min + 1;
  h->expect = (float *) MallocOrDie(sizeof(float) * hsize);
  for (idx = 0; idx < hsize; idx++)
    h->expect[idx] = 0.;
  /* Note: ideally we'd use the Gaussian distribution function
   * to find the histogram occupancy in the window sc..sc+1. 
   * However, the distribution function is hard to calculate.
   * Instead, estimate the histogram by taking the density at sc+0.5.
   */
  for (sc = h->min; sc <= h->max; sc++)
    { 
      delta = ((float)sc + 0.5) - h->param[GAUSS_MEAN];
      h->expect[sc - h->min] =
	(float) h->total * ((1. / (h->param[GAUSS_SD] * sqrt(2.*3.14159))) * 
	    (exp(-1.*delta*delta / (2. * h->param[GAUSS_SD] * h->param[GAUSS_SD]))));
    }
  /* Calculate the goodness-of-fit (within whole region)
   */
  h->chisq = 0.;
  nbins    = 0;
  for (sc = h->lowscore; sc <= h->highscore; sc++)
    if (h->expect[sc-h->min] >= 5. && h->histogram[sc-h->min] >= 5)
      {
	delta = (float) h->histogram[sc-h->min] - h->expect[sc-h->min];
	h->chisq += delta * delta / h->expect[sc-h->min];
	nbins++;
      }
	/* -1 d.f. for normalization */
  if (nbins > 1)
    h->chip = (float) IncompleteGamma((double)(nbins-1)/2., 
				      (double) h->chisq/2.);
  else
    h->chip = 0.;		
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
xdr_gfs3_xattrop_rsp (XDR *xdrs, gfs3_xattrop_rsp *objp)
{
	register int32_t *buf;
        buf = NULL;
	 if (!xdr_int (xdrs, &objp->op_ret))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->op_errno))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->dict.dict_val, (u_int *) &objp->dict.dict_len, ~0))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->xdata.xdata_val, (u_int *) &objp->xdata.xdata_len, ~0))
		 return FALSE;
	return TRUE;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
snd_pcm_route_convert(const snd_pcm_channel_area_t *dst_areas,
				  snd_pcm_uframes_t dst_offset,
				  const snd_pcm_channel_area_t *src_areas,
				  snd_pcm_uframes_t src_offset,
				  unsigned int src_channels,
				  unsigned int dst_channels,
				  snd_pcm_uframes_t frames,
				  snd_pcm_route_params_t *params)
{
	unsigned int dst_channel;
	snd_pcm_route_ttable_dst_t *dstp;
	const snd_pcm_channel_area_t *dst_area;
	dstp = params->dsts;
	dst_area = dst_areas;
	for (dst_channel = 0; dst_channel < dst_channels; ++dst_channel) {
		if (dst_channel >= params->ndsts)
			snd_pcm_route_convert1_zero(dst_area, dst_offset,
						    src_areas, src_offset,
						    src_channels,
						    frames, dstp, params);
		else
			dstp->func(dst_area, dst_offset,
				   src_areas, src_offset,
				   src_channels,
				   frames, dstp, params);
		dstp++;
		dst_area++;
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
repaint_point (EMap *map, EMapPoint *point)
{
	gdouble px, py;
        if (!gtk_widget_is_drawable (GTK_WIDGET (map)))
          return;
	e_map_world_to_window (map, point->longitude, point->latitude, &px, &py);
	gtk_widget_queue_draw_area (GTK_WIDGET (map),
                                    (gint) px - 2, (gint) py - 2,
                                    5, 5);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
load_modules(const char *name)
{
	struct conf_sect_t *sect;
	struct conf_option_t *opt;
	char *fname;
	char *path = MODULE_PATH;
	char *ptr1, *ptr2;
	struct module_t *m;
	void *h;
	sect = conf_get_section(name);
	if (!sect) {
		fprintf(stderr, "loader: section '%s' not found\n", name);
		return -1;
	}
	fname = _malloc(PATH_MAX);
	list_for_each_entry(opt, &sect->items, entry) {
		if (!strcmp(opt->name,"path") && opt->val) {
			path = opt->val;
			continue;
		}
		strcpy(fname, path);
		strcat(fname, "/");
		strcat(fname, opt->name);
		if (access(fname, F_OK)) {
			strcpy(fname, path);
			strcat(fname, "/lib");
			strcat(fname, opt->name);
			strcat(fname, ".so");
			if (access(fname, F_OK)) {
				strcpy(fname, opt->name);
				if (access(opt->name, F_OK)) {
					triton_log_error("loader: '%s' not found", opt->name);
					continue;
				}
			}
		}
		h = dlopen(fname, RTLD_LAZY | RTLD_GLOBAL);
		if (!h) {
			triton_log_error("loader: failed to load '%s': %s", opt->name, dlerror());
			_free(fname);
			return -1;
		}
		ptr1 = fname;
		while (1) {
			ptr2 = strchr(ptr1, '/');
			if (!ptr2)
				break;
			ptr1 = ptr2 + 1;
		}
		if (!strncmp(ptr1, "lib", 3))
			ptr1 += 3;
		ptr2 = strstr(ptr1, ".so\x0");
		if (ptr2)
			*ptr2 = 0;
		m = _malloc(sizeof(*m));
		m->name = _strdup(ptr1);
		m->handle = h;
		list_add_tail(&m->entry, &modules);
	}
	_free(fname);
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
savefile_handle_unknown(CdlInterpreter interp, int argc, const char* argv[])
{
    CYG_REPORT_FUNCNAME("CdlToplevel::savefile_handle_unknown");
    CYG_REPORT_FUNCARG2XV(interp, argc);
    CYG_PRECONDITION_CLASSC(interp);
    CdlParse::report_error(interp, "", std::string("Unknown command `") + argv[1] + "'.");
    CYG_UNUSED_PARAM(int, argc);
    return TCL_OK;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
__repmgr_check_listener(env)
	ENV *env;
{
	DB_REP *db_rep;
	REP *rep;
	SITEINFO *sites;
	db_timespec t;
	int ret;
	db_rep = env->rep_handle;
	rep = db_rep->region;
	ret = 0;
	/*
	 * Only subordinate rep-aware process can take over listener role, so
	 * no need to check listener in listener process or rep unaware process.
	 */
	if (!IS_LISTENER_CAND(db_rep))
		return (0);
	/*
	 * If the listener quits due to site removal, no subordinate process
	 * should take over as listener as the current site is not expected
	 * to be active in the group.  Check the status from the site array
	 * in the shared region instead of that in the GMDB.  We do this
	 * because the GMDB doesn't apply the change yet when replication
	 * is stopped on the removed site.
	 */
	sites = R_ADDR(env->reginfo, rep->siteinfo_off);
	if (sites[rep->self_eid].status == SITE_DELETING)
		return (0);
	/*
	 * Check the listener after timeout.  If there is no listener, we
	 * take over.  During takeover, we will refresh all connections.
	 * A subordinate process does not have an up-to-date site list, so sync
	 * up addresses from the in-memory site array before takeover.
	 */
	__os_gettime(env, &t, 1);
	if (timespeccmp(&t, &db_rep->l_listener_chk, >=)) {
		/* Compute the next timeout. */
		TIMESPEC_ADD_DB_TIMEOUT(&t, db_rep->l_listener_wait);
		db_rep->l_listener_chk = t;
		/* Check if site address information needs to be refreshed. */
		if ((rep->siteinfo_seq > db_rep->siteinfo_seq) &&
		    (ret = __repmgr_sync_siteaddr(env)) != 0)
			return (ret);
		if (rep->listener == 0)
			ret = __repmgr_start_takeover(env);
	}
	return (ret);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ap_mpm_rewrite_args(process_rec *process)
{
    apr_array_header_t *mpm_new_argv;
    apr_status_t rv;
    apr_getopt_t *opt;
    char optbuf[3];
    const char *optarg;
    mpm_new_argv = apr_array_make(process->pool, process->argc,
                                  sizeof(const char **));
    *(const char **)apr_array_push(mpm_new_argv) = process->argv[0];
    apr_getopt_init(&opt, process->pool, process->argc, process->argv);
    opt->errfn = NULL;
    optbuf[0] = '-';
    /* option char returned by apr_getopt() will be stored in optbuf[1] */
    optbuf[2] = '\0';
    while ((rv = apr_getopt(opt, "k:" AP_SERVER_BASEARGS,
                            optbuf + 1, &optarg)) == APR_SUCCESS) {
        switch(optbuf[1]) {
        case 'k':
            if (!dash_k_arg) {
                if (!strcmp(optarg, "start") || !strcmp(optarg, "stop") ||
                    !strcmp(optarg, "restart") || !strcmp(optarg, "graceful") ||
                    !strcmp(optarg, "graceful-stop")) {
                    dash_k_arg = optarg;
                    break;
                }
            }
        default:
            *(const char **)apr_array_push(mpm_new_argv) =
                apr_pstrdup(process->pool, optbuf);
            if (optarg) {
                *(const char **)apr_array_push(mpm_new_argv) = optarg;
            }
        }
    }
    /* back up to capture the bad argument */
    if (rv == APR_BADCH || rv == APR_BADARG) {
        opt->ind--;
    }
    while (opt->ind < opt->argc) {
        *(const char **)apr_array_push(mpm_new_argv) =
            apr_pstrdup(process->pool, opt->argv[opt->ind++]);
    }
    process->argc = mpm_new_argv->nelts;
    process->argv = (const char * const *)mpm_new_argv->elts;
    if (NULL == dash_k_arg) {
        dash_k_arg = dash_k_arg_noarg;
    }
    APR_REGISTER_OPTIONAL_FN(ap_signal_server);
}
CWE-119  True
CWE-120  True
CWE-469  True
CWE-476  False
CWE-other  False
--------------------------
gettheta(sex_, LINK)
thetavalues **sex_;
struct LOC_readloci *LINK;
{
  thetarray oldtheta;
  long i;
  thetavalues *WITH;
  long FORLIM;
#if !PARALLEL
  *sex_ = (thetavalues *)Malloc(sizeof(thetavalues));
  for (i = 0; i < maxlocus; i++)
    (*sex_)->theta[i] = 0.0;
#endif
  nuneed = 7;
  for(i = 2; i < mlocus; i++)
    nuneed = 5 * nuneed - 3;
  if (*sex_ == NULL)
    malloc_err("item of type thetavalues");
   /*Next line added by A. A. Schaffer*/
  (*sex_)->segprob = (double*) malloc(nuneed * sizeof(double));
  if ((*sex_)->segprob == NULL)
    malloc_err("a segprob array in procedure gettheta");
  WITH = *sex_;
  if (*sex_ == maletheta || readfemale) {
    FORLIM = mlocus - 2;
    for (i = 0; i <= FORLIM; i++)
      fscanf(datafile, "%lf", &(*sex_)->theta[i]);
    if (interfer && !mapping)
      fscanf(datafile, "%lf", &(*sex_)->theta[mlocus - 1]);
    fscanf(datafile, "%*[^\n]");
    getc(datafile);
  } else {
    fscanf(datafile, "%lf%*[^\n]", &distratio);
    getc(datafile);
  }
  /*     FOR j:=1 TO maxneed DO segprob[j]:=0.0;*/
  if (!interfer || mapping)
    return;
  memcpy(oldtheta, WITH->theta, sizeof(thetarray));
  WITH->theta[0] = (oldtheta[0] + oldtheta[mlocus - 1] - oldtheta[mlocus - 2]) / 2.0;
  WITH->theta[mlocus - 2] =
    (oldtheta[mlocus - 2] + oldtheta[mlocus - 1] - oldtheta[0]) / 2.0;
  WITH->theta[mlocus - 1] =
    (oldtheta[0] + oldtheta[mlocus - 2] - oldtheta[mlocus - 1]) / 2.0;
  for (i = 0; i < mlocus; i++) {   /*=ln(1/0.0001-1.0)*/
    if (WITH->theta[i] > 0.0) {
      if (WITH->theta[i] < 0.999)
	WITH->theta[i] = log(1.0 / WITH->theta[i] - 1.0);
      else
	WITH->theta[i] = -6.9;   /*=ln(1/0.999-1.0)*/
    } else
      WITH->theta[i] = 9.21;
  }
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Done(int restart, char *command)
{
  cleanupDone=1;
#ifdef M4  
  if (m4_enable)
    {
      extern char *fvwm_file;
      /* With m4 processing, a temporary file was created to hold the
         processed file.  Delete the file now because we don't need it
	 any more.  It will be created again during restart. */
      unlink(fvwm_file);
    }
#endif
#ifndef NON_VIRTUAL
  MoveViewport(0,0,False);
#endif
  /* Close all my pipes */
  ClosePipes();
  Reborder ();
  if(restart)
    {
      SaveDesktopState();		/* I wonder why ... */
      /* Really make sure that the connection is closed and cleared! */
      XSelectInput(dpy, Scr.Root, 0 );
      XSync(dpy, 0);
      XCloseDisplay(dpy);
      {
	char *my_argv[10];
	int i,done,j;
	i=0;
	j=0;
	done = 0;
	while((g_argv[j] != NULL)&&(i<8))
	  {
	    if(strcmp(g_argv[j],"-s")!=0)
	      {
		my_argv[i] = g_argv[j];
		i++;
		j++;
	      }
	    else
	      j++;
	  }
	if(strstr(command,"fvwm")!= NULL)
	   my_argv[i++] = "-s";
	while(i<10)
	  my_argv[i++] = NULL;
	/* really need to destroy all windows, explicitly,
	 * not sleep, but this is adequate for now */
	sleep(1);
	ReapChildren();
	execvp(command,my_argv);
      }
      fprintf(stderr, "FVWM: Call of '%s' failed!!!!\n",command);
      execvp(g_argv[0], g_argv);    /* that _should_ work */
      fprintf(stderr, "FVWM: Call of '%s' failed!!!!\n", g_argv[0]); 
    }
  else
    {
      XCloseDisplay(dpy);
      exit(0);
    }
}
CWE-119  True
CWE-120  True
CWE-469  True
CWE-476  False
CWE-other  False
--------------------------
__GEOIP_PREPARE_TEREDO(geoipv6_t * v6)
{
    int i;
    if ((v6->s6_addr[0]) != 0x20) {
        return;
    }
    if ((v6->s6_addr[1]) != 0x01) {
        return;
    }
    if ((v6->s6_addr[2]) != 0x00) {
        return;
    }
    if ((v6->s6_addr[3]) != 0x00) {
        return;
    }
    for (i = 0; i < 12; i++) {
        v6->s6_addr[i] = 0;
    }
    for (; i < 16; i++) {
        v6->s6_addr[i] ^= 0xff;
    }
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
create_access (tree expr, gimple stmt, bool write)
{
  struct access *access;
  HOST_WIDE_INT offset, size, max_size;
  tree base = expr;
  bool ptr, unscalarizable_region = false;
  base = get_ref_base_and_extent (expr, &offset, &size, &max_size);
  if (sra_mode == SRA_MODE_EARLY_IPA
      && TREE_CODE (base) == MEM_REF)
    {
      base = get_ssa_base_param (TREE_OPERAND (base, 0));
      if (!base)
	return NULL;
      ptr = true;
    }
  else
    ptr = false;
  if (!DECL_P (base) || !bitmap_bit_p (candidate_bitmap, DECL_UID (base)))
    return NULL;
  if (sra_mode == SRA_MODE_EARLY_IPA)
    {
      if (size < 0 || size != max_size)
	{
	  disqualify_candidate (base, "Encountered a variable sized access.");
	  return NULL;
	}
      if (TREE_CODE (expr) == COMPONENT_REF
	  && DECL_BIT_FIELD (TREE_OPERAND (expr, 1)))
	{
	  disqualify_candidate (base, "Encountered a bit-field access.");
	  return NULL;
	}
      gcc_checking_assert ((offset % BITS_PER_UNIT) == 0);
      if (ptr)
	mark_parm_dereference (base, offset + size, stmt);
    }
  else
    {
      if (size != max_size)
	{
	  size = max_size;
	  unscalarizable_region = true;
	}
      if (size < 0)
	{
	  disqualify_candidate (base, "Encountered an unconstrained access.");
	  return NULL;
	}
    }
  access = create_access_1 (base, offset, size);
  access->expr = expr;
  access->type = TREE_TYPE (expr);
  access->write = write;
  access->grp_unscalarizable_region = unscalarizable_region;
  access->stmt = stmt;
  if (TREE_CODE (expr) == COMPONENT_REF
      && DECL_NONADDRESSABLE_P (TREE_OPERAND (expr, 1)))
    access->non_addressable = 1;
  return access;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
draw_keys (int draw)
{
  char            s[20];
  static char    *key[4] =
  {"UP", "DOWN", "LEFT", "RIGHT"};
  static char    *rkey[3] =
  {"ACCELERATION", "ROTATE LEFT", "ROTATE RIGHT"};
  if (!draw)
    return;
  nmenu = 2;
  sprintf (s, "PLAYER:%i", player + 1);
  DrawWhiteMaskedText ((int) (MAPWIDTH / 2 - 4 * strlen (s)), (int) YPOSITION (0), s);
  if (rotation[player])
    sprintf (s, "KEY:%s", rkey[keynum]);
  else
    sprintf (s, "KEY:%s", key[keynum]);
  DrawWhiteMaskedText ((int) (MAPWIDTH / 2 - 4 * strlen (s)), (int) YPOSITION (1), s);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
da9150_fg_read_attr(struct da9150_fg *fg, u8 code, u8 size)
{
	u8 buf[size];
	u8 read_addr;
	u32 res = 0;
	int i;
	/* Set QIF code (READ mode) */
	read_addr = (code & DA9150_QIF_CODE_MASK) | DA9150_QIF_READ;
	da9150_read_qif(fg->da9150, read_addr, size, buf);
	for (i = 0; i < size; ++i)
		res |= (buf[i] << (i * DA9150_QIF_BYTE_SIZE));
	return res;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
save_weblist()
{
	char filename[512];
	xmlDoc  *doc;
	xmlNode *xsearchengine;
	xmlNode *xgroup;
	xmlNode *xengine;
	gint type;
	gchar *title=NULL;
	gchar *home=NULL;
	gchar *pre=NULL;
	gchar *post=NULL;
	gchar *glue=NULL;
	gchar *code=NULL;
	GtkTreeIter   parent_iter;
	GtkTreeIter   child_iter;
	LOG(LOG_DEBUG, "IN : save_weblist()");
	sprintf(filename, "%s%s%s", user_dir, DIR_DELIMITER, FILENAME_WEBLIST);
	doc = xml_doc_new();
	doc->encoding = strdup("euc-jp");
	doc->version = strdup("1.0");
	xsearchengine = xml_add_child(doc->root, "searchengine", NULL);
	if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(web_store), &parent_iter) == TRUE){
		do { 
			gtk_tree_model_get(GTK_TREE_MODEL(web_store), 
					   &parent_iter, 
					   WEB_TYPE_COLUMN, &type,
					   WEB_TITLE_COLUMN, &title,
					   -1);
			xgroup = xml_add_child(xsearchengine, "group", NULL);
			xml_set_attr(xgroup, "name", title);
			g_free (title);
		       if(gtk_tree_model_iter_children(GTK_TREE_MODEL(web_store), &child_iter, &parent_iter) == TRUE){
			       do {
				       title=NULL;
				       home=NULL;
				       pre=NULL;
				       post=NULL;
				       glue=NULL;
				       code=NULL;
				       gtk_tree_model_get(GTK_TREE_MODEL(web_store),
							  &child_iter,
							  WEB_TYPE_COLUMN, &type,
							  WEB_TITLE_COLUMN, &title,
							  WEB_HOME_COLUMN, &home,
							  WEB_PRE_COLUMN, &pre,
							  WEB_POST_COLUMN, &post,
							  WEB_GLUE_COLUMN, &glue,
							  WEB_CODE_COLUMN, &code,
							  -1);
				       xengine = xml_add_child(xgroup, "engine", NULL);
				       xml_add_child(xengine, "name", title);
				       xml_add_child(xengine, "home", home);
				       xml_add_child(xengine, "pre", pre);
				       xml_add_child(xengine, "post", post);
				       xml_add_child(xengine, "glue", glue);
				       xml_add_child(xengine, "charcode", code);
				       g_free (title);
				       g_free (home);
				       g_free (pre);
				       g_free (post);
				       g_free (glue);
				       g_free (code);
			       } while (gtk_tree_model_iter_next(GTK_TREE_MODEL(web_store), &child_iter) == TRUE);
		       }
	       } while (gtk_tree_model_iter_next(GTK_TREE_MODEL(web_store), &parent_iter) == TRUE);
	}
	xml_save_file(filename, doc);
	xml_destroy_document(doc);
	LOG(LOG_DEBUG, "OUT : save_weblist()");
	return(TRUE);
}
CWE-119  True
CWE-120  True
CWE-469  True
CWE-476  False
CWE-other  False
--------------------------
airEndsWith(const char *s, const char *suff) {
  if (!(s && suff))
    return 0;
  if (!(strlen(s) >= strlen(suff)))
    return 0;
  if (!strncmp(s + strlen(s) - strlen(suff), suff, strlen(suff)))
    return 1;
  else
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
memory_ass_sub(PyMemoryViewObject *self, PyObject *key, PyObject *value)
{
    Py_ssize_t start, len, bytelen;
    Py_buffer srcview;
    Py_buffer *view = &(self->view);
    char *srcbuf, *destbuf;
    if (view->readonly) {
        PyErr_SetString(PyExc_TypeError,
            "cannot modify read-only memory");
        return -1;
    }
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "cannot delete memory");
        return -1;
    }
    if (view->ndim != 1) {
        PyErr_SetNone(PyExc_NotImplementedError);
        return -1;
    }
    if (PyIndex_Check(key)) {
        start = PyNumber_AsSsize_t(key, NULL);
        if (start == -1 && PyErr_Occurred())
            return -1;
        if (start < 0) {
            start += get_shape0(view);
        }
        if ((start < 0) || (start >= get_shape0(view))) {
            PyErr_SetString(PyExc_IndexError,
                            "index out of bounds");
            return -1;
        }
        len = 1;
    }
    else if (PySlice_Check(key)) {
        Py_ssize_t stop, step;
        if (PySlice_GetIndicesEx((PySliceObject*)key, get_shape0(view),
                         &start, &stop, &step, &len) < 0) {
            return -1;
        }
        if (step != 1) {
            PyErr_SetNone(PyExc_NotImplementedError);
            return -1;
        }
    }
    else {
        PyErr_Format(PyExc_TypeError,
            "cannot index memory using \"%.200s\"", 
            key->ob_type->tp_name);
        return -1;
    }
    if (PyObject_GetBuffer(value, &srcview, PyBUF_CONTIG_RO) == -1) {
        return -1;
    }
    /* XXX should we allow assignment of different item sizes
       as long as the byte length is the same?
       (e.g. assign 2 shorts to a 4-byte slice) */
    if (srcview.itemsize != view->itemsize) {
        PyErr_Format(PyExc_TypeError,
            "mismatching item sizes for \"%.200s\" and \"%.200s\"", 
            view->obj->ob_type->tp_name, srcview.obj->ob_type->tp_name);
        goto _error;
    }
    bytelen = len * view->itemsize;
    if (bytelen != srcview.len) {
        PyErr_SetString(PyExc_ValueError,
            "cannot modify size of memoryview object");
        goto _error;
    }
    /* Do the actual copy */
    destbuf = (char *) view->buf + start * view->itemsize;
    srcbuf = (char *) srcview.buf;
    if (destbuf + bytelen < srcbuf || srcbuf + bytelen < destbuf)
        /* No overlapping */
        memcpy(destbuf, srcbuf, bytelen);
    else
        memmove(destbuf, srcbuf, bytelen);
    PyBuffer_Release(&srcview);
    return 0;
_error:
    PyBuffer_Release(&srcview);
    return -1;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
find_neighbors_LL(EW * ewptr, NEIGHBOR * nbr_head, SHORT row, SHORT col,
		      int npoints, SHORT * neighbors)
{
    MELEMENT **Mptr;		/* double indirection !! */
    int westward = 1;		/* 1 if west of interpolation point */
    double distance;
    short *active;		/* TRUE if active search in this direction */
    active = &ewptr->walive;	/* TRUE if searching west in this row */
    Mptr = &ewptr->west;	/* process search west first, then east */
    do {
	if (*active) {
	    distance = distance_LL(row, col, *Mptr);
	    if (*neighbors < npoints)
		add_neighbor(Mptr, nbr_head, distance, ++(*neighbors));
	    else if (!replace_neighbor(Mptr, nbr_head, distance))
		*active = FALSE;	/* curtail search in this direction */
	    if (*active)
		if (westward)
		    extend_west(ewptr);
		else
		    extend_east(ewptr);
	}
	active = &ewptr->ealive;
	Mptr = &ewptr->east;
    } while (westward--);	/* repeat loop for east and quit */
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_fm_folder_model_add_file(FmFolderModel* model, FmFileInfo* file)
{
    if(!file_can_show(model, file))
        g_sequence_append( model->hidden, fm_folder_item_new(file) );
    else
        fm_folder_model_file_created(model, file);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
GetLength()
{
  double result, l=0.0;
  int i;
  this->ComputeBounds();
  for (i=0; i<3; i++)
    {
    result = this->Bounds[2*i+1] - this->Bounds[2*i];
    l += result * result;
    }
  result = sqrt(l);
  assert("post: positive_result" && result>=0);
  return result;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
eb_finalize_appendix_subbooks(EB_Appendix *appendix)
{
    EB_Appendix_Subbook *subbook;
    int i;
    LOG(("in: eb_finalize_appendix_subbooks(appendix=%d)",
	(int)appendix->code));
    for (i = 0, subbook = appendix->subbooks; i < appendix->subbook_count;
	 i++, subbook++) {
	zio_finalize(&appendix->subbooks[i].zio);
    }
    LOG(("out: eb_finalize_appendix_subbooks()"));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
LongestAxisLength (void) const
{
    // Return longest axis length
    RNLength dx = this->XLength();
    RNLength dy = this->YLength();
    return (dx > dy) ? dx : dy;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
write_metadata_block_data_streaminfo_cb_(FLAC__IOHandle handle, FLAC__IOCallback_Write write_cb, const FLAC__StreamMetadata_StreamInfo *block)
{
	FLAC__byte buffer[FLAC__STREAM_METADATA_STREAMINFO_LENGTH];
	const unsigned channels1 = block->channels - 1;
	const unsigned bps1 = block->bits_per_sample - 1;
	/* we are using hardcoded numbers for simplicity but we should
	 * probably eventually write a bit-level packer and use the
	 * _STREAMINFO_ constants.
	 */
	pack_uint32_(block->min_blocksize, buffer, 2);
	pack_uint32_(block->max_blocksize, buffer+2, 2);
	pack_uint32_(block->min_framesize, buffer+4, 3);
	pack_uint32_(block->max_framesize, buffer+7, 3);
	buffer[10] = (block->sample_rate >> 12) & 0xff;
	buffer[11] = (block->sample_rate >> 4) & 0xff;
	buffer[12] = ((block->sample_rate & 0x0f) << 4) | (channels1 << 1) | (bps1 >> 4);
	buffer[13] = (FLAC__byte)(((bps1 & 0x0f) << 4) | ((block->total_samples >> 32) & 0x0f));
	pack_uint32_((FLAC__uint32)block->total_samples, buffer+14, 4);
	memcpy(buffer+18, block->md5sum, 16);
	if(write_cb(buffer, 1, FLAC__STREAM_METADATA_STREAMINFO_LENGTH, handle) != FLAC__STREAM_METADATA_STREAMINFO_LENGTH)
		return false;
	return true;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
set_member_ringinuse_help_members(struct call_queue *q, const char *interface, int ringinuse)
{
	struct member *mem;
	int foundinterface = 0;
	char rtringinuse[80];
	ao2_lock(q);
	if ((mem = interface_exists(q, interface))) {
		foundinterface++;
		if (!mem->realtime) {
			mem->ringinuse = ringinuse;
		} else {
			sprintf(rtringinuse, "%i", ringinuse);
			update_realtime_member_field(mem, q->name, realtime_ringinuse_field, rtringinuse);
		}
		ast_queue_log(q->name, "NONE", interface, "RINGINUSE", "%d", ringinuse);
		/*** DOCUMENTATION
		<managerEventInstance>
			<synopsis>Raised when a member's ringinuse setting is changed.</synopsis>
			<syntax>
				<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />
				<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />
				<parameter name="Ringinuse">
					<enumlist>
						<enum name="0"/>
						<enum name="1"/>
					</enumlist>
				</parameter>
			</syntax>
			<see-also>
				<ref type="function">QUEUE_MEMBER</ref>
			</see-also>
		</managerEventInstance>
		***/
		manager_event(EVENT_FLAG_AGENT, "QueueMemberRinginuse",
			"Queue: %s\r\n"
			"Location: %s\r\n"
			"Ringinuse: %d\r\n",
			q->name, mem->interface, ringinuse);
		ao2_ref(mem, -1);
	}
	ao2_unlock(q);
	return foundinterface;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cx_fw_version(struct ipmi_intf *intf, char *version)
{
	struct ipmi_rs *rsp;
	struct ipmi_rq req;
	uint8_t msg_data[64];
	int i;
	memset(&req, 0, sizeof(req));
	memset(msg_data, 0, sizeof(msg_data));
	req.msg.netfn = IPMI_NETFN_OEM_SS;
	req.msg.cmd = IPMI_CMD_OEM_FW_SET_STATUS;
	msg_data[0] = 0;	// resvd
	msg_data[1] = 4;	// param = 4 = "set version"
	strncpy(&msg_data[2], version, 32);
	req.msg.data = msg_data;
	req.msg.data_len = 34;
	rsp = intf->sendrecv(intf, &req);
	if (rsp == NULL) {
		lprintf(LOG_ERR, "Error setting firmware version");
		return -1;
	}
	if (rsp->ccode > 0) {
		lprintf(LOG_ERR, "Error: %s",
			val2str(rsp->ccode, completion_code_vals));
		return -1;
	}
	return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
dcc_request(DCC_REC *dcc)
{
	char *service;
	g_return_if_fail(dcc != NULL);
	if (dcc->port < 1024) {
                /* warn about connecting to lowports */
		service = net_getservbyport(dcc->port);
		printformat(dcc->server, NULL, MSGLEVEL_DCC,
			    IRCTXT_DCC_LOWPORT, dcc->port,
			    service != NULL ? service : "unknown");
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
der_put_general_string (unsigned char *p, size_t len, 
			const general_string *str, size_t *size)
{
    size_t slen = strlen(*str);
    if (len < slen)
	return ASN1_OVERFLOW;
    p -= slen;
    len -= slen;
    memcpy (p+1, *str, slen);
    *size = slen;
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
znotify(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    gs_context_t *current = (gs_context_t *)i_ctx_p;
    gs_condition_t *pcond;
    check_stype(*op, st_condition);
    pcond = r_ptr(op, gs_condition_t);
    if_debug1('"', "[\"]notify 0x%lx\n", (ulong) pcond);
    pop(1);
    op--;
    if (pcond->waiting.head_index == 0)	/* nothing to do */
        return 0;
    activate_waiting(current->scheduler, &pcond->waiting);
    return zyield(i_ctx_p);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
closeout()
{
    char *saveoutptr;
    if (outstage == 3)
    {
	saveoutptr = outbufptr;
	flushout();		/* buffer from last stage */
	outbufptr = saveoutptr;
    }
    outstage = 0;		/* flush from top to current ptr */
    flushout();
    close(output);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
samsung_sysfs_is_visible(struct kobject *kobj,
					struct attribute *attr, int idx)
{
	struct device *dev = container_of(kobj, struct device, kobj);
	struct platform_device *pdev = to_platform_device(dev);
	struct samsung_laptop *samsung = platform_get_drvdata(pdev);
	bool ok = true;
	if (attr == &dev_attr_performance_level.attr)
		ok = !!samsung->config->performance_levels[0].name;
	if (attr == &dev_attr_battery_life_extender.attr)
		ok = !!(read_battery_life_extender(samsung) >= 0);
	if (attr == &dev_attr_usb_charge.attr)
		ok = !!(read_usb_charge(samsung) >= 0);
	if (attr == &dev_attr_lid_handling.attr)
		ok = !!(read_lid_handling(samsung) >= 0);
	return ok ? attr->mode : 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
znzputc(int c, znzFile file)
{
  if (file==NULL) { return 0; }
#ifdef HAVE_ZLIB
  if (file->zfptr!=NULL) return gzputc(file->zfptr,c);
#endif
  return fputc(c,file->nzfptr);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
libgnac_converter_eos_cb(GstBus     *bus, 
                         GstMessage *message, 
                         gpointer    data)
{
  LibgnacConverter *converter = (LibgnacConverter *) data;
  g_return_if_fail(LIBGNAC_IS_CONVERTER(converter));
  LibgnacMediaItem *item = converter->priv->current;
  gchar *uri = g_file_get_uri(item->source);
  g_signal_emit(converter, signals[FILE_COMPLETED], 0, uri);
  g_free(uri);
  /* Start next file conversion */
  if (!libgnac_converter_start_next(converter)) {
    converter->priv->n_converted = -1;
    g_signal_emit(converter, signals[COMPLETION], 0);
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Perl_mro_get_linear_isa(pTHX_ HV *stash)
{
    struct mro_meta* meta;
    AV *isa;
    PERL_ARGS_ASSERT_MRO_GET_LINEAR_ISA;
    if(!SvOOK(stash))
        Perl_croak(aTHX_ "Can't linearize anonymous symbol table");
    meta = HvMROMETA(stash);
    if (!meta->mro_which)
        Perl_croak(aTHX_ "panic: invalid MRO!");
    isa = meta->mro_which->resolve(aTHX_ stash, 0);
    if (meta->mro_which != &dfs_alg) { /* skip for dfs, for speed */
	SV * const namesv =
	    (HvENAME(stash)||HvNAME(stash))
	      ? newSVhek(HvENAME_HEK(stash)
			  ? HvENAME_HEK(stash)
			  : HvNAME_HEK(stash))
	      : NULL;
	if(namesv && (AvFILLp(isa) == -1 || !sv_eq(*AvARRAY(isa), namesv)))
	{
	    AV * const old = isa;
	    SV **svp;
	    SV **ovp = AvARRAY(old);
	    SV * const * const oend = ovp + AvFILLp(old) + 1;
	    isa = (AV *)sv_2mortal((SV *)newAV());
	    av_extend(isa, AvFILLp(isa) = AvFILLp(old)+1);
	    *AvARRAY(isa) = namesv;
	    svp = AvARRAY(isa)+1;
	    while (ovp < oend) *svp++ = SvREFCNT_inc(*ovp++);
	}
	else SvREFCNT_dec(namesv);
    }
    if (!meta->isa) {
	    HV *const isa_hash = newHV();
	    /* Linearisation didn't build it for us, so do it here.  */
	    SV *const *svp = AvARRAY(isa);
	    SV *const *const svp_end = svp + AvFILLp(isa) + 1;
	    const HEK *canon_name = HvENAME_HEK(stash);
	    if (!canon_name) canon_name = HvNAME_HEK(stash);
	    while (svp < svp_end) {
		(void) hv_store_ent(isa_hash, *svp++, &PL_sv_undef, 0);
	    }
	    (void) hv_common(isa_hash, NULL, HEK_KEY(canon_name),
			     HEK_LEN(canon_name), HEK_FLAGS(canon_name),
			     HV_FETCH_ISSTORE, &PL_sv_undef,
			     HEK_HASH(canon_name));
	    (void) hv_store(isa_hash, "UNIVERSAL", 9, &PL_sv_undef, 0);
	    SvREADONLY_on(isa_hash);
	    meta->isa = isa_hash;
    }
    return isa;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
strip_path_suffix(const char *path, const char *suffix)
{
	int path_len = strlen(path), suffix_len = strlen(suffix);
	while (suffix_len) {
		if (!path_len)
			return NULL;
		if (is_dir_sep(path[path_len - 1])) {
			if (!is_dir_sep(suffix[suffix_len - 1]))
				return NULL;
			path_len = chomp_trailing_dir_sep(path, path_len);
			suffix_len = chomp_trailing_dir_sep(suffix, suffix_len);
		}
		else if (path[--path_len] != suffix[--suffix_len])
			return NULL;
	}
	if (path_len && !is_dir_sep(path[path_len - 1]))
		return NULL;
	return xstrndup(path, chomp_trailing_dir_sep(path, path_len));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
WXMPUtils_ComposeArrayItemPath_1 ( XMP_StringPtr   schemaNS,
								   XMP_StringPtr   arrayName,
								   XMP_Index	   itemIndex,
								   void *          itemPath,
								   SetClientStringProc SetClientString,
								   WXMP_Result *   wResult )
{
	XMP_ENTER_Static ( "WXMPUtils_ComposeArrayItemPath_1" )
		if ( (schemaNS == 0) || (*schemaNS == 0) ) XMP_Throw ( "Empty schema namespace URI", kXMPErr_BadSchema );
		if ( (arrayName == 0) || (*arrayName == 0) ) XMP_Throw ( "Empty array name", kXMPErr_BadXPath );
		XMP_VarString localStr;
		XMPUtils::ComposeArrayItemPath ( schemaNS, arrayName, itemIndex, &localStr );
		if ( itemPath != 0 ) (*SetClientString) ( itemPath, localStr.c_str(), localStr.size() );
	XMP_EXIT
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
updateState( const QPaintEngineState &state )
    {
        if ( state.state() & QPaintEngine::DirtyPen )
        {
            d_pen = state.pen();
        }
        if ( state.state() & QPaintEngine::DirtyBrush )
        {
            d_brush = state.brush();
        }
        if ( state.state() & QPaintEngine::DirtyBrushOrigin )
        {
            d_origin = state.brushOrigin();
        }
    }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
mprGrowBuf(MprBuf *bp, ssize need)
{
    char    *newbuf;
    ssize   growBy;
    if (bp->maxsize > 0 && bp->buflen >= bp->maxsize) {
        return MPR_ERR_TOO_MANY;
    }
    if (bp->start > bp->end) {
        mprCompactBuf(bp);
    }
    if (need > 0) {
        growBy = max(bp->growBy, need);
    } else {
        growBy = bp->growBy;
    }
    if ((newbuf = mprAlloc(bp->buflen + growBy)) == 0) {
        mprAssert(!MPR_ERR_MEMORY);
        return MPR_ERR_MEMORY;
    }
    if (bp->data) {
        memcpy(newbuf, bp->data, bp->buflen);
    }
    bp->buflen += growBy;
    bp->end = newbuf + (bp->end - bp->data);
    bp->start = newbuf + (bp->start - bp->data);
    bp->data = newbuf;
    bp->endbuf = &bp->data[bp->buflen];
    /*
        Increase growBy to reduce overhead
     */
    if (bp->maxsize > 0) {
        if ((bp->buflen + (bp->growBy * 2)) > bp->maxsize) {
            bp->growBy = min(bp->maxsize - bp->buflen, bp->growBy * 2);
        }
    } else {
        if ((bp->buflen + (bp->growBy * 2)) > bp->maxsize) {
            bp->growBy = min(bp->buflen, bp->growBy * 2);
        }
    }
    return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
init_ic_make_global_vars (void)
{
  tree  gcov_type_ptr;
  ptr_void = build_pointer_type (void_type_node);
  ic_void_ptr_var
    = build_decl (UNKNOWN_LOCATION, VAR_DECL,
		  get_identifier ("__gcov_indirect_call_callee"),
		  ptr_void);
  TREE_STATIC (ic_void_ptr_var) = 1;
  TREE_PUBLIC (ic_void_ptr_var) = 0;
  DECL_ARTIFICIAL (ic_void_ptr_var) = 1;
  DECL_INITIAL (ic_void_ptr_var) = NULL;
  if (targetm.have_tls)
    DECL_TLS_MODEL (ic_void_ptr_var) =
      decl_default_tls_model (ic_void_ptr_var);
  varpool_finalize_decl (ic_void_ptr_var);
  gcov_type_ptr = build_pointer_type (get_gcov_type ());
  ic_gcov_type_ptr_var
    = build_decl (UNKNOWN_LOCATION, VAR_DECL,
		  get_identifier ("__gcov_indirect_call_counters"),
		  gcov_type_ptr);
  TREE_STATIC (ic_gcov_type_ptr_var) = 1;
  TREE_PUBLIC (ic_gcov_type_ptr_var) = 0;
  DECL_ARTIFICIAL (ic_gcov_type_ptr_var) = 1;
  DECL_INITIAL (ic_gcov_type_ptr_var) = NULL;
  if (targetm.have_tls)
    DECL_TLS_MODEL (ic_gcov_type_ptr_var) =
      decl_default_tls_model (ic_gcov_type_ptr_var);
  varpool_finalize_decl (ic_gcov_type_ptr_var);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cpl_table_sort(cpl_table *table, const cpl_propertylist *reflist)
{
    cpl_size      *sort_pattern, *sort_null_pattern;
    cpl_error_code ec;
    if (table == NULL || reflist == NULL)
        return cpl_error_set_(CPL_ERROR_NULL_INPUT);
    if (cpl_propertylist_get_size(reflist) == 0)
        return cpl_error_set_(CPL_ERROR_ILLEGAL_INPUT);
    if (table->nr < 2)
        return CPL_ERROR_NONE;
    sort_pattern      = cpl_malloc(table->nr * sizeof(cpl_size));
    sort_null_pattern = cpl_malloc(table->nr * sizeof(cpl_size));
    ec = table_sort(table, reflist, cpl_propertylist_get_size(reflist),
                    sort_pattern, sort_null_pattern);
    cpl_free(sort_pattern);
    cpl_free(sort_null_pattern);
    return ec;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
dp83867_config_init(struct phy_device *phydev)
{
	struct dp83867_private *dp83867;
	int ret;
	u16 val, delay;
	if (!phydev->priv) {
		dp83867 = devm_kzalloc(&phydev->dev, sizeof(*dp83867),
				       GFP_KERNEL);
		if (!dp83867)
			return -ENOMEM;
		phydev->priv = dp83867;
		ret = dp83867_of_init(phydev);
		if (ret)
			return ret;
	} else {
		dp83867 = (struct dp83867_private *)phydev->priv;
	}
	if (phy_interface_is_rgmii(phydev)) {
		ret = phy_write(phydev, MII_DP83867_PHYCTRL,
			(dp83867->fifo_depth << DP83867_PHYCR_FIFO_DEPTH_SHIFT));
		if (ret)
			return ret;
	}
	if ((phydev->interface >= PHY_INTERFACE_MODE_RGMII_ID) &&
	    (phydev->interface <= PHY_INTERFACE_MODE_RGMII_RXID)) {
		val = phy_read_mmd_indirect(phydev, DP83867_RGMIICTL,
					    DP83867_DEVADDR, phydev->addr);
		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)
			val |= (DP83867_RGMII_TX_CLK_DELAY_EN | DP83867_RGMII_RX_CLK_DELAY_EN);
		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)
			val |= DP83867_RGMII_TX_CLK_DELAY_EN;
		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)
			val |= DP83867_RGMII_RX_CLK_DELAY_EN;
		phy_write_mmd_indirect(phydev, DP83867_RGMIICTL,
				       DP83867_DEVADDR, phydev->addr, val);
		delay = (dp83867->rx_id_delay |
			(dp83867->tx_id_delay << DP83867_RGMII_TX_CLK_DELAY_SHIFT));
		phy_write_mmd_indirect(phydev, DP83867_RGMIIDCTL,
				       DP83867_DEVADDR, phydev->addr, delay);
	}
	/* Enable Interrupt output INT_OE in CFG3 register */
	if (phy_interrupt_is_valid(phydev)) {
		val = phy_read(phydev, DP83867_CFG3);
		val |= BIT(7);
		phy_write(phydev, DP83867_CFG3, val);
	}
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_wapi_handle_ops_isowned (gpointer handle)
{
	guint32 idx = GPOINTER_TO_UINT(handle);
	WapiHandleType type;
	if (!_WAPI_PRIVATE_VALID_SLOT (idx)) {
		return(FALSE);
	}
	type = _WAPI_PRIVATE_HANDLES(idx).type;
	if (handle_ops[type] != NULL && handle_ops[type]->is_owned != NULL) {
		return(handle_ops[type]->is_owned (handle));
	} else {
		return(FALSE);
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ndmp_sxa_mover_set_window (struct ndm_session *sess,
  struct ndmp_xa_buf *xa, struct ndmconn *ref_conn)
{
	struct ndm_tape_agent *	ta = &sess->tape_acb;
	struct ndmp9_mover_get_state_reply *ms = &ta->mover_state;
	unsigned long long	max_len;
	unsigned long long	end_win;
      NDMS_WITH(ndmp9_mover_set_window)
	ndmta_mover_sync_state (sess);
	if (ref_conn->protocol_version < NDMP4VER) {
		/*
		 * NDMP[23] require the Mover be in LISTEN state.
		 * Unclear sequence for MOVER_CONNECT.
		 */
		if (ms->state != NDMP9_MOVER_STATE_LISTEN
		 && ms->state != NDMP9_MOVER_STATE_PAUSED) {
			NDMADR_RAISE_ILLEGAL_STATE("mover_state !LISTEN/PAUSED");
		}
	} else {
		/*
		 * NDMP4 require the Mover be in IDLE state.
		 * This always preceeds both MOVER_LISTEN or
		 * MOVER_CONNECT.
		 */
		if (ms->state != NDMP9_MOVER_STATE_IDLE
		 && ms->state != NDMP9_MOVER_STATE_PAUSED) {
			NDMADR_RAISE_ILLEGAL_STATE("mover_state !IDLE/PAUSED");
		}
	}
	if (request->offset % ms->record_size != 0) {
		NDMADR_RAISE_ILLEGAL_ARGS("off !record_size");
	}
	/* TODO: NDMPv4 subtle semantic changes here */
	/* If a maximum length window is required following a mover transition
	 * to the PAUSED state, a window length of all ones (binary) minus the
	 * current window offset MUST be specified." (NDMPv4 RFC, Section
	 * 3.6.2.2) -- we allow length = NDMP_LENGTH_INFINITY too */
	if (request->length != NDMP_LENGTH_INFINITY
		&& request->length + request->offset != NDMP_LENGTH_INFINITY) {
		if (request->length % ms->record_size != 0) {
			NDMADR_RAISE_ILLEGAL_ARGS("len !record_size");
		}
#if 0
		/* Too pedantic. Sometimes needed (like for testing) */
		if (request->length == 0) {
			NDMADR_RAISE_ILLEGAL_ARGS("length 0");
		}
#endif
		max_len = NDMP_LENGTH_INFINITY - request->offset;
		max_len -= max_len % ms->record_size;
		if (request->length > max_len) {  /* learn math fella */
			NDMADR_RAISE_ILLEGAL_ARGS("length too long");
		}
		end_win = request->offset + request->length;
	} else {
		end_win = NDMP_LENGTH_INFINITY;
	}
	ms->window_offset = request->offset;
	/* record_num should probably be one less than this value, but the spec
	 * says to divide, so we divide */
	ms->record_num = request->offset / ms->record_size;
	ms->window_length = request->length;
	ta->mover_window_end = end_win;
	ta->mover_window_first_blockno = ta->tape_state.blockno.value;
	return 0;
      NDMS_ENDWITH
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
scsifront_put_rqid(struct vscsifrnt_info *info, uint32_t id)
{
	unsigned long flags;
	int kick;
	spin_lock_irqsave(&info->shadow_lock, flags);
	kick = _scsifront_put_rqid(info, id);
	spin_unlock_irqrestore(&info->shadow_lock, flags);
	if (kick)
		scsifront_wake_up(info);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
getVectors( std::vector<aiVector3D>& vecs )
{
	vecs.resize(vecMap.size());
	for(vecIndexMap::dataType::iterator it = vecMap.begin(); it != vecMap.end(); it++){
		vecs[it->second-1] = it->first;
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
printheader(struct fetchheaderinfo *fi, const char *p, size_t s)
{
	size_t i;
	if (fi->skipping)
	{
		if (fi->skipping > s)
		{
			fi->skipping -= s;
			return;
		}
		p += fi->skipping;
		s -= fi->skipping;
		fi->skipping=0;
	}
	if (s > fi->cnt)	s=fi->cnt;
	for (i=0; i <= s; i++)
		if (p[i] != '\r')
			++header_count;
	writemem(p, s);
	fi->cnt -= s;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
simpleSplit (const UT_String & str, char separator,
						 size_t max)
{
	UT_GenericVector<UT_String*> * utvResult = new UT_GenericVector<UT_String*>();
	UT_String* utsEntry;
	UT_uint32 start = 0;
	for(size_t j = 0; (max == 0 || j < max) && start < str.size(); j++)
	{
		utsEntry = new UT_String;
		for (; (str[start] != separator || j == max - 1) && start < str.size(); start++)
			*utsEntry += str[start];
		start++;						// skipping over the separator character
										// itself
		if (utsEntry->empty())
			delete utsEntry;
		else
			utvResult->addItem(utsEntry);
	}
	return utvResult;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
get_genomic_range(const void *sa)
{
  GtSSplicedAlignment *alignment = *(GtSSplicedAlignment**) sa;
  gt_assert(alignment);
  return gt_sspliced_alignment_genomic_range(alignment);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_mesa_remove_dead_code_local(struct gl_program *prog)
{
   GLboolean *removeInst;
   GLuint i, arg, rem = 0;
   removeInst =
      calloc(1, prog->NumInstructions * sizeof(GLboolean));
   for (i = 0; i < prog->NumInstructions; i++) {
      const struct prog_instruction *inst = prog->Instructions + i;
      const GLuint index = inst->DstReg.Index;
      const GLuint mask = inst->DstReg.WriteMask;
      enum inst_use use;
      /* We must deactivate the pass as soon as some indirection is used */
      if (inst->DstReg.RelAddr)
         goto done;
      for (arg = 0; arg < _mesa_num_inst_src_regs(inst->Opcode); arg++)
         if (inst->SrcReg[arg].RelAddr)
            goto done;
      if (_mesa_is_flow_control_opcode(inst->Opcode) ||
          _mesa_num_inst_dst_regs(inst->Opcode) == 0 ||
          inst->DstReg.File != PROGRAM_TEMPORARY ||
          inst->DstReg.RelAddr)
         continue;
      use = find_next_use(prog, i+1, index, mask);
      if (use == WRITE || use == END)
         removeInst[i] = GL_TRUE;
   }
   rem = remove_instructions(prog, removeInst);
done:
   free(removeInst);
   return rem != 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
set_mode(struct device *dev, struct device_attribute *attr,
			const char *buf, size_t count)
{
	struct virtual_consumer_data *data = dev_get_drvdata(dev);
	unsigned int mode;
	int ret;
	/*
	 * sysfs_streq() doesn't need the \n's, but we add them so the strings
	 * will be shared with show_mode(), above.
	 */
	if (sysfs_streq(buf, "fast\n"))
		mode = REGULATOR_MODE_FAST;
	else if (sysfs_streq(buf, "normal\n"))
		mode = REGULATOR_MODE_NORMAL;
	else if (sysfs_streq(buf, "idle\n"))
		mode = REGULATOR_MODE_IDLE;
	else if (sysfs_streq(buf, "standby\n"))
		mode = REGULATOR_MODE_STANDBY;
	else {
		dev_err(dev, "Configuring invalid mode\n");
		return count;
	}
	mutex_lock(&data->lock);
	ret = regulator_set_mode(data->regulator, mode);
	if (ret == 0)
		data->mode = mode;
	else
		dev_err(dev, "Failed to configure mode: %d\n", ret);
	mutex_unlock(&data->lock);
	return count;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
readFData( FILE* fp, fData* t, const fDataType* types )
{
  char** currentRow;
  char*  rowPtr;
  int rowCount = 0;
  int i;
  int errFlag = 0;//not used, but possibly for future usage. set when data types disagree
  //allocate the datatypes table, and set the default values
  t->types = (fDataType*)malloc( sizeof(fDataType) * t->numCols );
  for(i=0;i<t->numCols;i++) { t->types[i].type = INT; t->types[i].sigDigits = 0; t->types[i].inSigDigits = 0; }
  //allocate the first row of data
  t->data = (char***)malloc((sizeof( char** )) );
  while(!EOFDETECTED)
    {
      //read in a row
      if((rowPtr = getRow(fp))==NULL) break; //this is not really an error
      //parse the row
      currentRow = readRow( rowPtr, t->numCols );
      if(types != NULL)//check to see if the dataTypes in TYPES are OK with the data read.
	{
	  if(!verifyRow(currentRow, types, t->numCols)) {fprintf(stderr,"On row %d\n", rowCount);errFlag = 1;}
	}
      if(EOFDETECTED) break;
      if(! currentRow )
	{ fprintf(stderr,"Flib::readRawData: I cant read line #%d\n",rowCount); t->data = NULL; return 1;; }
      //make space for another row
      t->data = (char***) realloc( t->data, (sizeof(char**) * (rowCount + 1)) );
      //set the values for the row, and increment rowCount
      t->data[rowCount++] = currentRow;
      getDataTypes( t->numCols, t->types, currentRow );
      free(rowPtr);
    }
  t->numRows = rowCount;
  return errFlag;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
stk3310_read_raw(struct iio_dev *indio_dev,
			    struct iio_chan_spec const *chan,
			    int *val, int *val2, long mask)
{
	u8 reg;
	__be16 buf;
	int ret;
	unsigned int index;
	struct stk3310_data *data = iio_priv(indio_dev);
	struct i2c_client *client = data->client;
	if (chan->type != IIO_LIGHT && chan->type != IIO_PROXIMITY)
		return -EINVAL;
	switch (mask) {
	case IIO_CHAN_INFO_RAW:
		if (chan->type == IIO_LIGHT)
			reg = STK3310_REG_ALS_DATA_MSB;
		else
			reg = STK3310_REG_PS_DATA_MSB;
		mutex_lock(&data->lock);
		ret = regmap_bulk_read(data->regmap, reg, &buf, 2);
		if (ret < 0) {
			dev_err(&client->dev, "register read failed\n");
			mutex_unlock(&data->lock);
			return ret;
		}
		*val = be16_to_cpu(buf);
		mutex_unlock(&data->lock);
		return IIO_VAL_INT;
	case IIO_CHAN_INFO_INT_TIME:
		if (chan->type == IIO_LIGHT)
			ret = regmap_field_read(data->reg_als_it, &index);
		else
			ret = regmap_field_read(data->reg_ps_it, &index);
		if (ret < 0)
			return ret;
		*val = stk3310_it_table[index][0];
		*val2 = stk3310_it_table[index][1];
		return IIO_VAL_INT_PLUS_MICRO;
	case IIO_CHAN_INFO_SCALE:
		if (chan->type == IIO_LIGHT)
			ret = regmap_field_read(data->reg_als_gain, &index);
		else
			ret = regmap_field_read(data->reg_ps_gain, &index);
		if (ret < 0)
			return ret;
		*val = stk3310_scale_table[index][0];
		*val2 = stk3310_scale_table[index][1];
		return IIO_VAL_INT_PLUS_MICRO;
	}
	return -EINVAL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
arma_model_get_x_coeffs (const MODEL *pmod)
{
    const double *xc = NULL;
    if (pmod->ci == ARMA && gretl_model_get_int(pmod, "armax")) {
	xc = pmod->coeff;
	xc += pmod->ifc;
	xc += arma_AR_lags(pmod);
	xc += arma_MA_lags(pmod);
	xc += gretl_model_get_int(pmod, "arma_P");
	xc += gretl_model_get_int(pmod, "arma_Q");
    }
    return xc;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Sop_a8_to_Dacc( GenefxState *gfxs )
{
     int                w = gfxs->length;
     GenefxAccumulator *D = gfxs->Dacc;
     u8                *S = gfxs->Sop[0];
     while (w--) {
          D->RGB.a = *S++;
          D->RGB.r = 0xFF;
          D->RGB.g = 0xFF;
          D->RGB.b = 0xFF;
          D++;
     }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
getCopyStart(PGconn *conn, ExecStatusType copytype)
{
	PGresult   *result;
	int			nfields;
	int			i;
	result = PQmakeEmptyPGresult(conn, copytype);
	if (!result)
		goto failure;
	if (pqGetc(&conn->copy_is_binary, conn))
		goto failure;
	result->binary = conn->copy_is_binary;
	/* the next two bytes are the number of fields	*/
	if (pqGetInt(&(result->numAttributes), 2, conn))
		goto failure;
	nfields = result->numAttributes;
	/* allocate space for the attribute descriptors */
	if (nfields > 0)
	{
		result->attDescs = (PGresAttDesc *)
			pqResultAlloc(result, nfields * sizeof(PGresAttDesc), TRUE);
		if (!result->attDescs)
			goto failure;
		MemSet(result->attDescs, 0, nfields * sizeof(PGresAttDesc));
	}
	for (i = 0; i < nfields; i++)
	{
		int			format;
		if (pqGetInt(&format, 2, conn))
			goto failure;
		/*
		 * Since pqGetInt treats 2-byte integers as unsigned, we need to
		 * coerce these results to signed form.
		 */
		format = (int) ((int16) format);
		result->attDescs[i].format = format;
	}
	/* Success! */
	conn->result = result;
	return 0;
failure:
	PQclear(result);
	return EOF;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
MV_Mix16BitStereo16Stereo( unsigned int position, unsigned int rate,
                         char *start, unsigned int length )
{
    unsigned short *source = (unsigned short *) start;
    short *dest = (short *) MV_MixDestination;
    int sample0l, sample0h, sample0;
    int sample1l, sample1h, sample1;
    while (length--) {
        sample0 = source[(position >> 16) << 1];
        sample1 = source[((position >> 16) << 1) + 1];
#ifdef BIGENDIAN
        sample0l = sample0 >> 8;
        sample0h = (sample0 & 255) ^ 128;
        sample1l = sample1 >> 8;
        sample1h = (sample1 & 255) ^ 128;
#else
        sample0l = sample0 & 255;
        sample0h = (sample0 >> 8) ^ 128;
        sample1l = sample1 & 255;
        sample1h = (sample1 >> 8) ^ 128;
#endif
        position += rate;
        sample0l = MV_LeftVolume[sample0l] >> 8;
        sample0h = MV_LeftVolume[sample0h];
        sample1l = MV_RightVolume[sample1l] >> 8;
        sample1h = MV_RightVolume[sample1h];
        sample0 = sample0l + sample0h + 128 + *dest;
        sample1 = sample1l + sample1h + 128 + *(dest + MV_RightChannelOffset/2);
        if (sample0 < -32768) sample0 = -32768;
        else if (sample0 > 32767) sample0 = 32767;
        if (sample1 < -32768) sample1 = -32768;
        else if (sample1 > 32767) sample1 = 32767;
        *dest = (short) sample0;
        *(dest + MV_RightChannelOffset/2) = (short) sample1;
        dest += MV_SampleSize / 2;
    }
    MV_MixPosition = position;
    MV_MixDestination = (char *) dest;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
scld_dock_exrom_from_snapshot( memory_page *dest, int page_num, int writable,
                               void *source )
{
  int i;
  libspectrum_byte *data = memory_pool_allocate( 0x2000 );
  memcpy( data, source, 0x2000 );
  for( i = 0; i < MEMORY_PAGES_IN_8K; i++ ) {
    memory_page *page = &dest[ page_num * MEMORY_PAGES_IN_8K + i ];
    page->offset = i * MEMORY_PAGE_SIZE;
    page->page_num = page_num;
    page->writable = writable;
    page->page = data + page->offset;
    page->save_to_snapshot = 1;
  }
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
kook_ASSURE_asm(CTX ctx, kStmtExpr *stmt)
{
	kStmtExpr *stmt0 = stmtNN(stmt, 0);
	kStmtExpr *stmt1 = stmtNN(stmt, 1);
	CALL(ctx, COMPILER_API.ASSURE, 3, stmt, stmt0, stmt1);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
define_attr_by_hp(HSCPRC * hp, STRPTR default_value, ULONG unmasked_flags)
{
   HSCATTR *attr = define_var(hp, hp->defattr, 0);
   if (attr)
   {
      /* set scope for local attribute */
      attr->macro_id = ((attr->varflag & VF_GLOBAL) ?
         MCI_GLOBAL : get_current_mci(hp));
      /* see "attrib.h" why this */
      attr->varflag |= VF_MACRO;
      /* set new value (copy from default) if passed */
      if (get_vardeftext(attr)) {
         if (default_value)
            panic("default value already set");
         else
            clr_vartext(attr);
      }
      /* set default value passed in function args */
      if (default_value)
         set_vartext(attr, default_value);
      /* remove default value */
      clr_attrdef(attr);
   }
   return (attr);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
getQuaternaries(uint32_t variableTop, uint32_t pair) {
    // Return the primary weight of a variable CE,
    // or the maximum primary weight for a non-variable, not-completely-ignorable CE.
    if(pair <= 0xffff) {
        // one mini CE
        if(pair >= MIN_SHORT) {
            // A high secondary weight means we really have two CEs,
            // a primary CE and a secondary CE.
            if((pair & SECONDARY_MASK) >= MIN_SEC_HIGH) {
                pair = TWO_SHORT_PRIMARIES_MASK;
            } else {
                pair = SHORT_PRIMARY_MASK;
            }
        } else if(pair > variableTop) {
            pair = SHORT_PRIMARY_MASK;
        } else if(pair >= MIN_LONG) {
            pair &= LONG_PRIMARY_MASK;  // variable
        }
        // else special mini CE
    } else {
        // two mini CEs, same primary groups, neither expands like above
        uint32_t ce = pair & 0xffff;
        if(ce > variableTop) {
            pair = TWO_SHORT_PRIMARIES_MASK;
        } else {
            U_ASSERT(ce >= MIN_LONG);
            pair &= TWO_LONG_PRIMARIES_MASK;  // variable
        }
    }
    return pair;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Java_ncsa_hdf_hdflib_HDFLibrary_SDsetcal
( JNIEnv *env,
jclass clss,
jint sds_id,
jdouble cal,
jdouble cal_err,
jdouble offset,
jdouble offset_err,
jint number_type)
{
    intn rval;
    rval = SDsetcal((int32) sds_id, (float64) cal, (float64) cal_err,
        (float64) offset, (float64) offset_err, (int32) number_type) ;
    if (rval==FAIL) {
        return JNI_FALSE;
    } else {
        return JNI_TRUE;
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cmd_objects_delete_undo (GnmCommand *cmd,
			G_GNUC_UNUSED WorkbookControl *wbc)
{
	CmdObjectsDelete *me = CMD_OBJECTS_DELETE (cmd);
	GSList *l;
	gint i;
	g_slist_foreach (me->objects,
		(GFunc) sheet_object_set_sheet, me->cmd.sheet);
	for (l = me->objects, i = 0; l; l = l->next, i++)
		cmd_objects_restore_location (SHEET_OBJECT (l->data),
					      g_array_index(me->location,
							    gint, i));
	return FALSE;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
retrieveModelPart(const QString & moduleID) {
	ModelPart * modelPart = m_partHash.value(moduleID, NULL);
	if (modelPart != NULL) return modelPart;
	if (m_referenceModel != NULL) {
		return m_referenceModel->retrieveModelPart(moduleID);
	}
	return NULL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
HENQueueScanner(Display *dpy, XEvent *ev, char *args)
{
    if (ev->type == LeaveNotify) {
	if (ev->xcrossing.window == ((HENScanArgs *) args)->w &&
	    ev->xcrossing.mode == NotifyNormal) {
	    ((HENScanArgs *) args)->leaves = True;
	    /*
	     * Only the last event found matters for the Inferior field.
	     */
	    ((HENScanArgs *) args)->inferior =
		(ev->xcrossing.detail == NotifyInferior);
	}
    } else if (ev->type == EnterNotify) {
	if (ev->xcrossing.mode == NotifyUngrab)
	    ((HENScanArgs *) args)->enters = True;
    }
    return (False);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ghw_read_lsleb128 (struct ghw_handler *h, int64_t *res)
{
  static const int64_t r_mask = -1;
  int64_t r = 0;
  unsigned int off = 0;
  while (1)
    {
      int v = fgetc (h->stream);
      if (v == EOF)
	return -1;
      r |= ((int64_t)(v & 0x7f)) << off;
      off += 7;
      if ((v & 0x80) == 0)
	{
	  if ((v & 0x40) && off < 64)
	    r |= r_mask << off;
	  break;
	}
    }
  *res = r;
  return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
sha256d(unsigned char *hash, const unsigned char *data, int len)
{
	uint32_t S[16], T[16];
	int i, r;
	sha256_init(S);
	for (r = len; r > -9; r -= 64) {
		if (r < 64)
			memset(T, 0, 64);
		memcpy(T, data + len - r, r > 64 ? 64 : (r < 0 ? 0 : r));
		if (r >= 0 && r < 64)
			((unsigned char *)T)[r] = 0x80;
		for (i = 0; i < 16; i++)
			T[i] = be32dec(T + i);
		if (r < 56)
			T[15] = 8 * len;
		sha256_transform(S, T, 0);
	}
	memcpy(S + 8, sha256d_hash1 + 8, 32);
	sha256_init(T);
	sha256_transform(T, S, 0);
	for (i = 0; i < 8; i++)
		be32enc((uint32_t *)hash + i, T[i]);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
jd_s_channel_read(mud_channel *pc, void *buf, int length, int sec_timeout, int *bytes_read)
{
   mud_device *pd = &msp->device[pc->dindex];
   int len=0;
   struct timeval tmo;
   fd_set master;
   fd_set readfd;
   int maxfd, ret;
   enum HPMUD_RESULT stat = HPMUD_R_IO_ERROR;
   *bytes_read = 0;
   if (pc->socket<0)
   {
      stat = HPMUD_R_INVALID_STATE;
      BUG("invalid data link socket=%d %s\n", pc->socket, pd->uri);
      goto bugout;
   }
   FD_ZERO(&master);
   FD_SET(pc->socket, &master);
   maxfd = pc->socket;
   tmo.tv_sec = sec_timeout;
   tmo.tv_usec = 0;
   readfd = master;
   ret = select(maxfd+1, &readfd, NULL, NULL, &tmo);
   if (ret < 0)
   {
      BUG("unable to read_channel: %m %s\n", pd->uri);
      goto bugout;
   }
   if (ret == 0)
   {
      stat = HPMUD_R_IO_TIMEOUT;
//      if (sec_timeout >= HPMUD_EXCEPTION_SEC_TIMEOUT)
         BUG("timeout read_channel sec=%d %s\n", sec_timeout, pd->uri);
      goto bugout;
   }
   else
   {
      if ((len = recv(pc->socket, buf, length, 0)) < 0)
      {
         BUG("unable to read_channel: %m %s\n", pd->uri);
         goto bugout;
      }
   }
   DBG("read socket=%d len=%d size=%d\n", pc->socket, len, length);
   DBG_DUMP(buf, len < 32 ? len : 32);
   *bytes_read = len;
   stat = HPMUD_R_OK;
bugout:
   return stat;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
escp2_set_printhead_speed(stp_vars_t *v)
{
  escp2_privdata_t *pd = get_privdata(v);
  const char *direction = stp_get_string_parameter(v, "PrintingDirection");
  int unidirectional = -1;
  if (direction && strcmp(direction, "Unidirectional") == 0)
    unidirectional = 1;
  else if (direction && strcmp(direction, "Bidirectional") == 0)
    unidirectional = 0;
  else if (pd->bidirectional_upper_limit >= 0 &&
	   pd->res->printed_hres * pd->res->printed_vres *
	   pd->res->vertical_passes >= pd->bidirectional_upper_limit)
    {
      stp_dprintf(STP_DBG_ESCP2, v,
		  "Setting unidirectional: hres %d vres %d passes %d total %d limit %d\n",
		  pd->res->printed_hres, pd->res->printed_vres,
		  pd->res->vertical_passes,
		  (pd->res->printed_hres * pd->res->printed_vres *
		   pd->res->vertical_passes),
		  pd->bidirectional_upper_limit);
      unidirectional = 1;
    }
  else if (pd->bidirectional_upper_limit >= 0)
    {
      stp_dprintf(STP_DBG_ESCP2, v,
		  "Setting bidirectional: hres %d vres %d passes %d total %d limit %d\n",
		  pd->res->printed_hres, pd->res->printed_vres,
		  pd->res->vertical_passes,
		  (pd->res->printed_hres * pd->res->printed_vres *
		   pd->res->vertical_passes),
		  pd->bidirectional_upper_limit);
      unidirectional = 0;
    }
  if (unidirectional == 1)
    {
      stp_send_command(v, "\033U", "c", 1);
      if (pd->res->hres > pd->physical_xdpi)
	stp_send_command(v, "\033(s", "bc", 2);
    }
  else if (unidirectional == 0)
    stp_send_command(v, "\033U", "c", 0);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Problem_11(const MATRIX &matrix){
    unsigned matrixSize = matrix.size();
    vector<vector<pair<int, int> > > matrixPreknowledge(matrixSize, vector<pair<int, int> >(matrixSize));
    preprocessMatrix(matrix, matrixPreknowledge);
    for(size_t i=matrixSize; i!=0; --i){
	bool temp = findSubsquares(matrixPreknowledge, i);
	if(temp)
	    return i;
    }
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
WalkLanguageTableElement(RefAST ast)
{
	RefAST astLabel = ast->getFirstChild();
	std::string staLabel(astLabel->getText().c_str());
	RefAST astItem = astLabel->getNextSibling();
	// Find or create the language class with that name:
	GdlLangClass * plcls;
	size_t ilcls;
	for (ilcls = 0; ilcls < m_vplcls.size(); ilcls++)
	{
		if (strcmp(m_vplcls[ilcls]->m_staLabel.c_str(), staLabel.c_str()) == 0)
		{
			plcls = m_vplcls[ilcls];
			break;
		}
	}
	if (ilcls >= m_vplcls.size())
	{
		plcls = new GdlLangClass(staLabel);
		m_vplcls.push_back(plcls);
	}
	WalkLanguageItem(astItem, plcls);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_callbacks_unregister(Evas_Object *obj)
{
   ELM_GESTURE_LAYER_DATA_GET(obj, sd);
   if (!sd->target) return;
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_MOUSE_DOWN, _mouse_down_cb);
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_MOUSE_MOVE, _mouse_move_cb);
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_MOUSE_UP, _mouse_up_cb);
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_MOUSE_WHEEL, _mouse_wheel_cb);
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_MULTI_DOWN, _multi_down_cb);
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_MULTI_MOVE, _multi_move_cb);
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_MULTI_UP, _multi_up_cb);
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_KEY_DOWN, _key_down_cb);
   evas_object_event_callback_del
     (sd->target, EVAS_CALLBACK_KEY_UP, _key_up_cb);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
git_remote_is_valid_name(
	const char *remote_name)
{
	git_buf buf = GIT_BUF_INIT;
	git_refspec refspec;
	int error = -1;
	if (!remote_name || *remote_name == '\0')
		return 0;
	git_buf_printf(&buf, "refs/heads/test:refs/remotes/%s/test", remote_name);
	error = git_refspec__parse(&refspec, git_buf_cstr(&buf), true);
	git_buf_free(&buf);
	git_refspec__free(&refspec);
	giterr_clear();
	return error == 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
clipRectangles(XRectangle *rects_,int n_,int ordering_)
{
  if (data()->shared()==MSTrue)
   {
     MSMessageLog::warningMessage("MSGC error: setting clip rectangle on a shared GC");
   }
  XSetClipRectangles(display(),gc(),clipXOrigin(),clipYOrigin(),rects_,n_,ordering_);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
generateLookupTable( void )
{
	// Declare Variables
	int i,j;
	// Allocate memory for lookup table w
	w = new double*[kp];
	// Traverse through kernel generating weight function
	// lookup table w
	// Assume kernel is uniform
	uniformKernel = true;
	for(i = 0; i < kp; i++)
    {
		switch(kernel[i])
		{
			// *Uniform Kernel* has weight funciton w(u) = 1
			// therefore, a weight funciton lookup table is
			// not needed for this kernel --> w[i] = NULL indicates
			// this
		case Uniform:
			w        [i] = NULL;  //weight function not needed for this kernel
			offset   [i] =    1;  //uniform kernel has u < 1.0
			increment[i] =    1;  //has no meaning
			break;
			// *Gaussian Kernel* has weight function w(u) = constant*exp(-u^2/[2h[i]^2])
		case Gaussian:
			// Set uniformKernel to false
			uniformKernel = false;
			// generate weight function using expression,
			// exp(-u/2), where u = norm(xi - x)^2/h^2
			// Allocate memory for weight table
			w[i] = new double [GAUSS_NUM_ELS+1];
			for(j = 0; j <= GAUSS_NUM_ELS; j++)
				w[i][j] = exp(-j*GAUSS_INCREMENT/2);
			// Set offset = offset^2, and set increment
			offset   [i] = (float)(GAUSS_LIMIT*GAUSS_LIMIT);
			increment[i] = GAUSS_INCREMENT;
			// done
			break;
			// *User Define Kernel* uses the weight function wf(u)
		case UserDefined:
			// Set uniformKernel to false
			uniformKernel = false;
			// Search for user defined weight function
			// defined for subspace (i+1)
			cur = head;
			while((cur)&&(cur->subspace != (i+1)))
				cur = cur->next;
			// If a user defined subspace has not been found
			// for this subspace, flag an error
			if(cur == NULL)
			{
				fprintf(stderr, "\ngenerateLookupTable Fatal Error: User defined kernel for subspace %d undefined.\n\nAborting Program.\n\n", i+1);
				exit(1);
			}
			// Otherwise, copy weight function lookup table to w[i]
			w[i] = new double [cur->sampleNumber+1];
			for(j = 0; j <= cur->sampleNumber; j++)
				w[i][j] = cur->w[j];
			// Set offset and increment accordingly
			offset   [i] = (float)(cur->halfWindow);
			increment[i] = cur->halfWindow/(float)(cur->sampleNumber);
			// done
			break;
		default:
			ErrorHandler("MeanShift", "generateLookupTable", "Unknown kernel type.");
		}
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
polynomialToFraction(Polynomial const &p)
{
  FieldRationalFunctions2Implementation *imp=dynamic_cast<FieldRationalFunctions2Implementation*>(implementingObject);
  Polynomial q=Term(imp->getPolynomialRing().getField().zHomomorphism(1),Monomial(imp->getPolynomialRing()));
  return new FieldElementRationalFunction2(*imp, p, q);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
w4_str(int fd, char *str)
{
	char buf[40];
	unsigned len = 0;
	int r;
	while (1) {
		r = read(fd, buf + len, sizeof(buf) - len - 1);
		if (r < 0) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			break;
		}
		if (!r)
			break;
		len += r;
		if (len < strlen(str))
			continue;
		buf[len] = 0;
		if (strstr(buf, str))
			return MS_SUCCESS;
		/* Detect PPP */
		if (strchr(buf, '~'))
			return MS_PPP;
	}
	return MS_FAILED;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
get_text_align_max_fill_size (int align_pow,
			      bfd_boolean use_nops,
			      bfd_boolean use_no_density)
{
  if (!use_nops)
    return (1 << align_pow);
  if (use_no_density)
    return 3 * (1 << align_pow);
  return 1 + (1 << align_pow);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
xsh_verify_2dmap_poly_input(cpl_frame* order_tab_edges_frame,
                       cpl_frame* spectralformat_frame,
                       cpl_frame* theo_tab_frame)
{
   cpl_table* tab_edges=NULL;
   cpl_table* tab_spectral_format=NULL;
   cpl_table* theo_tab=NULL;
   const char* name=NULL;
   int ord_min_ref=0;
   int ord_max_ref=0;
   int ord_min=0;
   int ord_max=0;
   check(name=cpl_frame_get_filename(order_tab_edges_frame));
   check(tab_edges=cpl_table_load(name,1,0));
   check(ord_min_ref=cpl_table_get_column_min(tab_edges,"ABSORDER"));
   check(ord_max_ref=cpl_table_get_column_max(tab_edges,"ABSORDER"));
   check(name=cpl_frame_get_filename(spectralformat_frame));
   check(tab_spectral_format=cpl_table_load(name,1,0));
   check(ord_min=cpl_table_get_column_min(tab_spectral_format,"ORDER"));
   check(ord_max=cpl_table_get_column_max(tab_spectral_format,"ORDER"));
   if(ord_min != ord_min_ref) {
      xsh_msg_error("Edge order table's ord_min != spectral format table's ord_min");
      return CPL_ERROR_INCOMPATIBLE_INPUT;
   }
   if(ord_max != ord_max_ref) {
      xsh_msg_error("Edge order table's ord_max != spectral format table's ord_max");
      return CPL_ERROR_INCOMPATIBLE_INPUT;
   }
   if(theo_tab_frame != NULL) {
      check(name=cpl_frame_get_filename(theo_tab_frame));
      check(theo_tab=cpl_table_load(name,1,0));
      check(ord_min=cpl_table_get_column_min(theo_tab,"Order"));
      check(ord_max=cpl_table_get_column_max(theo_tab,"Order"));
      if(ord_min != ord_min_ref) {
         xsh_msg_error("Theo table's ord_min != spectral format table's ord_min");
         return CPL_ERROR_INCOMPATIBLE_INPUT;
      }
      if(ord_max != ord_max_ref) {
         xsh_msg_error("Theo table's ord_max != spectral format table's ord_max");
         return CPL_ERROR_INCOMPATIBLE_INPUT;
      }
   }
 cleanup:
   xsh_free_table(&tab_edges);
   xsh_free_table(&tab_spectral_format);
   xsh_free_table(&theo_tab);
   return cpl_error_get_code();
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
doelectricity (void)
{
   int leftelectrax;
   int rightelectrax;
   int temp;
   int n;
   if (levelinfo.electrasflag && levelinfo.electraoffset == 0)    // When electra enemies ride over the main lightning...
   {
      for (n = 0; n < MAX_ENEMIES; n++)
      {
         if (enemy[n].exists && enemy[n].type == ELECTRA && enemy[enemy[n].intvar].exists)   // If both electras exist...
         {
            leftelectrax = enemy[n].x;
            rightelectrax = enemy[enemy[n].intvar].x;
            if (rightelectrax < leftelectrax)
            {
               temp = leftelectrax; leftelectrax = rightelectrax; rightelectrax = temp;
            }
            drawelectricity(LIGHTNINGADJUST, lightningy, leftelectrax, NO);
            drawelectricity(rightelectrax, lightningy, WIDTH - LIGHTNINGADJUST, NO);
            return;
         }
      }
   }
   drawelectricity(LIGHTNINGADJUST, lightningy, WIDTH - LIGHTNINGADJUST, NO);
   return;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cont_scroll(Widget	  gw,
			XEvent	 *event,
			String	 *params,
			Cardinal *no_params)
{
    ScrBarWidget	w = (ScrBarWidget)gw;
    int			x, y, dc, length;
    if (w->scrbar.mode != ScrBarModeContinuous)
	return;
    if (!get_event_xy(event, &x, &y)) {
	XBell(XtDisplay(w), 0);
	return;
    }
    length = w->scrbar.c4 - w->scrbar.c1;
    if (length <= 0)
	return;
    dc = (w->scrbar.vertical ?  y : x ) - w->scrbar.init_ptr_pos;
    w->scrbar.slider_position = w->scrbar.init_slider_pos +
	dc * w->scrbar.canvas_length / length;
    fit_scrbar(w);
    calc_scrbar_coords(w);
    draw_thumb(w, NULL);
    send_scroll_report(w);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
hash_find_entry (Hash_table *table, const void *entry,
		 struct hash_entry **bucket_head, bool delete)
{
  struct hash_entry *bucket
    = table->bucket + table->hasher (entry, table->n_buckets);
  struct hash_entry *cursor;
  assert (bucket < table->bucket_limit);
  *bucket_head = bucket;
  /* Test for empty bucket.  */
  if (bucket->data == NULL)
    return NULL;
  /* See if the entry is the first in the bucket.  */
  if ((*table->comparator) (entry, bucket->data))
    {
      void *data = bucket->data;
      if (delete)
	{
	  if (bucket->next)
	    {
	      struct hash_entry *next = bucket->next;
	      /* Bump the first overflow entry into the bucket head, then save
		 the previous first overflow entry for later recycling.  */
	      *bucket = *next;
	      free_entry (table, next);
	    }
	  else
	    {
	      bucket->data = NULL;
	    }
	}
      return data;
    }
  /* Scan the bucket overflow.  */
  for (cursor = bucket; cursor->next; cursor = cursor->next)
    {
      if ((*table->comparator) (entry, cursor->next->data))
	{
	  void *data = cursor->next->data;
	  if (delete)
	    {
	      struct hash_entry *next = cursor->next;
	      /* Unlink the entry to delete, then save the freed entry for later
		 recycling.  */
	      cursor->next = next->next;
	      free_entry (table, next);
	    }
	  return data;
	}
    }
  /* No entry found.  */
  return NULL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
thread_name (MonoProfiler *prof, uintptr_t tid, const char *name)
{
	int len = strlen (name) + 1;
	uint64_t now;
	LogBuffer *logbuffer;
	logbuffer = ensure_logbuf (
		EVENT_SIZE /* event */ +
		LEB128_SIZE /* time */ +
		EVENT_SIZE /* type */ +
		LEB128_SIZE /* tid */ +
		LEB128_SIZE /* flags */ +
		len /* name */
	);
	now = current_time ();
	ENTER_LOG (logbuffer, "tname");
	emit_byte (logbuffer, TYPE_METADATA);
	emit_time (logbuffer, now);
	emit_byte (logbuffer, TYPE_THREAD);
	emit_ptr (logbuffer, (void*)tid);
	emit_value (logbuffer, 0); /* flags */
	memcpy (logbuffer->data, name, len);
	logbuffer->data += len;
	EXIT_LOG (logbuffer);
	if (logbuffer->next)
		safe_send (prof, logbuffer);
	process_requests (prof);
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
handlePRERET(FlowInstruction *pre)
{
   BasicBlock *bbE = pre->bb;
   BasicBlock *bbT = pre->target.bb;
   pre->subOp = NV50_IR_SUBOP_EMU_PRERET + 0;
   bbE->remove(pre);
   bbE->insertHead(pre);
   Instruction *skip = new_FlowInstruction(func, OP_PRERET, bbT);
   Instruction *call = new_FlowInstruction(func, OP_PRERET, bbE);
   bbT->insertHead(call);
   bbT->insertHead(skip);
   // NOTE: maybe split blocks to prevent the instructions from moving ?
   skip->subOp = NV50_IR_SUBOP_EMU_PRERET + 1;
   call->subOp = NV50_IR_SUBOP_EMU_PRERET + 2;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
EmitSignal (SignalId Signal)
{
	Object *obj = NULL;
	Object *ancestor = this;
	while (ancestor && !ancestor->IsLocked () && ancestor->OnSignal (Signal, obj)) {
		obj = ancestor;
		ancestor = obj->m_Parent;
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
xfs_mru_cache_create(
	struct xfs_mru_cache	**mrup,
	unsigned int		lifetime_ms,
	unsigned int		grp_count,
	xfs_mru_cache_free_func_t free_func)
{
	struct xfs_mru_cache	*mru = NULL;
	int			err = 0, grp;
	unsigned int		grp_time;
	if (mrup)
		*mrup = NULL;
	if (!mrup || !grp_count || !lifetime_ms || !free_func)
		return -EINVAL;
	if (!(grp_time = msecs_to_jiffies(lifetime_ms) / grp_count))
		return -EINVAL;
	if (!(mru = kmem_zalloc(sizeof(*mru), KM_SLEEP)))
		return -ENOMEM;
	/* An extra list is needed to avoid reaping up to a grp_time early. */
	mru->grp_count = grp_count + 1;
	mru->lists = kmem_zalloc(mru->grp_count * sizeof(*mru->lists), KM_SLEEP);
	if (!mru->lists) {
		err = -ENOMEM;
		goto exit;
	}
	for (grp = 0; grp < mru->grp_count; grp++)
		INIT_LIST_HEAD(mru->lists + grp);
	/*
	 * We use GFP_KERNEL radix tree preload and do inserts under a
	 * spinlock so GFP_ATOMIC is appropriate for the radix tree itself.
	 */
	INIT_RADIX_TREE(&mru->store, GFP_ATOMIC);
	INIT_LIST_HEAD(&mru->reap_list);
	spin_lock_init(&mru->lock);
	INIT_DELAYED_WORK(&mru->work, _xfs_mru_cache_reap);
	mru->grp_time  = grp_time;
	mru->free_func = free_func;
	*mrup = mru;
exit:
	if (err && mru && mru->lists)
		kmem_free(mru->lists);
	if (err && mru)
		kmem_free(mru);
	return err;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gas_fire (edict_t * ent)
{
	vec3_t offset;
	vec3_t forward, right;
	vec3_t start;
	int damage = GRENADE_DAMRAD;
	float timer;
	int speed;
	/*        int held = false;*/
	// Reset Grenade Damage to 1.52 when requested:
	if (use_classic->value)
		damage = 170;
	else
		damage = GRENADE_DAMRAD;
	if(is_quad)
		damage *= 1.5f;
	VectorSet (offset, 8, 8, ent->viewheight - 8);
	AngleVectors (ent->client->v_angle, forward, right, NULL);
	P_ProjectSource (ent->client, ent->s.origin, offset, forward, right, start);
	timer = 2.0;
	if (ent->client->resp.grenade_mode == 0)
		speed = 400;
	else if (ent->client->resp.grenade_mode == 1)
		speed = 720;
	else
		speed = 920;
	fire_grenade2 (ent, start, forward, damage, speed, timer, damage * 2, false);
	INV_AMMO(ent, GRENADE_NUM)--;
	if (INV_AMMO(ent, GRENADE_NUM) <= 0)
	{
		ent->client->newweapon = GET_ITEM(MK23_NUM);
		ChangeWeapon (ent);
		return;
	}
	else
	{
		ent->client->weaponstate = WEAPON_RELOADING;
		ent->client->ps.gunframe = 0;
	}
	//      ent->client->grenade_time = level.time + 1.0;
	ent->client->ps.gunframe++;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_wapi_handle_check_share (struct _WapiFileShare *share_info, int fd)
{
	gboolean found = FALSE, proc_fds = FALSE;
	pid_t self = _wapi_getpid ();
	int pid;
	int thr_ret, i;
	/* Prevents entries from expiring under us if we remove this
	 * one
	 */
	thr_ret = _wapi_handle_lock_shared_handles ();
	g_assert (thr_ret == 0);
	/* Prevent new entries racing with us */
	thr_ret = _wapi_shm_sem_lock (_WAPI_SHARED_SEM_FILESHARE);
	g_assert (thr_ret == 0);
	/* If there is no /proc, there's nothing more we can do here */
	if (access ("/proc", F_OK) == -1) {
		_wapi_handle_check_share_by_pid (share_info);
		goto done;
	}
	/* If there's another handle that thinks it owns this fd, then even
	 * if the fd has been closed behind our back consider it still owned.
	 * See bugs 75764 and 75891
	 */
	for (i = 0; i < _wapi_fd_reserve; i++) {
		if (_wapi_private_handles [SLOT_INDEX (i)]) {
			struct _WapiHandleUnshared *handle = &_WAPI_PRIVATE_HANDLES(i);
			if (i != fd &&
				handle->type == WAPI_HANDLE_FILE) {
				struct _WapiHandle_file *file_handle = &handle->u.file;
				if (file_handle->share_info == share_info) {
					DEBUG ("%s: handle 0x%x has this file open!",
							   __func__, i);
					goto done;
				}
			}
		}
	}
	for (i = 0; i < _WAPI_HANDLE_INITIAL_COUNT; i++) {
		struct _WapiHandleShared *shared;
		struct _WapiHandle_process *process_handle;
		shared = &_wapi_shared_layout->handles[i];
		if (shared->type == WAPI_HANDLE_PROCESS) {
			DIR *fd_dir;
			struct dirent *fd_entry;
			char subdir[_POSIX_PATH_MAX];
			process_handle = &shared->u.process;
			pid = process_handle->id;
			/* Look in /proc/<pid>/fd/ but ignore
			 * /proc/<our pid>/fd/<fd>, as we have the
			 * file open too
			 */
			g_snprintf (subdir, _POSIX_PATH_MAX, "/proc/%d/fd",
				    pid);
			fd_dir = opendir (subdir);
			if (fd_dir == NULL) {
				continue;
			}
			DEBUG ("%s: Looking in %s", __func__, subdir);
			proc_fds = TRUE;
			while ((fd_entry = readdir (fd_dir)) != NULL) {
				char path[_POSIX_PATH_MAX];
				struct stat link_stat;
				if (!strcmp (fd_entry->d_name, ".") ||
				    !strcmp (fd_entry->d_name, "..") ||
				    (pid == self &&
				     fd == atoi (fd_entry->d_name))) {
					continue;
				}
				g_snprintf (path, _POSIX_PATH_MAX,
					    "/proc/%d/fd/%s", pid,
					    fd_entry->d_name);
				stat (path, &link_stat);
				if (link_stat.st_dev == share_info->device &&
				    link_stat.st_ino == share_info->inode) {
					DEBUG ("%s:  Found it at %s",
						   __func__, path);
					found = TRUE;
				}
			}
			closedir (fd_dir);
		}
	}
	if (proc_fds == FALSE) {
		_wapi_handle_check_share_by_pid (share_info);
	} else if (found == FALSE) {
		/* Blank out this entry, as it is stale */
		DEBUG ("%s: Didn't find it, destroying entry", __func__);
		_wapi_free_share_info (share_info);
	}
done:
	thr_ret = _wapi_shm_sem_unlock (_WAPI_SHARED_SEM_FILESHARE);
	_wapi_handle_unlock_shared_handles ();
}
CWE-119  True
CWE-120  True
CWE-469  True
CWE-476  False
CWE-other  False
--------------------------
ao_hex_record_set_checksum(struct ao_hex_record *record)
{
	uint8_t	cksum = 0;
	int i;
	cksum += record->length;
	cksum += record->address >> 8;
	cksum += record->address;
	cksum += record->type;
	for (i = 0; i < record->length; i++)
		cksum += record->data[i];
	record->checksum = -cksum;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
defragmentPage(Btree *pBt, MemPage *pPage){
  int pc, i, n;
  FreeBlk *pFBlk;
  char newPage[SQLITE_USABLE_SIZE];
  assert( sqlitepager_iswriteable(pPage) );
  assert( pPage->isInit );
  pc = sizeof(PageHdr);
  pPage->u.hdr.firstCell = SWAB16(pBt, pc);
  memcpy(newPage, pPage->u.aDisk, pc);
  for(i=0; i<pPage->nCell; i++){
    Cell *pCell = pPage->apCell[i];
    /* This routine should never be called on an overfull page.  The
    ** following asserts verify that constraint. */
    assert( Addr(pCell) > Addr(pPage) );
    assert( Addr(pCell) < Addr(pPage) + SQLITE_USABLE_SIZE );
    n = cellSize(pBt, pCell);
    pCell->h.iNext = SWAB16(pBt, pc + n);
    memcpy(&newPage[pc], pCell, n);
    pPage->apCell[i] = (Cell*)&pPage->u.aDisk[pc];
    pc += n;
  }
  assert( pPage->nFree==SQLITE_USABLE_SIZE-pc );
  memcpy(pPage->u.aDisk, newPage, pc);
  if( pPage->nCell>0 ){
    pPage->apCell[pPage->nCell-1]->h.iNext = 0;
  }
  pFBlk = (FreeBlk*)&pPage->u.aDisk[pc];
  pFBlk->iSize = SWAB16(pBt, SQLITE_USABLE_SIZE - pc);
  pFBlk->iNext = 0;
  pPage->u.hdr.firstFree = SWAB16(pBt, pc);
  memset(&pFBlk[1], 0, SQLITE_USABLE_SIZE - pc - sizeof(FreeBlk));
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
lvalue_error (location_t loc, enum lvalue_use use)
{
  switch (use)
    {
    case lv_assign:
      error_at (loc, "lvalue required as left operand of assignment");
      break;
    case lv_increment:
      error_at (loc, "lvalue required as increment operand");
      break;
    case lv_decrement:
      error_at (loc, "lvalue required as decrement operand");
      break;
    case lv_addressof:
      error_at (loc, "lvalue required as unary %<&%> operand");
      break;
    case lv_asm:
      error_at (loc, "lvalue required in asm statement");
      break;
    default:
      gcc_unreachable ();
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
add_label(void)
{
	int i;
	if (token[strlen(token)-1]==':')
		token[strlen(token)-1]=0;
	if (lindex>=MAX_LABELS)
		{
			printf("Too many labels.\n");
			exit(0);
		}
	for (i=0;i<lindex;i++)
		{
			if (!strcasecmp(token,labels[i]))
				{
					printf("Warning: label '%s' already exists.\n",token);
					return;
				}
		}
	strcpy(labels[lindex],token);
	offsets[lindex++]=offset;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
set_db_type(const char *name)
{
   if (catalog_db != NULL) {
      free(catalog_db);
   }
   catalog_db = bstrdup(name);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
net_write(UPSCONN_t *ups, const char *buf, size_t buflen)
{
	int	ret;
#ifdef WITH_SSL
	if (ups->ssl) {
#ifdef WITH_OPENSSL
		ret = SSL_write(ups->ssl, buf, buflen);
#elif defined(WITH_NSS) /* WITH_OPENSSL */
		ret = PR_Write(ups->ssl, buf, buflen);
#endif /* WITH_OPENSSL | WITH_NSS */
		if (ret < 1) {
			ups->upserror = UPSCLI_ERR_SSLERR;
		}
		return ret;
	}
#endif
	ret = upscli_select_write(ups->fd, buf, buflen, 0, 0);
	/* error writing data, server disconnected? */
	if (ret < 0) {
		ups->upserror = UPSCLI_ERR_WRITE;
		ups->syserrno = errno;
	}
	/* not ready for writing, server disconnected? */
	if (ret == 0) {
		ups->upserror = UPSCLI_ERR_SRVDISC;
	}
	return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_non_existent()
{
  if( _NP_is_nil() )  _CORBA_invoked_nil_pseudo_ref();
  omni_tracedmutex_lock sync(pd_lock);
  return pd_destroyed ? 1 : 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
init_mem(compress_io *cio,
         FILE *in_fp, int in_size, FILE *out_fp, int out_size)
{
    cio->in = (mem_mgr *) malloc(sizeof(mem_mgr));
    if (!cio->in)
        err_exit(BUFFER_ALLOC_ERR);
    cio->in->set = (UINT8 *) malloc(sizeof(UINT8) * in_size);
    if (!cio->in->set)
        err_exit(BUFFER_ALLOC_ERR);
    cio->in->pos = cio->in->set;
    cio->in->end = cio->in->set + in_size;
    cio->in->flush_buffer = flush_cin_buffer;
    cio->in->fp = in_fp;
    cio->out = (mem_mgr *) malloc(sizeof(mem_mgr));
    if (!cio->out)
        err_exit(BUFFER_ALLOC_ERR);
    cio->out->set = (UINT8 *) malloc(sizeof(UINT8) * out_size);
    if (!cio->out->set)
        err_exit(BUFFER_ALLOC_ERR);
    cio->out->pos = cio->out->set;
    cio->out->end = cio->out->set + out_size;
    cio->out->flush_buffer = flush_cout_buffer;
    cio->out->fp = out_fp;
    cio->temp_bits.len = 0;
    cio->temp_bits.val = 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
realloc(CVmVarHeapHybrid_hdr *mem, size_t siz,
                                     CVmObject *obj)
{
    void *new_mem;
    /* 
     *   if the new block fits in our cell size, return the original
     *   memory unchanged; note that we must adjust the pointer so that we
     *   return the client-visible portion 
     */
    if (siz <= cell_size_)
        return (void *)(mem + 1);
    /*
     *   The memory won't fit in our cell size, so not only can't we
     *   re-use the existing cell, but we can't allocate the memory from
     *   our own sub-block at all.  Allocate an entirely new block from
     *   the heap manager.
     */
    new_mem = mem_mgr_->alloc_mem(siz, obj);
    /* 
     *   Copy the old cell's contents to the new memory.  Note that the
     *   user-visible portion of the old cell starts immediately after the
     *   header; don't copy the old header, since it's not applicable to
     *   the new object.  Note also that we got a pointer directly to the
     *   user-visible portion of the new object, so we don't need to make
     *   any adjustments to the new pointer.  
     */
    memcpy(new_mem, (void *)(mem + 1), cell_size_);
    /* free the old memory */
    free(mem);
    /* return the new memory */
    return new_mem;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
GetInetAddr(char *host)
{ struct in_addr addr;
  struct hostent *hp;
addr.s_addr = inet_addr(host);
if ((addr.s_addr == INADDR_NONE) || (addr.s_addr == 0)) 
   {
   if ((hp = gethostbyname(host)) == 0)
      {
      snprintf(OUTPUT,CF_BUFSIZE,"\nhost not found: %s\n",host);
      FatalError(OUTPUT);
      }
   if (hp->h_addrtype != AF_INET)
      {
      snprintf(OUTPUT,CF_BUFSIZE,"unexpected address family: %d\n",hp->h_addrtype);
      FatalError(OUTPUT);
      }
   if (hp->h_length != sizeof(addr))
      {
      snprintf(OUTPUT,CF_BUFSIZE,"unexpected address length %d\n",hp->h_length);
      FatalError(OUTPUT);
      }
   memcpy((char *) &addr, hp->h_addr, hp->h_length);
   }
return (addr.s_addr);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
_chm_parse_UTF8(UChar **pEntry, UInt64 count, char *path)
{
    /* XXX: implement UTF-8 support, including a real mapping onto
     *      ISO-8859-1?  probably there is a library to do this?  As is
     *      immediately apparent from the below code, I'm presently not doing
     *      any special handling for files in which none of the strings contain
     *      UTF-8 multi-byte characters.
     */
    while (count != 0)
    {
        *path++ = (char)(*(*pEntry)++);
        --count;
    }
    *path = '\0';
    return 1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
make_option_str_with_ver(char **argv,int argc, char *version){
    char *op_str;
    int len=0;
    int i;
    for(i=0;i<argc;i++){
        len += strlen(argv[i]);
    }
    len += (strlen(version) + 2);
    len += argc-1;
    op_str = (char *)malloc(sizeof(char)*(len+1));
    if(op_str == NULL){
	fatal("not enough memory\n");
    }
    op_str[0] = '\0';
    sprintf(op_str, "%s.%s ", argv[0], version);
    for(i=1;i<argc;i++){
	strcat(op_str,argv[i]);
	if(argc > i+1){
	    strcat(op_str," ");
	}
    }
    return op_str;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
options_add_filter(obj_list_t *obj_list,
                       int n_objs,
                       filter_info_t filt,
                       pack_opttbl_t *table )
{
    unsigned int i, I;
    int          j, added=0, found=0;
    /* increase the size of the collection by N_OBJS if necessary */
    if (table->nelems+n_objs >= table->size)
    {
        if (aux_inctable(table,n_objs)<0)
            return -1;
    }
    /* search if this object is already in the table; "path" is the key */
    if (table->nelems>0)
    {
        /* go tru the supplied list of names */
        for (j = 0; j < n_objs; j++)
        {
            /* linear table search */
            for (i = 0; i < table->nelems; i++)
            {
                /*already on the table */
                if (HDstrcmp(obj_list[j].obj,table->objs[i].path)==0)
                {
                    /* insert */
                    aux_tblinsert_filter(table,i,filt);
                    found=1;
                    break;
                } /* if */
            } /* i */
            if (found==0)
            {
                /* keep the grow in a temp var */
                I = table->nelems + added;
                added++;
                HDstrcpy(table->objs[I].path,obj_list[j].obj);
                aux_tblinsert_filter(table,I,filt);
            }
            /* cases where we have an already inserted name but there is a new name also
            example:
            -l dset1:CHUNK=20x20 -f dset1,dset2:GZIP=1
            dset1 is already inserted, but dset2 must also be
            */
            else if (found==1 && HDstrcmp(obj_list[j].obj,table->objs[i].path)!=0)
            {
                /* keep the grow in a temp var */
                I = table->nelems + added;
                added++;
                HDstrcpy(table->objs[I].path,obj_list[j].obj);
                aux_tblinsert_filter(table,I,filt);
            }
        } /* j */
    }
    /* first time insertion */
    else
    {
        /* go tru the supplied list of names */
        for (j = 0; j < n_objs; j++)
        {
            I = table->nelems + added;
            added++;
            HDstrcpy(table->objs[I].path,obj_list[j].obj);
            aux_tblinsert_filter(table,I,filt);
        }
    }
    table->nelems+= added;
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
PR_FreeAddrInfo(PRAddrInfo *ai)
{
#if defined(_PR_HAVE_GETADDRINFO)
#if defined(_PR_INET6_PROBE)
    if (!_pr_ipv6_is_present())
        PR_Free((PRAddrInfoFB *) ai);
    else
#endif
        FREEADDRINFO((PRADDRINFO *) ai);
#else
    PR_Free((PRAddrInfoFB *) ai);
#endif
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
b43legacy_write_initvals(struct b43legacy_wldev *dev,
				    const struct b43legacy_iv *ivals,
				    size_t count,
				    size_t array_size)
{
	const struct b43legacy_iv *iv;
	u16 offset;
	size_t i;
	bool bit32;
	BUILD_BUG_ON(sizeof(struct b43legacy_iv) != 6);
	iv = ivals;
	for (i = 0; i < count; i++) {
		if (array_size < sizeof(iv->offset_size))
			goto err_format;
		array_size -= sizeof(iv->offset_size);
		offset = be16_to_cpu(iv->offset_size);
		bit32 = !!(offset & B43legacy_IV_32BIT);
		offset &= B43legacy_IV_OFFSET_MASK;
		if (offset >= 0x1000)
			goto err_format;
		if (bit32) {
			u32 value;
			if (array_size < sizeof(iv->data.d32))
				goto err_format;
			array_size -= sizeof(iv->data.d32);
			value = get_unaligned_be32(&iv->data.d32);
			b43legacy_write32(dev, offset, value);
			iv = (const struct b43legacy_iv *)((const uint8_t *)iv +
							sizeof(__be16) +
							sizeof(__be32));
		} else {
			u16 value;
			if (array_size < sizeof(iv->data.d16))
				goto err_format;
			array_size -= sizeof(iv->data.d16);
			value = be16_to_cpu(iv->data.d16);
			b43legacy_write16(dev, offset, value);
			iv = (const struct b43legacy_iv *)((const uint8_t *)iv +
							sizeof(__be16) +
							sizeof(__be16));
		}
	}
	if (array_size)
		goto err_format;
	return 0;
err_format:
	b43legacyerr(dev->wl, "Initial Values Firmware file-format error.\n");
	b43legacy_print_fw_helptext(dev->wl);
	return -EPROTO;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
canvas_properties(t_glist *x)
{
    t_gobj *y;
    char graphbuf[200];
    if (glist_isgraph(x) != 0)
        sprintf(graphbuf,
            "pdtk_canvas_dialog %%s %g %g %d %g %g %g %g %d %d %d %d\n",
                0., 0.,
                glist_isgraph(x) ,//1,
                x->gl_x1, x->gl_y1, x->gl_x2, x->gl_y2, 
                (int)x->gl_pixwidth, (int)x->gl_pixheight,
                (int)x->gl_xmargin, (int)x->gl_ymargin);
    else sprintf(graphbuf,
            "pdtk_canvas_dialog %%s %g %g %d %g %g %g %g %d %d %d %d\n",
                glist_dpixtodx(x, 1), -glist_dpixtody(x, 1),
                0,
                0., -1., 1., 1., 
                (int)x->gl_pixwidth, (int)x->gl_pixheight,
                (int)x->gl_xmargin, (int)x->gl_ymargin);
    gfxstub_new(&x->gl_pd, x, graphbuf);
        /* if any arrays are in the graph, put out their dialogs too */
    for (y = x->gl_list; y; y = y->g_next)
        if (pd_class(&y->g_pd) == garray_class) 
            garray_properties((t_garray *)y);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
oc_enc_fdct8x8_c(ogg_int16_t _y[64],const ogg_int16_t _x[64]){
  const ogg_int16_t *in;
  ogg_int16_t       *end;
  ogg_int16_t       *out;
  ogg_int16_t        w[64];
  int                i;
  /*Add two extra bits of working precision to improve accuracy; any more and
     we could overflow.*/
  for(i=0;i<64;i++)w[i]=_x[i]<<2;
  /*These biases correct for some systematic error that remains in the full
     fDCT->iDCT round trip.*/
  w[0]+=(w[0]!=0)+1;
  w[1]++;
  w[8]--;
  /*Transform columns of w into rows of _y.*/
  for(in=w,out=_y,end=out+64;out<end;in++,out+=8)oc_fdct8(out,in);
  /*Transform columns of _y into rows of w.*/
  for(in=_y,out=w,end=out+64;out<end;in++,out+=8)oc_fdct8(out,in);
  /*Round the result back to the external working precision (which is still
     scaled by four relative to the orthogonal result).
    TODO: We should just update the external working precision.*/
  for(i=0;i<64;i++)_y[i]=w[i]+2>>2;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_dxfinit_convert(double gamma)
{
    static double convert_gamma = 0.0;	/* current gamma loaded into table */
    union hl f;
    int c, i;
    if (gamma==convert_gamma)		/* already computed? */
	return;
    f.f = 1.0;				/* start at pixel value 1.0 */
    i = UNSIGN(f.hl.hi);		/* unsigned index */
    memset(_dxd_convert+i, 255, NC-i);	/* set high values to 255 */
    do {				/* loop through lower values */
	f.hl.hi--;			/* go to next smaller number */
	c = pow(f.f, 1.0/gamma)*255.0;	/* f.f converts to c */
	_dxd_convert[UNSIGN(f.hl.hi)] = c;	/* put conversion in table */
    } while (c!=0);			/* stop when we get to 0 */
    convert_gamma = gamma;		/* record the current gamma value */
    DXMarkTimeLocal("init convert");
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
main(int argc, char **argv)
{
  char *temp, *s;
  /* Save our program  name - for error messages */
  temp = argv[0];
  s=strrchr(argv[0], '/');
  if (s != NULL)
    temp = s + 1;
  MyName = safemalloc(strlen(temp)+2);
  strcpy(MyName,"*");
  strcat(MyName, temp);
  if((argc != 6)&&(argc != 7))
    {
      fprintf(stderr,"%s Version %s should only be executed by fvwm!\n",MyName,
	      VERSION);
      exit(1);
    }
  /* Dead pipe == Fvwm died */
  signal (SIGPIPE, DeadPipe);  
  fd[0] = atoi(argv[1]);
  fd[1] = atoi(argv[2]);
  /* Data passed in command line */
  fprintf(stderr,"Application Window 0x%s\n",argv[4]);
  fprintf(stderr,"Application Context %s\n",argv[5]);
  fd_width = GetFdWidth();
  /* Create a list of all windows */
  /* Request a list of all windows,
   * wait for ConfigureWindow packets */
  SendInfo(fd,"Send_WindowList",0);
  Loop(fd);
  return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_GD_OldTypeName(DIRFILE* D, gd_type_t data_type)
{
  const char* ptr;
  dtrace("%p, 0x%x", D, data_type);
  switch(data_type) {
    case GD_UINT8:
      ptr = "c";
      break;
    case GD_UINT16:
      ptr = "u";
      break;
    case GD_INT16:
      ptr = "s";
      break;
    case GD_UINT32:
      ptr = "U";
      break;
    case GD_INT32:
      ptr = "S";
      break;
    case GD_FLOAT32:
      ptr = "f";
      break;
    case GD_FLOAT64:
      ptr = "d";
      break;
    default:
      _GD_InternalError(D);
      ptr = "";
      break;
  }
  dreturn("\"%s\"", ptr);
  return ptr;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
dm_raid0(struct lib_context *lc, char **table, struct raid_set *rs)
{
	unsigned int stripes = 0;
	uint64_t min, last_min = 0;
	for (; (min = _smallest(lc, rs, last_min)); last_min = min) {
		if (last_min && !p_fmt(lc, table, "\n"))
			goto err;
		if (!_dm_raid0_bol(lc, table, round_down(min, rs->stride),
				   last_min, _dm_raid_devs(lc, rs,
							   last_min),
				   rs->stride)
		    || !_dm_raid0_eol(lc, table, rs, &stripes, last_min))
			goto err;
		if (!F_MAXIMIZE(rs))
			break;
	}
	return stripes ? 1 : 0;
     err:
	return log_alloc_err(lc, __func__);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
commitLanguages(const CI18nTranslator& inTranslator){  
  for(CLanguageList::const_iterator i=mLanguages.begin();
      i!=mLanguages.end();
      i++){
    if(inTranslator.hasLanguage(*i)){
      mPreferredLanguage=*i;
      break;
    }
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
carl9170_debugfs_write(struct file *file,
	const char __user *userbuf, size_t count, loff_t *ppos)
{
	struct carl9170_debugfs_fops *dfops;
	struct ar9170 *ar;
	char *buf = NULL;
	int err = 0;
	if (!count)
		return 0;
	if (count > PAGE_SIZE)
		return -E2BIG;
	ar = file->private_data;
	if (!ar)
		return -ENODEV;
	dfops = container_of(file->f_op, struct carl9170_debugfs_fops, fops);
	if (!dfops->write)
		return -ENOSYS;
	buf = vmalloc(count);
	if (!buf)
		return -ENOMEM;
	if (copy_from_user(buf, userbuf, count)) {
		err = -EFAULT;
		goto out_free;
	}
	if (mutex_trylock(&ar->mutex) == 0) {
		err = -EAGAIN;
		goto out_free;
	}
	if (!CHK_DEV_STATE(ar, dfops->req_dev_state)) {
		err = -ENODEV;
		goto out_unlock;
	}
	err = dfops->write(ar, buf, count);
	if (err)
		goto out_unlock;
out_unlock:
	mutex_unlock(&ar->mutex);
out_free:
	vfree(buf);
	return err;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
orte_plm_base_vm_ready(int fd, short args, void *cbdata)
{
    orte_state_caddy_t *caddy = (orte_state_caddy_t*)cbdata;
    /* progress the job */
    caddy->jdata->state = ORTE_JOB_STATE_VM_READY;
    /* position any required files */
    if (ORTE_SUCCESS != orte_filem.preposition_files(caddy->jdata, files_ready, caddy->jdata)) {
        ORTE_FORCED_TERMINATE(ORTE_ERROR_DEFAULT_EXIT_CODE);
    }
    /* cleanup */
    OBJ_RELEASE(caddy);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gst_element_factory_list_filter (GList * list,
    const GstCaps * caps, GstPadDirection direction, gboolean subsetonly)
{
  GQueue results = G_QUEUE_INIT;
  GST_DEBUG ("finding factories");
  /* loop over all the factories */
  for (; list; list = list->next) {
    GstElementFactory *factory;
    const GList *templates;
    GList *walk;
    factory = (GstElementFactory *) list->data;
    GST_DEBUG ("Trying %s",
        gst_plugin_feature_get_name ((GstPluginFeature *) factory));
    /* get the templates from the element factory */
    templates = gst_element_factory_get_static_pad_templates (factory);
    for (walk = (GList *) templates; walk; walk = g_list_next (walk)) {
      GstStaticPadTemplate *templ = walk->data;
      /* we only care about the sink templates */
      if (templ->direction == direction) {
        GstCaps *tmpl_caps;
        /* try to intersect the caps with the caps of the template */
        tmpl_caps = gst_static_caps_get (&templ->static_caps);
        /* FIXME, intersect is not the right method, we ideally want to check
         * for a subset here */
        /* check if the intersection is empty */
        if ((subsetonly && gst_caps_is_subset (caps, tmpl_caps)) ||
            (!subsetonly && gst_caps_can_intersect (caps, tmpl_caps))) {
          /* non empty intersection, we can use this element */
          g_queue_push_tail (&results, gst_object_ref (factory));
          gst_caps_unref (tmpl_caps);
          break;
        }
        gst_caps_unref (tmpl_caps);
      }
    }
  }
  return results.head;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bch_bbio_count_io_errors(struct cache_set *c, struct bio *bio,
			      int error, const char *m)
{
	struct bbio *b = container_of(bio, struct bbio, bio);
	struct cache *ca = PTR_CACHE(c, &b->key, 0);
	unsigned threshold = bio->bi_rw & REQ_WRITE
		? c->congested_write_threshold_us
		: c->congested_read_threshold_us;
	if (threshold) {
		unsigned t = local_clock_us();
		int us = t - b->submit_time_us;
		int congested = atomic_read(&c->congested);
		if (us > (int) threshold) {
			int ms = us / 1024;
			c->congested_last_us = t;
			ms = min(ms, CONGESTED_MAX + congested);
			atomic_sub(ms, &c->congested);
		} else if (congested < 0)
			atomic_inc(&c->congested);
	}
	bch_count_io_errors(ca, error, m);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
dns_config_find_zone(char *name, int class)
{
    int len, buflen, match_len = -1;
    char buf[DNS_NAME_MAX];
    dns_config_root_t *root;
    dns_config_zone_t *zone, *candidate = NULL;
    if ((root = ConfigRoot) == NULL)
        return NULL;
    STRLCPY(buf, name, sizeof(buf));
    STRLOWER(buf);
    buflen = strlen(buf);
    zone = (dns_config_zone_t *) dns_list_head(&root->r_zone);
    while (zone != NULL) {
        if (zone->z_class == class || class == DNS_CLASS_ANY) {
            len = strlen(zone->z_name);
            if (buflen >= len && len > match_len) {
                if (buflen == len || buf[buflen - len - 1] == '.' || len == 0) {
                    if (strcmp(&buf[buflen - len], zone->z_name) == 0) {
                        candidate = zone;
                        match_len = len;
                    }
                }
            }
        }
        zone = (dns_config_zone_t *) dns_list_next(&root->r_zone, &zone->z_elem);
    }
    if (candidate == NULL)
        plog(LOG_DEBUG, "%s: no zone found", MODULE);
    else
        plog(LOG_DEBUG, "%s: found zone \"%s\"", MODULE, candidate->z_name);
    return candidate;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
autosave()
{
	statusBar->clearstatus();
	statusBar->status(_("Autosaving..."));
	autosave_int();
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
RandomRotorSearchInitialize(unsigned int conformers, unsigned int geomSteps)
  {
    if (!_validSetup)
      return;
    OBRotorList rl;
    OBRotamerList rotamers;
    OBRotorIterator ri;
    OBRotor *rotor;
    OBRandom generator;
    generator.TimeSeed();
    _origLogLevel = _loglvl;
    if (_mol.GetCoordinates() == NULL)
      return;
    OBBitVec fixed = _constraints.GetFixedBitVec();
    rl.SetFixAtoms(fixed);
    rl.Setup(_mol);
    rotamers.SetBaseCoordinateSets(_mol);
    rotamers.Setup(_mol, rl);
    IF_OBFF_LOGLVL_LOW {
      OBFFLog("\nR A N D O M   R O T O R   S E A R C H\n\n");
      snprintf(_logbuf, BUFF_SIZE, "  NUMBER OF ROTATABLE BONDS: %lu\n", (unsigned long)rl.Size());
      OBFFLog(_logbuf);
      unsigned long int combinations = 1;
      for (rotor = rl.BeginRotor(ri); rotor;
           rotor = rl.NextRotor(ri)) {
        combinations *= rotor->GetResolution().size();
      }
      snprintf(_logbuf, BUFF_SIZE, "  NUMBER OF POSSIBLE ROTAMERS: %lu\n", combinations);
      OBFFLog(_logbuf);
    }
    if (!rl.Size()) { // only one conformer
      IF_OBFF_LOGLVL_LOW
        OBFFLog("  GENERATED ONLY ONE CONFORMER\n\n");
      _loglvl = OBFF_LOGLVL_NONE;
      ConjugateGradients(geomSteps); // energy minimization for conformer
      _loglvl = _origLogLevel;
      return;
    }
    std::vector<int> rotorKey(rl.Size() + 1, 0); // indexed from 1
    for (int c = 0; c < conformers; ++c) {
      rotor = rl.BeginRotor(ri);
      for (int i = 1; i < rl.Size() + 1; ++i, rotor = rl.NextRotor(ri)) {
        // foreach rotor
        rotorKey[i] = generator.NextInt() % rotor->GetResolution().size();
      }
      rotamers.AddRotamer(rotorKey);
    }
    rotamers.ExpandConformerList(_mol, _mol.GetConformers());
    IF_OBFF_LOGLVL_LOW {
      snprintf(_logbuf, BUFF_SIZE, "  GENERATED %d CONFORMERS\n\n", _mol.NumConformers());
      OBFFLog(_logbuf);
      OBFFLog("CONFORMER     ENERGY\n");
      OBFFLog("--------------------\n");
    }
    _current_conformer = 0;
    _energies.clear();
  }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gd_header_button_set_symbolic_icon_name (GdHeaderButton *self,
                                         const gchar    *symbolic_icon_name)
{
  if (symbolic_icon_name != NULL &&
      !g_str_has_suffix (symbolic_icon_name, "-symbolic"))
    {
      g_warning ("gd_header_button_set_symbolic_icon_name was called with "
                 "a non-symbolic name.");
      return;
    }
  g_object_set (self, "symbolic-icon-name", symbolic_icon_name, NULL);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
mailimap_section_text_send(mailstream * fd,
    struct mailimap_section_text * section_text)
{
  switch (section_text->sec_type) {
  case MAILIMAP_SECTION_TEXT_SECTION_MSGTEXT:
    return mailimap_section_msgtext_send(fd, section_text->sec_msgtext);
  case MAILIMAP_SECTION_TEXT_MIME:
    return mailimap_token_send(fd, "MIME");
  default:
    /* should not happen */
    return MAILIMAP_NO_ERROR;
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
send_next_ecm_frame(t30_state_t *s)
{
    int i;
    uint8_t frame[3];
    if (s->ecm_current_tx_frame < s->ecm_frames)
    {
        /* Search for the next frame, within the current partial page, which has
           not been tagged as transferred OK. */
        for (i = s->ecm_current_tx_frame;  i < s->ecm_frames;  i++)
        {
            if (s->ecm_len[i] >= 0)
            {
                send_frame(s, s->ecm_data[i], s->ecm_len[i]);
                s->ecm_current_tx_frame = i + 1;
                s->ecm_frames_this_tx_burst++;
                return 0;
            }
        }
        s->ecm_current_tx_frame = s->ecm_frames;
    }
    if (s->ecm_current_tx_frame <= s->ecm_frames + 3)
    {
        /* We have sent all the FCD frames. Send some RCP frames. Three seems to be
           a popular number, to minimise the risk of a bit error stopping the receiving
           end from recognising the RCP. */
        s->ecm_current_tx_frame++;
        /* The RCP frame is an odd man out, as its a simple 1 byte control
           frame, but is specified to not have the final bit set. It doesn't
           seem to have the DIS received bit set, either. */
        frame[0] = 0xFF;
        frame[1] = 0x03;
        frame[2] = T4_RCP;
        send_frame(s, frame, 3);
        /* In case we are just after a CTC/CTR exchange, which kicked us back to long training */
        s->short_train = TRUE;
        return 0;
    }
    return -1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ParseSwallow(
	char **ss, unsigned int *flags, unsigned int *mask, button_info *b)
{
	char *swallowopts[] =
	{
		"nohints", "hints",
		"nokill", "kill",
		"noclose", "close",
		"respawn", "norespawn",
		"useold", "noold",
		"usetitle", "notitle",
		"fvwmmodule", "nofvwmmodule",
		"swallownew",
		NULL
	};
	char *t, *s = *ss;
	while (*s && *s != ')')
	{
		s = trimleft(s);
		if (*s == ',')
		{
			s++;
			continue;
		}
		switch (GetTokenIndex(s, swallowopts, -1, &s))
		{
		case 0: /* NoHints */
			*flags |= b_NoHints;
			*mask |= b_NoHints;
			break;
		case 1: /* Hints */
			*flags &= ~b_NoHints;
			*mask |= b_NoHints;
			break;
		case 2: /* NoKill */
			*flags &= ~b_Kill;
			*mask |= b_Kill;
			break;
		case 3: /* Kill */
			*flags |= b_Kill;
			*mask |= b_Kill;
			break;
		case 4: /* NoClose */
			*flags |= b_NoClose;
			*mask |= b_NoClose;
			break;
		case 5: /* Close */
			*flags &= ~b_NoClose;
			*mask |= b_NoClose;
			break;
		case 6: /* Respawn */
			*flags |= b_Respawn;
			*mask |= b_Respawn;
			b->newflags.do_swallow_new = 0;
			break;
		case 7: /* NoRespawn */
			*flags &= ~b_Respawn;
			*mask |= b_Respawn;
			b->newflags.do_swallow_new = 0;
			break;
		case 8: /* UseOld */
			*flags |= b_UseOld;
			*mask |= b_UseOld;
			break;
		case 9: /* NoOld */
			*flags &= ~b_UseOld;
			*mask |= b_UseOld;
			break;
		case 10: /* UseTitle */
			*flags |= b_UseTitle;
			*mask |= b_UseTitle;
			break;
		case 11: /* NoTitle */
			*flags &= ~b_UseTitle;
			*mask |= b_UseTitle;
			break;
		case 12: /* FvwmModule */
			*flags |= b_FvwmModule;
			*mask |= b_FvwmModule;
			break;
		case 13: /* NoFvwmModule */
			*flags &= ~b_FvwmModule;
			*mask |= b_FvwmModule;
			break;
		case 14: /* SwallowNew */
			*flags &= ~b_Respawn;
			*mask |= b_Respawn;
			b->newflags.do_swallow_new = 1;
			break;
		default:
			t = seekright(&s);
			fprintf(stderr,
				"%s: Illegal Swallow option \"%s\"\n", MyName,
				(t) ? t : "");
			if (t)
			{
				free(t);
			}
		}
	}
	if (*s)
	{
		s++;
	}
	*ss = s;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
do_redirect(action_list_t *a, const char *addr, int cancel_keep)
{
    action_list_t *b = NULL;
    /* xxx we should validate addr */
    /* see if this conflicts with any previous actions taken on this message */
    while (a != NULL) {
	b = a;
	if (a->a == ACTION_REJECT)
	    return SIEVE_RUN_ERROR;
	a = a->next;
    }
    /* add to the action list */
    a = (action_list_t *) xmalloc(sizeof(action_list_t));
    if (a == NULL)
	return SIEVE_NOMEM;
    a->a = ACTION_REDIRECT;
    a->cancel_keep = cancel_keep;
    a->u.red.addr = addr;
    a->next = NULL;
    b->next = a;
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
free_server(aServer *serv)
{
	aClient *cptr = serv->bcptr;
	/* decrement reference counter, and eventually free it */
	if (--serv->refcnt <= 0)
	{
		if (serv->refcnt == -211001)
		{
			/* Loop detected, break it.
			 * XXX: Remove loop detection before 2.11.0 - jv */
			sendto_flag(SCH_DEBUG, "* %#x free_server loop %s *",
				    serv, serv->namebuf);
			return;
		}
		/* Decrease (and possibly free) refcnt of the user struct
		 * of who connected this server.
		 */
		if (serv->user)
		{
			int cnt = serv->refcnt;
			serv->refcnt = -211000;	/* Loop detection */
			free_user(serv->user);
			serv->user = NULL;
			serv->refcnt = cnt;
		}
		if (serv->refcnt < 0 ||	serv->prevs || serv->nexts ||
		    serv->bcptr || serv->user)
		{
			char buf[512];
			sprintf(buf, "%d %p %p %p %p (%s)",
				serv->refcnt, (void *)serv->prevs,
				(void *)serv->nexts, (void *)serv->user,
				(void *)serv->bcptr,
				(serv->bcptr) ? serv->bcptr->name : "none");
#ifdef DEBUGMODE
			dumpcore("%#x server %s %s",
				 cptr, cptr ? cptr->name : "<noname>", buf);
			servs.inuse--;
#else
			sendto_flag(SCH_ERROR, "* %#x server %s %s *",
				    cptr, cptr ? cptr->name : "<noname>", buf);
#endif
		}
		MyFree(serv);
	}
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
e_bindings_shutdown(void)
{
   E_FREE_LIST(mouse_bindings, _e_bindings_mouse_free);
   E_FREE_LIST(key_bindings, _e_bindings_key_free);
   E_FREE_LIST(edge_bindings, _e_bindings_edge_free);
   E_FREE_LIST(signal_bindings, _e_bindings_signal_free);
   E_FREE_LIST(wheel_bindings, _e_bindings_wheel_free);
   E_FREE_LIST(acpi_bindings, _e_bindings_acpi_free);
   if (mapping_handler)
      {
         ecore_event_handler_del(mapping_handler);
         mapping_handler = NULL;
      }
   return 1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
parse_quota(const char *s, uint64_t * quota)
{
	*quota = strtoull(s, NULL, 10);
#ifdef DEBUG_XT_QUOTA
	printf("Quota: %llu\n", *quota);
#endif
	if (*quota == UINT64_MAX)
		xtables_error(PARAMETER_PROBLEM, "quota invalid: '%s'\n", s);
	else
		return 1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
iwl_mvm_add_int_sta_common(struct iwl_mvm *mvm,
				      struct iwl_mvm_int_sta *sta,
				      const u8 *addr,
				      u16 mac_id, u16 color)
{
	struct iwl_mvm_add_sta_cmd cmd;
	int ret;
	u32 status;
	lockdep_assert_held(&mvm->mutex);
	memset(&cmd, 0, sizeof(cmd));
	cmd.sta_id = sta->sta_id;
	cmd.mac_id_n_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(mac_id,
							     color));
	cmd.tfd_queue_msk = cpu_to_le32(sta->tfd_queue_msk);
	if (addr)
		memcpy(cmd.addr, addr, ETH_ALEN);
	ret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA, sizeof(cmd),
					  &cmd, &status);
	if (ret)
		return ret;
	switch (status) {
	case ADD_STA_SUCCESS:
		IWL_DEBUG_INFO(mvm, "Internal station added.\n");
		return 0;
	default:
		ret = -EIO;
		IWL_ERR(mvm, "Add internal station failed, status=0x%x\n",
			status);
		break;
	}
	return ret;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
matroska_aac_profile(char *codec_id)
{
    static const char * const aac_profiles[] = { "MAIN", "LC", "SSR" };
    int profile;
    for (profile=0; profile<FF_ARRAY_ELEMS(aac_profiles); profile++)
        if (strstr(codec_id, aac_profiles[profile]))
            break;
    return profile + 1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ds_strcat (struct dstring *s, char *t)
{
  size_t len = s->len;
  s->len += strlen (t);
  if (ds_is_full (s))
    ds_grow (s);
  strcpy (s->content + len, t);
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
mystrdup(char *s)
{
    char *dup;
    if (!s)
        return 0;
    if ((dup = MALLOC(strlen(s) + 1)) == NULL)
        syserr("Not enough memory for strdup.");
    strcpy(dup, s);
    return dup;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
dfs_file_write(struct file *file, const char __user *user_buf,
			      size_t count, loff_t *ppos)
{
	unsigned long ubi_num = (unsigned long)file->private_data;
	struct dentry *dent = file->f_path.dentry;
	struct ubi_device *ubi;
	struct ubi_debug_info *d;
	size_t buf_size;
	char buf[8] = {0};
	int val;
	ubi = ubi_get_device(ubi_num);
	if (!ubi)
		return -ENODEV;
	d = &ubi->dbg;
	buf_size = min_t(size_t, count, (sizeof(buf) - 1));
	if (copy_from_user(buf, user_buf, buf_size)) {
		count = -EFAULT;
		goto out;
	}
	if (dent == d->dfs_power_cut_min) {
		if (kstrtouint(buf, 0, &d->power_cut_min) != 0)
			count = -EINVAL;
		goto out;
	} else if (dent == d->dfs_power_cut_max) {
		if (kstrtouint(buf, 0, &d->power_cut_max) != 0)
			count = -EINVAL;
		goto out;
	} else if (dent == d->dfs_emulate_power_cut) {
		if (kstrtoint(buf, 0, &val) != 0)
			count = -EINVAL;
		d->emulate_power_cut = val;
		goto out;
	}
	if (buf[0] == '1')
		val = 1;
	else if (buf[0] == '0')
		val = 0;
	else {
		count = -EINVAL;
		goto out;
	}
	if (dent == d->dfs_chk_gen)
		d->chk_gen = val;
	else if (dent == d->dfs_chk_io)
		d->chk_io = val;
	else if (dent == d->dfs_chk_fastmap)
		d->chk_fastmap = val;
	else if (dent == d->dfs_disable_bgt)
		d->disable_bgt = val;
	else if (dent == d->dfs_emulate_bitflips)
		d->emulate_bitflips = val;
	else if (dent == d->dfs_emulate_io_failures)
		d->emulate_io_failures = val;
	else
		count = -EINVAL;
out:
	ubi_put_device(ubi);
	return count;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
get_filename( char* vfilename, char* filename, char* directive, char* tag, char* val, char* fn, int fnsize )
    {
    int vl, fl;
    char* cp;
    /* Used for the various commands that accept a file name.
    ** These commands accept two tags:
    **   virtual
    **     Gives a virtual path to a document on the server.
    **   file
    **     Gives a pathname relative to the current directory. ../ cannot
    **     be used in this pathname, nor can absolute paths be used.
    */
    vl = strlen( vfilename );
    fl = strlen( filename );
    if ( strcmp( tag, "virtual" ) == 0 )
	{
	if ( strstr( val, "../" ) != (char*) 0 )
	    {
	    not_permitted( directive, tag, val );
	    return -1;
	    }
	/* Figure out root using difference between vfilename and filename. */
	if ( vl > fl ||
	     strcmp( vfilename, &filename[fl - vl] ) != 0 )
	    return -1;
	if ( fl - vl + strlen( val ) >= fnsize )
	    return -1;
	(void) strncpy( fn, filename, fl - vl );
	(void) strcpy( &fn[fl - vl], val );
	}
    else if ( strcmp( tag, "file" ) == 0 )
	{
	if ( val[0] == '/' || strstr( val, "../" ) != (char*) 0 )
	    {
	    not_permitted( directive, tag, val );
	    return -1;
	    }
	if ( fl + 1 + strlen( val ) >= fnsize )
	    return -1;
	(void) strcpy( fn, filename );
	cp = strrchr( fn, '/' );
	if ( cp == (char*) 0 )
	    {
	    cp = &fn[strlen( fn )];
	    *cp = '/';
	    }
	(void) strcpy( ++cp, val );
	}
    else
	{
	unknown_tag( filename, directive, tag );
	return -1;
	}
    return 0;
    }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
suspend_nvs_alloc(void)
{
	struct nvs_page *entry;
	list_for_each_entry(entry, &nvs_list, node) {
		entry->data = (void *)__get_free_page(GFP_KERNEL);
		if (!entry->data) {
			suspend_nvs_free();
			return -ENOMEM;
		}
	}
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
drbd_bm_init(struct drbd_device *device)
{
	struct drbd_bitmap *b = device->bitmap;
	WARN_ON(b != NULL);
	b = kzalloc(sizeof(struct drbd_bitmap), GFP_KERNEL);
	if (!b)
		return -ENOMEM;
	spin_lock_init(&b->bm_lock);
	mutex_init(&b->bm_change);
	init_waitqueue_head(&b->bm_io_wait);
	device->bitmap = b;
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
mcontour (header *hd)
/***** mcontour
	contour plot with matrix and vector intput.
*****/
{	header *st=hd,*result,*hd1;
	double *m,*mv,x[5];
	int r,c,cv,dummy,i,j;
	hd=getvalue(hd); if (error) return;
	if (hd->type!=s_matrix || dimsof(hd)->c<2 || dimsof(hd)->r<2)
	{	output("Contour needs a real matrix!\n"); error=81; return;
	}
	hd1=next_param(st); if (error) return;
	hd1=getvalue(hd1); if (error) return;
	if (hd1->type!=s_real)
		if (hd1->type!=s_matrix || dimsof(hd1)->r!=1)
		{	output("Second parameter of contour must be a vector!\n");
			error=82; return;
		}
	getmatrix(hd,&r,&c,&m); getmatrix(hd1,&dummy,&cv,&mv);
	graphic_mode();
	if (!holding) gclear();
	frame();
	for (i=0; i<r-1; i++)
	{	for (j=0; j<c-1; j++)
		{	x[0]=*mat(m,c,i,j); x[1]=*mat(m,c,i+1,j);
			x[2]=*mat(m,c,i+1,j+1); x[3]=*mat(m,c,i,j+1);
			x[4]=x[0];
			contour(x,i,j,c-1,r-1,mv,cv);
		}
		if (test_key()==escape)
		{	output("User interrupted!\n");
			error=1; gflush(); return;
		}
	}
	result=new_real(cv,"");
	moveresult(st,result);
	gflush();
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
iosf_mbi_pci_write_mdr(u32 mcrx, u32 mcr, u32 mdr)
{
	int result;
	if (!mbi_pdev)
		return -ENODEV;
	result = pci_write_config_dword(mbi_pdev, MBI_MDR_OFFSET, mdr);
	if (result < 0)
		goto fail_write;
	if (mcrx) {
		result = pci_write_config_dword(mbi_pdev, MBI_MCRX_OFFSET,
						mcrx);
		if (result < 0)
			goto fail_write;
	}
	result = pci_write_config_dword(mbi_pdev, MBI_MCR_OFFSET, mcr);
	if (result < 0)
		goto fail_write;
	return 0;
fail_write:
	dev_err(&mbi_pdev->dev, "PCI config access failed with %d\n", result);
	return result;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
log_message_level(int level, const char *fmt, ...)
{
	int log_level = global.logLevel;
	if( (level & log_level) && level != 0) 
	{
		va_list ap;
		char    buf[1024];
		int     len;
		char   *msg;
		/* strfcpy (buf + 4, "&LOG opennap ", sizeof(buf) - 4); */
		snprintf(buf + 4, sizeof(buf) - 4, "&LOG %s ", global.serverName);
		len = strlen(buf + 4);
		msg = buf + len + 4;
		va_start(ap, fmt);
		vsnprintf(buf + 4 + len, sizeof(buf) - 4 - len, fmt, ap);
		va_end(ap);
#if LOG_CHANNEL
		/* prevent infinite loop */
		if(!Logging)
		{
			len += strlen(buf + 4 + len);
			set_tag(buf, MSG_SERVER_PUBLIC);
			set_len(buf, len);
			Logging = 1;
			(void) send_to_channel("&LOG", buf, len + 4);
			Logging = 0;
		}
#endif
		/* display log msg on console */
		if(option(ON_LOG_STDOUT)) 
		{
			char timebuf[64];
			time_t curtime;
			struct tm *loctime;
			curtime = time(NULL);
			loctime = localtime(&curtime);
			strftime(timebuf, 64, "%b %d %H:%M:%S ", loctime);
			fputs(timebuf, stdout);
			fputs(msg, stdout);
			fputc('\n', stdout);
			fflush(stdout);
		}
	}
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gf_af_new(GF_Compositor *compositor, GF_AudioInterface *src, char *filter_name)
{
	GF_AudioFilterItem *filter;
	if (!src || !filter_name) return NULL;
	GF_SAFEALLOC(filter, GF_AudioFilterItem);
	filter->src = src;
	filter->input.FetchFrame = gf_af_fetch_frame;
	filter->input.ReleaseFrame = gf_af_release_frame;
	filter->input.GetSpeed = gf_af_get_speed;
	filter->input.GetChannelVolume = gf_af_get_channel_volume;
	filter->input.IsMuted = gf_af_is_muted;
	filter->input.GetConfig = gf_af_get_config;
	filter->input.callback = filter;
	gf_afc_load(&filter->filter_chain, compositor->user, filter_name);
	return filter;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
ExtractInternalReferences(JSObject* js_obj,
                                               HeapEntry* entry) {
  int length = js_obj->GetInternalFieldCount();
  for (int i = 0; i < length; ++i) {
    Object* o = js_obj->GetInternalField(i);
    SetInternalReference(
        js_obj, entry, i, o, js_obj->GetInternalFieldOffset(i));
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
enterprise_add_realm (UmAccountDialog *self,
                      UmRealmObject *realm)
{
        GtkTreeModel *model;
        GtkTreeIter iter;
        UmRealmCommon *common;
        const gchar *realm_name;
        gboolean match;
        gboolean ret;
        gchar *name;
        common = um_realm_object_get_common (realm);
        realm_name = um_realm_common_get_name (common);
        /*
         * Don't add a second realm if we already have one with this name.
         * Sometimes realmd returns to realms for the same name, if it has
         * different ways to use that realm. The first one that realmd
         * returns is the one it prefers.
         */
        model = GTK_TREE_MODEL (self->enterprise_realms);
        ret = gtk_tree_model_get_iter_first (model, &iter);
        while (ret) {
                gtk_tree_model_get (model, &iter, 0, &name, -1);
                match = (g_strcmp0 (name, realm_name) == 0);
                g_free (name);
                if (match) {
                        g_debug ("ignoring duplicate realm: %s", realm_name);
                        return;
                }
                ret = gtk_tree_model_iter_next (model, &iter);
        }
        gtk_list_store_append (self->enterprise_realms, &iter);
        gtk_list_store_set (self->enterprise_realms, &iter,
                            0, realm_name,
                            1, realm,
                            -1);
        g_debug ("added realm to drop down: %s %s", realm_name,
                 g_dbus_object_get_object_path (G_DBUS_OBJECT (realm)));
        if (!self->enterprise_domain_chosen && um_realm_is_configured (realm))
                gtk_combo_box_set_active_iter (self->enterprise_domain, &iter);
        g_object_unref (common);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
stripe_mkdir (call_frame_t *frame, xlator_t *this, loc_t *loc, mode_t mode,
              dict_t *params)
{
        stripe_private_t *priv = NULL;
        stripe_local_t   *local = NULL;
        xlator_list_t    *trav = NULL;
        int32_t           op_errno = 1;
        VALIDATE_OR_GOTO (frame, err);
        VALIDATE_OR_GOTO (this, err);
        VALIDATE_OR_GOTO (loc, err);
        VALIDATE_OR_GOTO (loc->path, err);
        VALIDATE_OR_GOTO (loc->inode, err);
        priv = this->private;
        trav = this->children;
        if (priv->first_child_down) {
                op_errno = ENOTCONN;
                goto err;
        }
        /* Initialization */
        local = GF_CALLOC (1, sizeof (stripe_local_t),
                           gf_stripe_mt_stripe_local_t);
        if (!local) {
                op_errno = ENOMEM;
                goto err;
        }
        local->op_ret = -1;
        local->call_count = priv->child_count;
        local->dict = dict_ref (params);
        local->mode = mode;
        loc_copy (&local->loc, loc);
        frame->local = local;
        /* Everytime in stripe lookup, all child nodes should be looked up */
        STACK_WIND (frame, stripe_first_mkdir_cbk, trav->xlator,
                    trav->xlator->fops->mkdir, loc, mode, params);
        return 0;
err:
        STRIPE_STACK_UNWIND (mkdir, frame, -1, op_errno, NULL, NULL, NULL, NULL);
        return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
nfs_iob_get_fh ( struct io_buffer *io_buf, struct nfs_fh *fh ) {
	fh->size = oncrpc_iob_get_int ( io_buf );
	if ( fh->size > 64 )
		return sizeof ( uint32_t );
	memcpy (fh->fh, io_buf->data, fh->size );
	iob_pull ( io_buf, fh->size );
	return fh->size + sizeof ( uint32_t );
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
mxl111sf_i2c_stop(struct mxl111sf_state *state)
{
	int ret;
	mxl_i2c("()");
	ret = mxl111sf_write_reg(state, SW_I2C_ADDR,
				 0x10 | SW_I2C_EN); /* stop */
	if (mxl_fail(ret))
		goto fail;
	ret = mxl111sf_write_reg(state, SW_I2C_ADDR,
				 0x10 | SW_I2C_EN | SW_SCL_OUT);
	if (mxl_fail(ret))
		goto fail;
	ret = mxl111sf_write_reg(state, SW_I2C_ADDR,
				 0x10 | SW_I2C_EN | SW_SCL_OUT | SW_SDA_OUT);
	if (mxl_fail(ret))
		goto fail;
	ret = mxl111sf_write_reg(state, SW_I2C_ADDR,
				 0x10 | SW_SCL_OUT | SW_SDA_OUT);
	mxl_fail(ret);
fail:
	return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
oppositeBorderPositionWithPoints(const int borderPosition,  QList<int> &points) {
	// 1. Conversion "border position -> (Absolute) position"
	int position[DIM_MAX];
	borderPositionToAbsolutePosition(borderPosition, position);
	// 2. Get start direction
	int direction[DIM_MAX];
	if (borderPosition < m_columns) {
		direction[DIM_X] = 0;
		direction[DIM_Y] = 1;
	} else if ((borderPosition >= m_columns) && (borderPosition < m_columns + m_rows)) {
		direction[DIM_X] = -1;
		direction[DIM_Y] = 0;
	} else if ((borderPosition >= m_columns + m_rows) && (borderPosition < 2*m_columns + m_rows)) {
		direction[DIM_X] = 0;
		direction[DIM_Y] = -1;
	} else if (borderPosition >= 2*m_columns + m_rows) {
		direction[DIM_X] = 1;
		direction[DIM_Y] = 0;
	}
	// 3. Get the outgoing (absolute) position
	getOutgoingPosition(position, direction, points);
	// 4. Conversion "(absolute) position -> border position"
	return absolutePositionToBorderPosition(position);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gst_ring_buffer_delay (GstRingBuffer * buf)
{
  GstRingBufferClass *rclass;
  guint res;
  g_return_val_if_fail (GST_IS_RING_BUFFER (buf), 0);
  /* buffer must be acquired */
  if (G_UNLIKELY (!gst_ring_buffer_is_acquired (buf)))
    goto not_acquired;
  rclass = GST_RING_BUFFER_GET_CLASS (buf);
  if (G_LIKELY (rclass->delay))
    res = rclass->delay (buf);
  else
    res = 0;
  return res;
not_acquired:
  {
    GST_DEBUG_OBJECT (buf, "not acquired");
    return 0;
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
sftk_newPinCheck(CK_CHAR_PTR pPin, CK_ULONG ulPinLen) {
    unsigned int i;
    int nchar = 0;      /* number of characters */
    int ntrail = 0;     /* number of trailing bytes to follow */
    int ndigit = 0;     /* number of decimal digits */
    int nlower = 0;     /* number of ASCII lowercase letters */
    int nupper = 0;     /* number of ASCII uppercase letters */
    int nnonalnum = 0;  /* number of ASCII non-alphanumeric characters */
    int nnonascii = 0;  /* number of non-ASCII characters */
    int nclass;         /* number of character classes */
    for (i = 0; i < ulPinLen; i++) {
	unsigned int byte = pPin[i];
	if (ntrail) {
	    if ((byte & 0xc0) != 0x80) {
		/* illegal */
		nchar = -1;
		break;
	    }
	    if (--ntrail == 0) {
		nchar++;
		nnonascii++;
	    }
	    continue;
	}
	if ((byte & 0x80) == 0x00) {
	    /* single-byte (ASCII) character */
	    nchar++;
	    if (isdigit(byte)) {
		if (i < ulPinLen - 1) {
		    ndigit++;
		}
	    } else if (islower(byte)) {
		nlower++;
	    } else if (isupper(byte)) {
		if (i > 0) {
		    nupper++;
		}
	    } else {
		nnonalnum++;
	    }
	} else if ((byte & 0xe0) == 0xc0) {
	    /* leading byte of two-byte character */
	    ntrail = 1;
	} else if ((byte & 0xf0) == 0xe0) {
	    /* leading byte of three-byte character */
	    ntrail = 2;
	} else if ((byte & 0xf8) == 0xf0) {
	    /* leading byte of four-byte character */
	    ntrail = 3;
	} else {
	    /* illegal */
	    nchar = -1;
	    break;
	}
    }
    if (nchar == -1) {
	/* illegal UTF8 string */
	return CKR_PIN_INVALID;
    }
    if (nchar < FIPS_MIN_PIN) {
	return CKR_PIN_LEN_RANGE;
    }
    nclass = (ndigit != 0) + (nlower != 0) + (nupper != 0) +
	     (nnonalnum != 0) + (nnonascii != 0);
    if (nclass < 3) {
	return CKR_PIN_LEN_RANGE;
    }
    return CKR_OK;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
SaveDefmethodsForDefgeneric(
  void *theEnv,
  struct constructHeader *theDefgeneric,
  void *userBuffer)
  {
   DEFGENERIC *gfunc = (DEFGENERIC *) theDefgeneric;
   char *logName = (char *) userBuffer;
   register unsigned i;
   for (i = 0 ; i < gfunc->mcnt ; i++)
     {
      if (gfunc->methods[i].ppForm != NULL)
        {
         PrintInChunks(theEnv,logName,gfunc->methods[i].ppForm);
         EnvPrintRouter(theEnv,logName,"\n");
        }
     }
  }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ath5k_hw_channel(struct ath5k_hw *ah, struct net80211_channel *channel)
{
	int ret;
	/*
	 * Check bounds supported by the PHY (we don't care about regultory
	 * restrictions at this point). Note: hw_value already has the band
	 * (CHANNEL_2GHZ, or CHANNEL_5GHZ) so we inform ath5k_channel_ok()
	 * of the band by that */
	if (!ath5k_channel_ok(ah, channel->center_freq, channel->hw_value)) {
		DBG("ath5k: channel frequency (%d MHz) out of supported "
		    "range\n", channel->center_freq);
		return -EINVAL;
	}
	/*
	 * Set the channel and wait
	 */
	switch (ah->ah_radio) {
	case AR5K_RF5110:
		ret = ath5k_hw_rf5110_channel(ah, channel);
		break;
	case AR5K_RF5111:
		ret = ath5k_hw_rf5111_channel(ah, channel);
		break;
	case AR5K_RF2425:
		ret = ath5k_hw_rf2425_channel(ah, channel);
		break;
	default:
		ret = ath5k_hw_rf5112_channel(ah, channel);
		break;
	}
	if (ret) {
		DBG("ath5k: setting channel failed: %s\n", strerror(ret));
		return ret;
	}
	/* Set JAPAN setting for channel 14 */
	if (channel->center_freq == 2484) {
		AR5K_REG_ENABLE_BITS(ah, AR5K_PHY_CCKTXCTL,
				AR5K_PHY_CCKTXCTL_JAPAN);
	} else {
		AR5K_REG_ENABLE_BITS(ah, AR5K_PHY_CCKTXCTL,
				AR5K_PHY_CCKTXCTL_WORLD);
	}
	ah->ah_current_channel = channel;
	ah->ah_turbo = (channel->hw_value == CHANNEL_T ? 1 : 0);
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Send_NR(char *reason)
{
	char buffer[257];
	int length;
	if ((length = strlen(reason)) > 255)
		length = 255;
	buffer[0] = NAK;
	buffer[1] = length;
	memcpy(buffer + 2, reason, length);
	write(fd, buffer, length + 2);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
register_stat2( char *module, char *name, stat_var **pvar,
											unsigned short flags, void *ctx)
{
	module_stats* mods;
	stat_var *stat;
	stat_var *it;
	str smodule;
	int hash;
	if (module==0 || name==0 || pvar==0) {
		LM_ERR("invalid parameters module=%p, name=%p, pvar=%p \n", 
				module, name, pvar);
		goto error;
	}
	stat = (stat_var*)shm_malloc(sizeof(stat_var));
	if (stat==0) {
		LM_ERR("no more shm memory\n");
		goto error;
	}
	memset( stat, 0, sizeof(stat_var));
	if ( (flags&STAT_IS_FUNC)==0 ) {
		stat->u.val = (stat_val*)shm_malloc(sizeof(stat_val));
		if (stat->u.val==0) {
			LM_ERR("no more shm memory\n");
			goto error1;
		}
#ifdef NO_ATOMIC_OPS
		*(stat->u.val) = 0;
#else
		atomic_set(stat->u.val,0);
#endif
		*pvar = stat;
	} else {
		stat->u.f = (stat_function)(pvar);
	}
	/* is the module already recorded? */
	smodule.s = module;
	smodule.len = strlen(module);
	mods = get_stat_module(&smodule);
	if (mods==0) {
		mods = add_stat_module(module);
		if (mods==0) {
			LM_ERR("failed to add new module\n");
			goto error2;
		}
	}
	/* fill the stat record */
	stat->mod_idx = collector->mod_no-1;
	stat->name.s = name;
	stat->name.len = strlen(name);
	stat->flags = flags;
	stat->context = ctx;
	/* compute the hash by name */
	hash = stat_hash( &stat->name );
	/* link it */
	if (collector->hstats[hash]==0) {
		collector->hstats[hash] = stat;
	} else {
		it = collector->hstats[hash];
		while(it->hnext)
			it = it->hnext;
		it->hnext = stat;
	}
	collector->stats_no++;
	/* add the statistic also to the module statistic list */
	if (mods->tail) {
		mods->tail->lnext = stat;
	} else {
		mods->head = stat;
	}
	mods->tail = stat;
	mods->no++;
	return 0;
error2:
	if ( (flags&STAT_IS_FUNC)==0 ) {
		shm_free(*pvar);
		*pvar = 0;
	}
error1:
	shm_free(stat);
error:
	*pvar = 0;
	return -1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
nxt_psp_get_buttons(nxt_t *nxt,int port,struct nxt_psp_buttons *buttons) {
  uint16_t buf;
  int ret = nxt_i2c_read(nxt,port,nxt_psp_i2c_addr,NXT_PSP_REG_BUTTONS,2,&buf);
  if (ret==2) {
    buf = ~buf;
    if (buttons!=NULL) {
      buttons->left = buf&NXT_PSP_BTN_LEFT;
      buttons->down = buf&NXT_PSP_BTN_DOWN;
      buttons->up = buf&NXT_PSP_BTN_UP;
      buttons->right = buf&NXT_PSP_BTN_RIGHT;
      buttons->r3 = buf&NXT_PSP_BTN_R3;
      buttons->l3 = buf&NXT_PSP_BTN_L3;
      buttons->square = buf&NXT_PSP_BTN_SQUARE;
      buttons->x = buf&NXT_PSP_BTN_X;
      buttons->o = buf&NXT_PSP_BTN_O;
      buttons->triangle = buf&NXT_PSP_BTN_TRIANGLE;
      buttons->r1 = buf&NXT_PSP_BTN_R1;
      buttons->l1 = buf&NXT_PSP_BTN_L1;
      buttons->r2 = buf&NXT_PSP_BTN_R2;
      buttons->l2 = buf&NXT_PSP_BTN_L2;
    }
    return 0;
  }
  else {
    return -1;
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
set_new_fixed_colormap(const char *name)
{
  int i;
  if (name && strcmp(name, "web") == 0) {
    Gif_Colormap *cm = Gif_NewFullColormap(216, 256);
    Gif_Color *col = cm->col;
    for (i = 0; i < 216; i++) {
      col[i].gfc_red = (i / 36) * 0x33;
      col[i].gfc_green = ((i / 6) % 6) * 0x33;
      col[i].gfc_blue = (i % 6) * 0x33;
    }
    def_output_data.colormap_fixed = cm;
  } else if (name && (strcmp(name, "gray") == 0
		      || strcmp(name, "grey") == 0)) {
    Gif_Colormap *cm = Gif_NewFullColormap(256, 256);
    Gif_Color *col = cm->col;
    for (i = 0; i < 256; i++)
      col[i].gfc_red = col[i].gfc_green = col[i].gfc_blue = i;
    def_output_data.colormap_fixed = cm;
  } else if (name && strcmp(name, "bw") == 0) {
    Gif_Colormap *cm = Gif_NewFullColormap(2, 256);
    cm->col[0].gfc_red = cm->col[0].gfc_green = cm->col[0].gfc_blue = 0;
    cm->col[1].gfc_red = cm->col[1].gfc_green = cm->col[1].gfc_blue = 255;
    def_output_data.colormap_fixed = cm;
  } else
    def_output_data.colormap_fixed = read_colormap_file(name, 0);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
setInstanceUpdatesBlocked(bool blockUpdates)
{
    if (blockUpdates) {
        if (!gElementsWithInstanceUpdatesBlocked)
            gElementsWithInstanceUpdatesBlocked = new HashSet<const SVGStyledElement*>;
        gElementsWithInstanceUpdatesBlocked->add(this);
    } else {
        ASSERT(gElementsWithInstanceUpdatesBlocked);
        ASSERT(gElementsWithInstanceUpdatesBlocked->contains(this));
        gElementsWithInstanceUpdatesBlocked->remove(this);
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
addIsotopeToAtom(gchar* symbol, gint atomicNumber, gint iMass, gdouble rMass, gdouble abundance)
{
	gint i = (gint)atomicNumber-1;
	gint j = 0;
	if(i>=NATOMS) return;
	if(i<0) return;
	if(strcmp(symbol,"Xx")==0) return;
	if(strcmp(symbol,"X")==0) return;
	if(i>=109) return;
	if(AtomsProp[i].nIsotopes>= MAXISOTOP) return;
	j = AtomsProp[i].nIsotopes;
	AtomsProp[i].nIsotopes++;
	AtomsProp[i].iMass[j] = iMass;
	AtomsProp[i].rMass[j] = rMass;
	AtomsProp[i].abundances[j] = abundance;
	if(j==0) AtomsProp[i].masse = rMass;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
btrfs_alloc_from_cluster(struct btrfs_block_group_cache *block_group,
			     struct btrfs_free_cluster *cluster, u64 bytes,
			     u64 min_start, u64 *max_extent_size)
{
	struct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;
	struct btrfs_free_space *entry = NULL;
	struct rb_node *node;
	u64 ret = 0;
	spin_lock(&cluster->lock);
	if (bytes > cluster->max_size)
		goto out;
	if (cluster->block_group != block_group)
		goto out;
	node = rb_first(&cluster->root);
	if (!node)
		goto out;
	entry = rb_entry(node, struct btrfs_free_space, offset_index);
	while (1) {
		if (entry->bytes < bytes && entry->bytes > *max_extent_size)
			*max_extent_size = entry->bytes;
		if (entry->bytes < bytes ||
		    (!entry->bitmap && entry->offset < min_start)) {
			node = rb_next(&entry->offset_index);
			if (!node)
				break;
			entry = rb_entry(node, struct btrfs_free_space,
					 offset_index);
			continue;
		}
		if (entry->bitmap) {
			ret = btrfs_alloc_from_bitmap(block_group,
						      cluster, entry, bytes,
						      cluster->window_start,
						      max_extent_size);
			if (ret == 0) {
				node = rb_next(&entry->offset_index);
				if (!node)
					break;
				entry = rb_entry(node, struct btrfs_free_space,
						 offset_index);
				continue;
			}
			cluster->window_start += bytes;
		} else {
			ret = entry->offset;
			entry->offset += bytes;
			entry->bytes -= bytes;
		}
		if (entry->bytes == 0)
			rb_erase(&entry->offset_index, &cluster->root);
		break;
	}
out:
	spin_unlock(&cluster->lock);
	if (!ret)
		return 0;
	spin_lock(&ctl->tree_lock);
	ctl->free_space -= bytes;
	if (entry->bytes == 0) {
		ctl->free_extents--;
		if (entry->bitmap) {
			kfree(entry->bitmap);
			ctl->total_bitmaps--;
			ctl->op->recalc_thresholds(ctl);
		}
		kmem_cache_free(btrfs_free_space_cachep, entry);
	}
	spin_unlock(&ctl->tree_lock);
	return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
decode(const std::string& input, unsigned char *output, size_t& sz)
{
    size_t i = 0;
    size_t l = input.size();
    size_t j = 0;
    while (i < l)
    {
        while (i < l && (input[i] == 13 || input[i] == 10))
            i++;
        if (i < l)
        {
            unsigned char b1 = (unsigned char)((rstr[(int)input[i]] << 2 & 0xfc) +
                (rstr[(int)input[i + 1]] >> 4 & 0x03));
            if (output)
            {
                output[j] = b1;
            }
            j++;
            if (input[i + 2] != '=')
            {
                unsigned char b2 = (unsigned char)((rstr[(int)input[i + 1]] << 4 & 0xf0) +
                    (rstr[(int)input[i + 2]] >> 2 & 0x0f));
                if (output)
                {
                    output[j] = b2;
                }
                j++;
            }
            if (input[i + 3] != '=')
            {
                unsigned char b3 = (unsigned char)((rstr[(int)input[i + 2]] << 6 & 0xc0) +
                    rstr[(int)input[i + 3]]);
                if (output)
                {
                    output[j] = b3;
                }
                j++;
            }
            i += 4;
        }
    }
    sz = j;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
g3d_stream_open_zip(const gchar *filename, const gchar *subfile)
{
	GsfInput *input;
	GError *error = NULL;
	input = gsf_input_stdio_new(filename, &error);
	if(error != NULL) {
		g_warning("error opening container file '%s': %s", filename,
			error->message);
		g_error_free(error);
		return NULL;
	}
	return g3d_stream_open_zip_from_input(input, subfile);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
print_los(object *op) {
    int x, y;
    char buf[MAP_CLIENT_X*2+20], buf2[10];
    snprintf(buf, sizeof(buf), "[fixed]   ");
    for (x = 0; x < op->contr->socket.mapx; x++) {
        snprintf(buf2, sizeof(buf2), "%2d", x);
        strncat(buf, buf2, sizeof(buf)-strlen(buf)-1);
    }
    draw_ext_info(NDI_UNIQUE, 0, op, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_DEBUG, buf);
    for (y = 0; y < op->contr->socket.mapy; y++) {
        snprintf(buf, sizeof(buf), "[fixed]%2d:", y);
        for (x = 0; x < op->contr->socket.mapx; x++) {
            snprintf(buf2, sizeof(buf2), " %1d", op->contr->blocked_los[x][y] == 100 ? 1 : 0);
            strncat(buf, buf2, sizeof(buf)-strlen(buf)-1);
        }
        draw_ext_info(NDI_UNIQUE, 0, op, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_DEBUG, buf);
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
find_nested_options(struct isl_args *args,
	void *opt, struct isl_args *wanted)
{
	int i;
	struct isl_options *options;
	if (args == wanted)
		return opt;
	for (i = 0; args->args[i].type != isl_arg_end; ++i) {
		struct isl_arg *arg = &args->args[i];
		void *child;
		if (arg->type != isl_arg_child)
			continue;
		if (arg->offset == (size_t) -1)
			child = opt;
		else
			child = *(void **)(((char *)opt) + arg->offset);
		options = find_nested_options(arg->u.child.child,
						child, wanted);
		if (options)
			return options;
	}
	return NULL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
console_init(void)
{
#ifdef VT_OPENQRY
	int vtno;
#endif
	char *s;
	s = getenv("CONSOLE");
	if (!s)
		s = getenv("console");
	if (s) {
		int fd = open(s, O_RDWR | O_NONBLOCK | O_NOCTTY);
		if (fd >= 0) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			xmove_fd(fd, STDERR_FILENO);
		}
		dbg_message(L_LOG, "console='%s'", s);
	} else {
		/* Make sure fd 0,1,2 are not closed
		 * (so that they won't be used by future opens) */
		bb_sanitize_stdio();
// Users report problems
//		/* Make sure init can't be blocked by writing to stderr */
//		fcntl(STDERR_FILENO, F_SETFL, fcntl(STDERR_FILENO, F_GETFL) | O_NONBLOCK);
	}
	s = getenv("TERM");
#ifdef VT_OPENQRY
	if (ioctl(STDIN_FILENO, VT_OPENQRY, &vtno) != 0) {
		/* Not a linux terminal, probably serial console.
		 * Force the TERM setting to vt102
		 * if TERM is set to linux (the default) */
		if (!s || strcmp(s, "linux") == 0)
			putenv((char*)"TERM=vt102");
		if (!ENABLE_FEATURE_INIT_SYSLOG)
			log_console = NULL;
	} else
#endif
	if (!s)
		putenv((char*)"TERM=" CONFIG_INIT_TERMINAL_TYPE);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ompi_io_ompio_full_print_queue(int queue_type){
    int ret = OMPI_SUCCESS;
    print_queue *q=NULL;
    ret =  ompi_io_ompio_set_print_queue(&q, queue_type);
    assert ( ret != OMPI_ERROR);	
    if (q->count < QUEUESIZE)
	    return 0;
    else
	return 1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
gt_bsPrint(FILE *fp, constBitString str, BitOffset offset,
               BitOffset numBits)
{
  uint32_t accum = 0;
  unsigned bitsLeft = numBits, bitTop = offset%bitElemBits, bitsInAccum = 0;
  size_t elemStart = offset/bitElemBits;
  const BitElem *p = str + elemStart;
  char buf[sizeof (accum) * CHAR_BIT];
  int ioGtError = 0;
  gt_assert(str);
  do {
    if (bitTop)
    {
      uint32_t mask;
      unsigned bits2Read = MIN(bitElemBits - bitTop, bitsLeft);
      unsigned unreadRightBits = (bitElemBits - bitTop - bits2Read);
      mask = (~((~(uint32_t)0) << bits2Read)) << unreadRightBits;
      ACCUM2FP(((*p++) & mask) >> unreadRightBits, bits2Read);
      bitsLeft -= bits2Read;
    }
    /* get bits from intervening elems */
    while (bitsLeft >= bitElemBits && !ioGtError)
    {
      while (bitsLeft >= bitElemBits
             && sizeof (accum) * CHAR_BIT - bitElemBits >= bitsInAccum)
      {
        accum = accum << bitElemBits | (*p++);
        bitsLeft -= bitElemBits;
        bitsInAccum += bitElemBits;
      }
      ACCUM2FP(accum, bitsInAccum);
      accum = 0; bitsInAccum = 0;
    }
    if (ioGtError)
      break;
    /* get bits from last elem */
    if (bitsLeft)
    {
      accum = ((*p) & ((~(uint32_t)0)<<(bitElemBits - bitsLeft)))
        >> (bitElemBits - bitsLeft);
      ACCUM2FP(accum, bitsLeft);
    }
  } while (0);
  return ioGtError?-1:0;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
isakmp_attr_print(const u_char *p, const u_char *ep)
{
	u_int16_t *q;
	int totlen;
	u_int32_t t;
	q = (u_int16_t *)p;
	if (p[0] & 0x80)
		totlen = 4;
	else
		totlen = 4 + EXTRACT_16BITS(&q[1]);
	if (ep < p + totlen) {
		printf("[|attr]");
		return ep + 1;
	}
	printf("(");
	t = EXTRACT_16BITS(&q[0]) & 0x7fff;
	printf("type=#%d ", t);
	if (p[0] & 0x80) {
		printf("value=");
		t = q[1];
		rawprint((caddr_t)&q[1], 2);
	} else {
		printf("len=%d value=", EXTRACT_16BITS(&q[1]));
		rawprint((caddr_t)&p[2], EXTRACT_16BITS(&q[1]));
	}
	printf(")");
	return p + totlen;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
pm8001_set_phy_profile_single(struct pm8001_hba_info *pm8001_ha,
		u32 phy, u32 length, u32 *buf)
{
	u32 tag, opc;
	int rc, i;
	struct set_phy_profile_req payload;
	struct inbound_queue_table *circularQ;
	memset(&payload, 0, sizeof(payload));
	rc = pm8001_tag_alloc(pm8001_ha, &tag);
	if (rc)
		PM8001_INIT_DBG(pm8001_ha, pm8001_printk("Invalid tag"));
	circularQ = &pm8001_ha->inbnd_q_tbl[0];
	opc = OPC_INB_SET_PHY_PROFILE;
	payload.tag = cpu_to_le32(tag);
	payload.ppc_phyid = (((SAS_PHY_ANALOG_SETTINGS_PAGE & 0xF) << 8)
				| (phy & 0xFF));
	for (i = 0; i < length; i++)
		payload.reserved[i] = cpu_to_le32(*(buf + i));
	rc = pm8001_mpi_build_cmd(pm8001_ha, circularQ, opc, &payload, 0);
	if (rc)
		pm8001_tag_free(pm8001_ha, tag);
	PM8001_INIT_DBG(pm8001_ha,
		pm8001_printk("PHY %d settings applied", phy));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
check_printable(char *id, int maxlen)
{
    static char buffer[MAX_IDLEN];
    char *idval,*bufval;
    int i = 0;
    memset(buffer,'\0',MAX_IDLEN);
    if(maxlen > MAX_IDLEN)
        maxlen = MAX_IDLEN;
    bufval = buffer;
    for(idval = id; idval && (i < maxlen - 1); ++idval,++bufval,++i)
        if(!isprint(*idval))
        {
            *bufval = '\0';
            break;
        }
        else
            *bufval = *idval;
    return(buffer);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
restore_node_features(int recover)
{
	int i;
	struct node_record *node_ptr;
	for (i=0, node_ptr=node_record_table_ptr; i<node_record_count;
	     i++, node_ptr++) {
		if (node_ptr->weight != node_ptr->config_ptr->weight) {
			error("Node %s Weight(%u) differ from slurm.conf",
			      node_ptr->name, node_ptr->weight);
			if (recover == 2) {
				_update_node_weight(node_ptr->name,
						    node_ptr->weight);
			} else {
				node_ptr->weight = node_ptr->config_ptr->
						   weight;
			}
		}
		if (_strcmp(node_ptr->config_ptr->feature, node_ptr->features)){
			error("Node %s Features(%s) differ from slurm.conf",
			      node_ptr->name, node_ptr->features);
			if (recover == 2) {
				_update_node_features(node_ptr->name,
						      node_ptr->features);
			} else {
				xfree(node_ptr->features);
				node_ptr->features = xstrdup(node_ptr->
							     config_ptr->
							     feature);
			}
		}
		/* We lose the gres information updated manually and always
		 * use the information from slurm.conf */
		(void) gres_plugin_node_reconfig(node_ptr->name,
						 node_ptr->config_ptr->gres,
						 &node_ptr->gres,
						 &node_ptr->gres_list,
						 slurmctld_conf.fast_schedule);
		gres_plugin_node_state_log(node_ptr->gres_list, node_ptr->name);
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
handle_print_numeric(const char *token, char *line)
{
    const char *value;
    char       *st;
    value = strtok_r(line, " \t\n", &st);
    if (value && (
	    (strcasecmp(value, "yes")  == 0) || 
	    (strcasecmp(value, "true") == 0) ||
	    (*value == '1') )) {
        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
                                                  NETSNMP_OID_OUTPUT_NUMERIC);
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_tenEMBimodalIterate(tenEMBimodalParm *biparm) {
  static const char me[]="_tenEMBimodalIterate";
  double om1, os1, om2, os2, of1, m1, s1, m2, s2, f1;
  /* copy old values */
  om1 = biparm->mean1;
  os1 = biparm->stdv1;
  of1 = biparm->fraction1;
  om2 = biparm->mean2;
  os2 = biparm->stdv2;
  /* find new values, and calculate delta */
  _tenEMBimodalPP(biparm);
  f1 = _tenEMBimodalNewFraction1(biparm);
  /*   if (1 == biparm->stage) { */
    _tenEMBimodalNewMean(&m1, &m2, biparm);
    /*   } */
  _tenEMBimodalNewSigma(&s1, &s2, m1, m2, biparm);
  biparm->delta = ((fabs(m1 - om1) + fabs(m2 - om2)
                    + fabs(s1 - os1) + fabs(s2 - os2))/biparm->N
                   + fabs(f1 - of1));
  /* set new values */
  biparm->mean1 = m1;
  biparm->stdv1 = s1;
  biparm->fraction1 = f1;
  biparm->mean2 = m2;
  biparm->stdv2 = s2;
  if (biparm->verbose) {
    fprintf(stderr, "%s(%d:%d):\n", me, biparm->stage, biparm->iteration);
    fprintf(stderr, "  m1, s1 = %g, %g\n", m1, s1);
    fprintf(stderr, "  m2, s2 = %g, %g\n", m2, s2);
    fprintf(stderr, "  f1 = %g ; delta = %g\n", f1, biparm->delta);
  }
  if (biparm->verbose > 1) {
    _tenEMBimodalSaveImage(biparm);
  }
  return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bfa_cb_sfp_show(struct bfa_sfp_s *sfp)
{
	bfa_trc(sfp, sfp->lock);
	if (sfp->cbfn)
		sfp->cbfn(sfp->cbarg, sfp->status);
	sfp->lock = 0;
	sfp->cbfn = NULL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
putString(const char *stringVal)
{
    errorFlag = EC_Normal;
    /* check for an empty string parameter */
    if ((stringVal != NULL) && (strlen(stringVal) > 0))
        putValue(stringVal, strlen(stringVal));
    else
        putValue(NULL, 0);
    /* make sure that extra padding is removed from the string */
    fStringMode = DCM_UnknownString;
    makeMachineByteString();
    return errorFlag;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
convertseries(StackInfo *si)
{
    Series newtop = NULL;
    Object subo;
    int i;
    double seriespos = 0.0;
    newtop = DXNewSeries();
    if (!newtop)
	goto error;
    for (i=0, seriespos = 0.0; 
	 (subo=DXGetEnumeratedMember((Group)si->thisobj, i, NULL)); 
	 i++, seriespos += 1.0) 
	if (!DXSetSeriesMember(newtop, i, seriespos, subo))
	    goto error;
  /* done */
    return (Object)newtop;
  error:
    DXDelete((Object)newtop);
    return NULL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
drbg_hash_df(struct drbg_state *drbg,
			unsigned char *outval, size_t outlen,
			struct list_head *entropylist)
{
	int ret = 0;
	size_t len = 0;
	unsigned char input[5];
	unsigned char *tmp = drbg->scratchpad + drbg_statelen(drbg);
	struct drbg_string data;
	/* 10.4.1 step 3 */
	input[0] = 1;
	drbg_cpu_to_be32((outlen * 8), &input[1]);
	/* 10.4.1 step 4.1 -- concatenation of data for input into hash */
	drbg_string_fill(&data, input, 5);
	list_add(&data.list, entropylist);
	/* 10.4.1 step 4 */
	while (len < outlen) {
		short blocklen = 0;
		/* 10.4.1 step 4.1 */
		ret = drbg_kcapi_hash(drbg, NULL, tmp, entropylist);
		if (ret)
			goto out;
		/* 10.4.1 step 4.2 */
		input[0]++;
		blocklen = (drbg_blocklen(drbg) < (outlen - len)) ?
			    drbg_blocklen(drbg) : (outlen - len);
		memcpy(outval + len, tmp, blocklen);
		len += blocklen;
	}
out:
	memset(tmp, 0, drbg_blocklen(drbg));
	return ret;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
snd_ice1712_ews88mt_input_sense_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
{
	struct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);
	struct ews_spec *spec = ice->spec;
	int channel = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);
	unsigned char data, ndata;
	if (snd_BUG_ON(channel < 0 || channel > 7))
		return 0;
	snd_i2c_lock(ice->i2c);
	if (snd_i2c_readbytes(spec->i2cdevs[EWS_I2C_PCF1], &data, 1) != 1) {
		snd_i2c_unlock(ice->i2c);
		return -EIO;
	}
	ndata = (data & ~(1 << channel)) | (ucontrol->value.enumerated.item[0] ? 0 : (1 << channel));
	if (ndata != data && snd_i2c_sendbytes(spec->i2cdevs[EWS_I2C_PCF1],
					       &ndata, 1) != 1) {
		snd_i2c_unlock(ice->i2c);
		return -EIO;
	}
	snd_i2c_unlock(ice->i2c);
	return ndata != data;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gst_collect_pads2_set_flushing (GstCollectPads2 * pads, gboolean flushing)
{
  g_return_if_fail (pads != NULL);
  g_return_if_fail (GST_IS_COLLECT_PADS2 (pads));
  /* NOTE since this eventually calls _pop, some (STREAM_)LOCK is needed here */
  GST_COLLECT_PADS2_STREAM_LOCK (pads);
  gst_collect_pads2_set_flushing_unlocked (pads, flushing);
  GST_COLLECT_PADS2_STREAM_UNLOCK (pads);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
get_udp_in_errors() 
{
    FILE* f = NULL;
    u_int64_t errs = 0;
    char buf[512], *p;
    int len, i;
    /* need to reopen /proc/net/snmp file each time, it won't update otherwise */
    f = fopen("/proc/net/snmp", "r");
    if (!f) {
        // warn("could not open /proc/net/snmp");
        return 0;
    }
    /* seek for header line currently with poor programming using poor /proc interface...  */
    while (!feof(f)) {
        if (!fgets(buf, sizeof(buf)-1, f)) break;
        if (strstr(buf, "Udp:") && strstr(buf, "InErrors") && !feof(f)) {
            if(!fgets(buf, sizeof(buf)-1, f)) break;
            len = strlen(buf);
            /* Udp: InDatagrams NoPorts InErrors OutDatagrams
               Udp: 62771599 31995 4244 63083342              */
            p = buf;
            for (i=0; (i<3) && (p!=NULL) && (p < buf+len-1); i++, p++)  {
                p = strchr(p, ' ');
            }
            if ((p != NULL) && (p < buf+len-1)) { 
                errs = atol(p--);
            } else {
                errs = 0;
            }
            break;
        }
    }
    fclose(f);
    return errs;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
xkobo_shot()
{
	int i, j;
	for(i = 0; i < game.bolts && boltst[i]; i++)
		;
	for(j = i + 1; j < game.bolts && boltst[j]; j++)
		;
	if(j >= game.bolts)
	{
		sound.g_player_overheat(1);
		return 1;
	}
	shot_single(i, di, 0);
	shot_single(j, (di > 4) ? (di - 4) : (di + 4), 0);
	sound.g_player_fire();
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
SetOutputFormat(int format)
{
  if (format == this->OutputFormat)
    {
    return;
    }
  this->OutputFormat = format;
  // convert color format to number of scalar components
  int numComponents = 1;
  switch (this->OutputFormat)
    {
    case VTK_RGBA:
      numComponents = 4;
      break;
    case VTK_RGB:
      numComponents = 3;
      break;
    case VTK_LUMINANCE_ALPHA:
      numComponents = 2;
      break;
    case VTK_LUMINANCE:
      numComponents = 1;
      break;
    default:
      vtkErrorMacro(<< "SetOutputFormat: Unrecognized color format.");
      break;
    }
  this->NumberOfScalarComponents = numComponents;
  if (this->FrameBufferBitsPerPixel != numComponents*8)
    {
    this->FrameBufferMutex->Lock();
    this->FrameBufferBitsPerPixel = numComponents*8;
    if (this->Initialized)
      {
      this->UpdateFrameBuffer();
      }
    this->FrameBufferMutex->Unlock();
    }
  this->Modified();
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
hx509_ca_sign(hx509_context context,
	      hx509_ca_tbs tbs,
	      hx509_cert signer,
	      hx509_cert *certificate)
{
    const Certificate *signer_cert;
    AuthorityKeyIdentifier ai;
    int ret;
    memset(&ai, 0, sizeof(ai));
    signer_cert = _hx509_get_cert(signer);
    ret = get_AuthorityKeyIdentifier(context, signer_cert, &ai);
    if (ret)
	goto out;
    ret = ca_sign(context,
		  tbs,
		  _hx509_cert_private_key(signer),
		  &ai,
		  &signer_cert->tbsCertificate.subject,
		  certificate);
out:
    free_AuthorityKeyIdentifier(&ai);
    return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
get_fields_for_table(const Document* document, const Glib::ustring& table_name, bool /* including_system_fields */)
{
  //We could also get the field definitions from the database:
  //But that is inefficient because this method is called so often,
  //and that meta information is not even available if the user does not have SELECT rights.
  //Therefore we just assume that the Document has been updated from the database already.
  //type_vec_fields fieldsDatabase = get_fields_for_table_from_database(table_name, including_system_fields);
  if(!document)
  {
    std::cerr << G_STRFUNC << ": document is null" << std::endl;
    return type_vec_fields(); //This should never happen.
  }
  type_vec_fields result = document->get_table_fields(table_name);
  //Look at each field in the database:
  /*
  for(type_vec_fields::iterator iter = fieldsDocument.begin(); iter != fieldsDocument.end(); ++iter)
  {
    sharedptr<Field> field = *iter;
    const Glib::ustring field_name = field->get_name();
    //Get the field info from the database:
    //This is in the document as well, but it _might_ have changed.
    type_vec_fields::const_iterator iterFindDatabase = 
      std::find_if(fieldsDatabase.begin(), fieldsDatabase.end(), predicate_FieldHasName<Field>(field_name));
    if(iterFindDatabase != fieldsDatabase.end() ) //Ignore fields that don't exist in the database anymore.
    {
      Glib::RefPtr<Gnome::Gda::Column> field_info_document = field->get_field_info();
      //Update the Field information that _might_ have changed in the database.
      Glib::RefPtr<Gnome::Gda::Column> field_info = (*iterFindDatabase)->get_field_info();
      //libgda does not tell us whether the field is auto_incremented, so we need to get that from the document.
      field_info->set_auto_increment( field_info_document->get_auto_increment() );
      //libgda does not tell us whether the field is auto_incremented, so we need to get that from the document.
      //TODO_gda:field_info->set_primary_key( field_info_document->get_primary_key() );
      //libgda does yet tell us correct default_value information so we need to get that from the document.
      field_info->set_default_value( field_info_document->get_default_value() );
      field->set_field_info(field_info);
      result.push_back(*iter);
    }
  }
  //Add any fields that are in the database, but not in the document:
  for(type_vec_fields::iterator iter = fieldsDatabase.begin(); iter != fieldsDatabase.end(); ++iter)
  {
    const Glib::ustring field_name = (*iter)->get_name();
    //Look in the result so far:
    type_vec_fields::const_iterator iterFind = std::find_if(result.begin(), result.end(), predicate_FieldHasName<Field>(field_name));
    //Add it if it is not there:
    if(iterFind == result.end() )
      result.push_back(*iter);
  }
  */
  return result;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
variantSet(enum VariantType type, void *value, unsigned long valueSize, void *userParam, void (*setter)(void *userParam, const char *string))
{
	switch (type)
	{
		case VARIANT_TYPE_STRING:
			setter(userParam, value);
			break;
		case VARIANT_TYPE_SIGNED_INTEGER:
			if (valueSize >= sizeof(signed long))
			{
				char trans[32];
				snprintf(trans, sizeof(trans) - 1, "%li", *(signed long *)value);
				setter(userParam, trans);
			}
			break;
		case VARIANT_TYPE_UNSIGNED_INTEGER:
			if (valueSize >= sizeof(unsigned long))
			{
				char trans[32];
				snprintf(trans, sizeof(trans) - 1, "%lu", *(unsigned long *)value);
				setter(userParam, trans);
			}
			break;
		case VARIANT_TYPE_SIGNED_SHORT:
			if (valueSize >= sizeof(signed short))
			{
				char trans[16];
				snprintf(trans, sizeof(trans) - 1, "%d", *(signed short *)value);
				setter(userParam, trans);
			}
			break;
		case VARIANT_TYPE_UNSIGNED_SHORT:
			if (valueSize >= sizeof(signed short))
			{
				char trans[16];
				snprintf(trans, sizeof(trans) - 1, "%u", *(unsigned short *)value);
				setter(userParam, trans);
			}
			break;
		case VARIANT_TYPE_FLOAT:
		case VARIANT_TYPE_DOUBLE:
			if ((valueSize >= sizeof(float)) || (valueSize >= sizeof(double)))
			{
				char trans[128];
				snprintf(trans, sizeof(trans) - 1, "%f", *(float *)value);
				setter(userParam, trans);
			}
			break;
		case VARIANT_TYPE_CHAR:
			if (valueSize >= sizeof(char))
			{
				char actual[2] = { *(char *)value, 0 };
				setter(userParam, actual);
			}
			break;
		case VARIANT_TYPE_BINARY_B64:
			{
				char *ret = _variantBase64Encode(value, valueSize);
				setter(userParam, ret);
				free(ret);
			}
			break;
		default:
			break;
	}
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
rpz_get_zbits(ns_client_t *client,
	      dns_rdatatype_t ip_type, dns_rpz_type_t rpz_type)
{
	dns_rpz_zones_t *rpzs;
	dns_rpz_st_t *st;
	dns_rpz_zbits_t zbits;
	rpzs = client->view->rpzs;
	switch (rpz_type) {
	case DNS_RPZ_TYPE_CLIENT_IP:
		zbits = rpzs->have.client_ip;
		break;
	case DNS_RPZ_TYPE_QNAME:
		zbits = rpzs->have.qname;
		break;
	case DNS_RPZ_TYPE_IP:
		if (ip_type == dns_rdatatype_a) {
			zbits = rpzs->have.ipv4;
		} else if (ip_type == dns_rdatatype_aaaa) {
			zbits = rpzs->have.ipv6;
		} else {
			zbits = rpzs->have.ip;
		}
		break;
	case DNS_RPZ_TYPE_NSDNAME:
		zbits = rpzs->have.nsdname;
		break;
	case DNS_RPZ_TYPE_NSIP:
		if (ip_type == dns_rdatatype_a) {
			zbits = rpzs->have.nsipv4;
		} else if (ip_type == dns_rdatatype_aaaa) {
			zbits = rpzs->have.nsipv6;
		} else {
			zbits = rpzs->have.nsip;
		}
		break;
	default:
		INSIST(0);
		break;
	}
	st = client->query.rpz_st;
	/*
	 * Choose
	 *	the earliest configured policy zone (rpz->num)
	 *	QNAME over IP over NSDNAME over NSIP (rpz_type)
	 *	the smallest name,
	 *	the longest IP address prefix,
	 *	the lexically smallest address.
	 */
	if (st->m.policy != DNS_RPZ_POLICY_MISS) {
		if (st->m.type >= rpz_type) {
			zbits &= DNS_RPZ_ZMASK(st->m.rpz->num);
		} else{
			zbits &= DNS_RPZ_ZMASK(st->m.rpz->num) >> 1;
		}
	}
	/*
	 * If the client wants recursion, allow only compatible policies.
	 */
	if (!RECURSIONOK(client))
		zbits &= rpzs->p.no_rd_ok;
	return (zbits);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
openpgp_s2k (const void *passphrase, size_t passphraselen,
             int algo, int hashalgo,
             const void *salt, size_t saltlen,
             unsigned long iterations,
             size_t keysize, void *keybuffer)
{
  gpg_err_code_t ec;
  gcry_md_hd_t md;
  char *key = keybuffer;
  int pass, i;
  int used = 0;
  int secmode;
  if ((algo == GCRY_KDF_SALTED_S2K || algo == GCRY_KDF_ITERSALTED_S2K)
      && (!salt || saltlen != 8))
    return GPG_ERR_INV_VALUE;
  secmode = gcry_is_secure (passphrase) || gcry_is_secure (keybuffer);
  ec = gpg_err_code (gcry_md_open (&md, hashalgo,
                                   secmode? GCRY_MD_FLAG_SECURE : 0));
  if (ec)
    return ec;
  for (pass=0; used < keysize; pass++)
    {
      if (pass)
        {
          gcry_md_reset (md);
          for (i=0; i < pass; i++) /* Preset the hash context.  */
            gcry_md_putc (md, 0);
	}
      if (algo == GCRY_KDF_SALTED_S2K || algo == GCRY_KDF_ITERSALTED_S2K)
        {
          int len2 = passphraselen + 8;
          unsigned long count = len2;
          if (algo == GCRY_KDF_ITERSALTED_S2K)
            {
              count = iterations;
              if (count < len2)
                count = len2;
            }
          while (count > len2)
            {
              gcry_md_write (md, salt, saltlen);
              gcry_md_write (md, passphrase, passphraselen);
              count -= len2;
            }
          if (count < saltlen)
            gcry_md_write (md, salt, count);
          else
            {
              gcry_md_write (md, salt, saltlen);
              count -= saltlen;
              gcry_md_write (md, passphrase, count);
            }
        }
      else
        gcry_md_write (md, passphrase, passphraselen);
      gcry_md_final (md);
      i = gcry_md_get_algo_dlen (hashalgo);
      if (i > keysize - used)
        i = keysize - used;
      memcpy (key+used, gcry_md_read (md, hashalgo), i);
      used += i;
    }
  gcry_md_close (md);
  return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
DXDelete(Object o)
{
    int rc = 0, i, n;
    Class class;
    if (!o)
	return OK;
    if (o->count==PERMANENT)
	return OK;
    /* sanity checks - up thru dx 2.1.1, this was if DEBUGGED only */
    if (o->count < 0)
	DXErrorReturn(ERROR_DATA_INVALID,
		    "Object deleted too often! (or not an object)");
    class = DXGetObjectClass(o);
    if ((int)class<=(int)CLASS_MIN || (int)class>=(int)CLASS_MAX) {
	DXSetError(ERROR_DATA_INVALID,
		 "Deleting object of unknown class %d! (or not an object)",
		 class);
	return ERROR;
    }
    /* lock & decrement count */
    if (DXfetch_and_add(&o->count, -1, &o->lock, ID) > 1)
	return OK;
#if DEBUGGED
    /* tracing */
    if (trace>=2)
	DXDebug("Q","deleting object class %s at 0x%x", CLASS_NAME(o->class), o);
    if (trace>=1) {
	int n = (int) CLASS_CLASS(o->class);
	DXlock(&table->lock, 0);
	table->counts[n].deleted += 1;
	DXunlock(&table->lock, 0);
    }
#endif
    /*
     * delete attributes
     * XXX - this should by in an _DeleteObject to be called by subclass
     * i.e. _Delete should be handled like New and DXCopy
     */
    for (i=0, n=o->nattributes; i<n; i++)
	if (o->count != PERMANENT)
	    DXDelete(o->attributes[i].value);
    if (o->attributes!=o->local)
	DXFree((Pointer)o->attributes);
    /* user deletion */
    rc = _dxfDelete(o);
    /* in case we mistakenly delete this object again - same as above;
     *  was only if DEBUGGED up through dx 2.1.1
     */
    o->class_id = CLASS_DELETED;
    o->count = -1;
    o->class = NULL;
    /* finish deleting our stuff */
    DXdestroy_lock(&o->lock);
    DXFree((Pointer)o);
    return rc;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
changeKomi(But *but)  {
  CliMatch  *m = but_packet(but);
  char  komiStr[10];
  assert(MAGIC(m));
  if (newKomi(m->komiIn, butTextin_get(m->komiIn)) & BUTOUT_ERR)
    return(BUTOUT_ERR);
  if (but == m->komiUp)  {
    m->komi += 1.0;
    if (m->komi > 99.5)
      m->komi = 99.5;
  } else  {
    assert(but == m->komiDown);
    m->komi -= 1.0;
    if (m->komi < -99.5)
      m->komi = -99.5;
  }
  sprintf(komiStr, "%g", m->komi);
  butTextin_set(m->komiIn, komiStr, TRUE);
  return(0);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
expand_acl(struct proc_acl *proc, struct role_acl *role)
{
	char *tmpproc;
	struct proc_acl *tmpp;
	tmpproc = (char *)alloca(strlen(proc->filename) + 1);
	strcpy(tmpproc, proc->filename);
	while (parent_dir(proc->filename, &tmpproc)) {
		tmpp = lookup_acl_subject_by_name(role, tmpproc);
	        if (tmpp) {
			proc->parent_subject = tmpp;
			return;
		}
	}
	return;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
png_colorspace_check_xy(png_XYZ *XYZ, const png_xy *xy)
{
   int result;
   png_xy xy_test;
   /* As a side-effect this routine also returns the XYZ endpoints. */
   result = png_XYZ_from_xy(XYZ, xy);
   if (result) return result;
   result = png_xy_from_XYZ(&xy_test, XYZ);
   if (result) return result;
   if (png_colorspace_endpoints_match(xy, &xy_test,
      5/*actually, the math is pretty accurate*/))
      return 0;
   /* Too much slip */
   return 1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
setContent(GooString* new_content)
{
  if (isReadOnly()) {
    error(-1, "FormWidgetText::setContentCopy called on a read only field\n");
    return;
  }
  modified = gTrue;
  if (new_content == NULL) {
    parent->setContentCopy(NULL);
  } else {
    //append the unicode marker <FE FF> if needed
    if (!new_content->hasUnicodeMarker()) {
      new_content->insert(0, 0xff);
      new_content->insert(0, 0xfe);
    }
    GooString *cont = new GooString(new_content);
    parent->setContentCopy(cont);
    Object obj1;
    obj1.initString(cont);
    updateField ("V", &obj1);
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
tp_base_contact_list_channel_dispose (GObject *object)
{
  TpBaseContactListChannel *self = TP_BASE_CONTACT_LIST_CHANNEL (object);
  void (*dispose) (GObject *) =
    G_OBJECT_CLASS (_tp_base_contact_list_channel_parent_class)->dispose;
  _tp_base_contact_list_channel_close (self);
  if (dispose != NULL)
    dispose (object);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gnac_profiles_utils_init_raw_audioconvert(XMLDoc *doc)
{
  if (G_UNLIKELY(!raw)) {
    raw = gnac_profiles_xml_engine_get_text_node(doc,
        "//process[@id='gstreamer-audio']");
  }
  if (G_UNLIKELY(!audioconvert)) {
    audioconvert = gnac_profiles_xml_engine_get_text_node(doc,
        "//process[@id='audioconvert']");
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
glmLinearTexture(GLMmodel* model, float h, float w)
{
  GLMgroup *group;
  GLfloat dimensions[3];
  GLfloat x, y, scalefactor;
  GLuint i;
  if (!(model))return;
  if (model->texcoords)
    free(model->texcoords);
  model->numtexcoords = model->numvertices;
  model->texcoords=(GLfloat*)malloc(sizeof(GLfloat)*2*(model->numtexcoords+1));
  glmDimensions(model, dimensions);
  scalefactor = 2.0f /
    _glmAbs(_glmMax(_glmMax(dimensions[0], dimensions[1]), dimensions[2]));
  /* do the calculations */
  for(i = 1; i <= model->numvertices; i++) {
    x = model->vertices[3 * i + 0] * scalefactor;
    y = model->vertices[3 * i + 2] * scalefactor;
    model->texcoords[2 * i + 0] = ((x + 1.0f) / 2.0f) * w;
    model->texcoords[2 * i + 1] = ((y + 1.0f) / 2.0f) * h;
  }
  /* go through and put texture coordinate indices in all the triangles */
  group = model->groups;
  while(group) {
    for(i = 0; i < group->numtriangles; i++) {
      T(group->triangles[i]).tindices[0] = T(group->triangles[i]).vindices[0];
      T(group->triangles[i]).tindices[1] = T(group->triangles[i]).vindices[1];
      T(group->triangles[i]).tindices[2] = T(group->triangles[i]).vindices[2];
    }
    group = group->next;
  }
  verbose(1, "glmLinearTexture(): generated %d linear texture coordinates", model->numtexcoords);
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ndmca_tape_read_partial (struct ndm_session *sess, char *buf, unsigned count, int *read_count)
{
	struct ndmconn *	conn = sess->plumb.tape;
	int			rc;
	NDMC_WITH(ndmp9_tape_read, NDMP9VER)
		request->count = count;
		rc = NDMC_CALL(conn);
		if (rc == 0) {
			*read_count = reply->data_in.data_in_len;
			bcopy (reply->data_in.data_in_val, buf, *read_count);
		} else {
			rc = reply->error;
		}
		NDMC_FREE_REPLY();
	NDMC_ENDWITH
	return rc;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
isc_sockaddr_fromnetaddr(isc_sockaddr_t *sockaddr, const isc_netaddr_t *na,
		    in_port_t port)
{
	memset(sockaddr, 0, sizeof(*sockaddr));
	sockaddr->type.sin.sin_family = na->family;
	switch (na->family) {
	case AF_INET:
		sockaddr->length = sizeof(sockaddr->type.sin);
#ifdef ISC_PLATFORM_HAVESALEN
		sockaddr->type.sin.sin_len = sizeof(sockaddr->type.sin);
#endif
		sockaddr->type.sin.sin_addr = na->type.in;
		sockaddr->type.sin.sin_port = htons(port);
		break;
	case AF_INET6:
		sockaddr->length = sizeof(sockaddr->type.sin6);
#ifdef ISC_PLATFORM_HAVESALEN
		sockaddr->type.sin6.sin6_len = sizeof(sockaddr->type.sin6);
#endif
		memcpy(&sockaddr->type.sin6.sin6_addr, &na->type.in6, 16);
#ifdef ISC_PLATFORM_HAVESCOPEID
		sockaddr->type.sin6.sin6_scope_id = isc_netaddr_getzone(na);
#endif
		sockaddr->type.sin6.sin6_port = htons(port);
		break;
	default:
		INSIST(0);
	}
	ISC_LINK_INIT(sockaddr, link);
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
init_base()
{
  DBUG_ASSERT(inited == 0);
  inited= 1;
  /*
    Here we create file log handler. We don't do it for the table log handler
    here as it cannot be created so early. The reason is THD initialization,
    which depends on the system variables (parsed later).
  */
  if (!file_log_handler)
    file_log_handler= new Log_to_file_event_handler;
  /* by default we use traditional error log */
  init_error_log(LOG_FILE);
  file_log_handler->init_pthread_objects();
  mysql_rwlock_init(key_rwlock_LOCK_logger, &LOCK_logger);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
dewarpaDestroy(L_DEWARPA  **pdewa)
{
l_int32     i;
L_DEWARP   *dew;
L_DEWARPA  *dewa;
    PROCNAME("dewarpaDestroy");
    if (pdewa == NULL) {
        L_WARNING("ptr address is null!\n", procName);
        return;
    }
    if ((dewa = *pdewa) == NULL)
        return;
    for (i = 0; i < dewa->nalloc; i++) {
        if ((dew = dewa->dewarp[i]) != NULL)
            dewarpDestroy(&dew);
        if ((dew = dewa->dewarpcache[i]) != NULL)
            dewarpDestroy(&dew);
    }
    numaDestroy(&dewa->namodels);
    numaDestroy(&dewa->napages);
    FREE(dewa->dewarp);
    FREE(dewa->dewarpcache);
    FREE(dewa);
    *pdewa = NULL;
    return;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
sizeHint() const
{
    return fontMetrics().size(0, d->m_Text);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
amdlibGetOiTargetFromRawData(amdlibRAW_DATA  *rawData,
                                              amdlibOI_TARGET *target)
{
    int i;
    int cIndex = 0;
    char targVal[amdlibKEYW_VAL_LEN];
    amdlibLogTrace("amdlibFillOiTargetTableEntry()");
    target->element[cIndex].targetId = 1;
    /* Retrieve from Configuration Keyword values used for various headers */
    for (i=0; i < rawData->insCfg.nbKeywords; i++)
    {
        if (strstr(rawData->insCfg.keywords[i].name, "ESO OBS TARG NAME") != NULL)
        {
            strncpy(targVal, rawData->insCfg.keywords[i].value, 
                    amdlibKEYW_VAL_LEN);
            amdlibStripQuotes(targVal);
            strncpy(target->element[cIndex].targetName, targVal, 16);
        }
        /*Use strncmp since RA or DEC are not unique in the header*/
        if (strncmp(rawData->insCfg.keywords[i].name, "RA      ", 8) == 0)
        {
            sscanf(rawData->insCfg.keywords[i].value, "%lf", 
                   &target->element[cIndex].raEp0);
        }
        if (strncmp(rawData->insCfg.keywords[i].name, "DEC     ", 8) == 0)
        {
            sscanf(rawData->insCfg.keywords[i].value, "%lf", 
                   &target->element[cIndex].decEp0);
        }
        if (strncmp(rawData->insCfg.keywords[i].name, "EQUINOX ", 8) == 0)
        {
            sscanf(rawData->insCfg.keywords[i].value, "%lf", 
                   &target->element[cIndex].equinox);
        }
        /* the following values are fixed until ESO's VLTICS writes a good 
         * OI_TARGET by itself!*/
        strncpy(target->element[cIndex].velTyp, "UNKNOWN",  8 );
        strncpy(target->element[cIndex].velDef, "OPTICAL",  8 );
        strncpy(target->element[cIndex].specTyp, "UNKNOWN",  16 );
    }
    return amdlibSUCCESS;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gretl_model_set_full_vcv_info (MODEL *pmod, int vmaj, int vmin,
				   int order, int flags, double bw)
{
    VCVInfo *vi;
    int prev = 0;
    int err = 0;
    vi = gretl_model_get_data(pmod, "vcv_info");
    if (vi == NULL) {
	vi = vcv_info_new();
	if (vi == NULL) {
	    return E_ALLOC;
	}
    } else {
	prev = 1;
    }
    vi->vmaj = vmaj;
    vi->vmin = vmin;
    vi->order = order;
    vi->flags = flags;
    vi->bw = bw;
    if (!prev) {
	err = gretl_model_set_data(pmod, "vcv_info", vi, 
				   GRETL_TYPE_STRUCT,
				   sizeof *vi);
    }
    return err;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
list_backups(ext2_filsys fs, unsigned int *three,
				 unsigned int *five, unsigned int *seven)
{
	unsigned int *min = three;
	int mult = 3;
	unsigned int ret;
	if (!(fs->super->s_feature_ro_compat &
	      EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)) {
		ret = *min;
		*min += 1;
		return ret;
	}
	if (*five < *min) {
		min = five;
		mult = 5;
	}
	if (*seven < *min) {
		min = seven;
		mult = 7;
	}
	ret = *min;
	*min *= mult;
	return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
lowestEndPoint(const IntervalInfo &I1,
                             const IntervalInfo &I2) {
    SlotIndex E1 = getEndPoint(I1);
    SlotIndex E2 = getEndPoint(I2);
    if (E1 < E2)
      return true;
    if (E1 > E2)
      return false;
    // If two intervals end at the same point, we need a way to break the tie or
    // the set will assume they're actually equal and refuse to insert a
    // "duplicate". Just compare the vregs - fast and guaranteed unique.
    return std::get<0>(I1)->reg < std::get<0>(I2)->reg;
  }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
findsubquery(QTNode *root, QTNode *ex, QTNode *subs, bool *isfind)
{
	bool		DidFind = false;
	root = dofindsubquery(root, ex, subs, &DidFind);
	if (!subs && DidFind)
		root = dropvoidsubtree(root);
	if (isfind)
		*isfind = DidFind;
	return root;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ResearchGraph( PG_Widget *parent, const PG_Rect& rect, ContainerBase* container ) : GraphWidget( parent, rect ), cont( container ) {
         setRange( cont->maxresearchpoints+1, returnResourcenUseForResearch( cont, cont->maxresearchpoints ).energy );
         addCurve( 0x00ff00 );
         recalc();
      }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
changeActivation(bool activate, QWidget * originator) {
	if (!activate) return;
	//DebugDialog::debug(QString("change activation %1 %2").arg(activate).arg(originator->metaObject()->className()));
	FritzingWindow * fritzingWindow = qobject_cast<FritzingWindow *>(originator);
	if (fritzingWindow == NULL) {
		fritzingWindow = qobject_cast<FritzingWindow *>(originator->parent());
	}
	if (fritzingWindow == NULL) return;
	m_orderedTopLevelWidgets.removeOne(fritzingWindow);
	m_orderedTopLevelWidgets.push_front(fritzingWindow);
	m_activationTimer.stop();
	m_activationTimer.start();
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
isbinarystream(fz_buffer *buf)
{
	int i;
	for (i = 0; i < buf->len; i++)
		if (isbinary(buf->data[i]))
			return 1;
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gth_contact_sheet_theme_unref (GthContactSheetTheme *theme)
{
	if (theme == NULL)
		return;
	theme->ref--;
	if (theme->ref > 0)
		return;
	_g_object_unref (theme->file);
	g_free (theme->display_name);
	g_free (theme->header_font_name);
	g_free (theme->footer_font_name);
	g_free (theme->caption_font_name);
	g_free (theme);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
interpret_date_string(const char *date_opt, time_t * const time_p)
{
	FILE *date_child_fp;
	char date_resp[100];
	const char magic[] = "seconds-into-epoch=";
	char date_command[100];
	int retcode;		/* our eventual return code */
	int rc;			/* local return code */
	if (date_opt == NULL) {
		warnx(_("No --date option specified."));
		return 14;
	}
	/* prevent overflow - a security risk */
	if (strlen(date_opt) > sizeof(date_command) - 50) {
		warnx(_("--date argument too long"));
		return 13;
	}
	/* Quotes in date_opt would ruin the date command we construct. */
	if (strchr(date_opt, '"') != NULL) {
		warnx(_
		      ("The value of the --date option is not a valid date.\n"
		       "In particular, it contains quotation marks."));
		return 12;
	}
	sprintf(date_command, "date --date=\"%s\" +seconds-into-epoch=%%s",
		date_opt);
	if (debug)
		printf(_("Issuing date command: %s\n"), date_command);
	date_child_fp = popen(date_command, "r");
	if (date_child_fp == NULL) {
		warn(_("Unable to run 'date' program in /bin/sh shell. "
			    "popen() failed"));
		return 10;
	}
	if (!fgets(date_resp, sizeof(date_resp), date_child_fp))
		date_resp[0] = '\0';	/* in case fgets fails */
	if (debug)
		printf(_("response from date command = %s\n"), date_resp);
	if (strncmp(date_resp, magic, sizeof(magic) - 1) != 0) {
		warnx(_("The date command issued by %s returned "
				  "unexpected results.\n"
				  "The command was:\n  %s\n"
				  "The response was:\n  %s"),
			program_invocation_short_name, date_command, date_resp);
		retcode = 8;
	} else {
		long seconds_since_epoch;
		rc = sscanf(date_resp + sizeof(magic) - 1, "%ld",
			    &seconds_since_epoch);
		if (rc < 1) {
			warnx(_("The date command issued by %s returned "
				"something other than an integer where the "
				"converted time value was expected.\n"
				"The command was:\n  %s\n"
				"The response was:\n %s\n"),
			      program_invocation_short_name, date_command,
			      date_resp);
			retcode = 6;
		} else {
			retcode = 0;
			*time_p = seconds_since_epoch;
			if (debug)
				printf(_("date string %s equates to "
					 "%ld seconds since 1969.\n"),
				       date_opt, (long)*time_p);
		}
	}
	pclose(date_child_fp);
	return retcode;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
print_range(const struct nf_nat_ipv4_range *r)
{
	if (r->flags & NF_NAT_RANGE_MAP_IPS) {
		struct in_addr a;
		a.s_addr = r->min_ip;
		printf("%s", xtables_ipaddr_to_numeric(&a));
		if (r->max_ip != r->min_ip) {
			a.s_addr = r->max_ip;
			printf("-%s", xtables_ipaddr_to_numeric(&a));
		}
	}
	if (r->flags & NF_NAT_RANGE_PROTO_SPECIFIED) {
		printf(":");
		printf("%hu", ntohs(r->min.tcp.port));
		if (r->max.tcp.port != r->min.tcp.port)
			printf("-%hu", ntohs(r->max.tcp.port));
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
shiftAttribute(QDomElement & element, const char * attributeName, double d)
{
	double n = element.attribute(attributeName).toDouble() + d;
	element.setAttribute(attributeName, QString::number(n));
	return true;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
appendChart(GcWinID id)
{
    // GcWindowDialog is delete on close, so no need to delete
    GcWindowDialog *f = new GcWindowDialog(id, mainWindow);
    GcWindow *newone = f->exec();
    // returns null if cancelled or closed
    if (newone) {
        addChart(newone);
        newone->show();
    }
    // now wipe it
    delete f;
    // before we return lets turn the cursor off
    chartCursor = -2;
    winWidget->repaint();
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Validate(FreeImageIO *io, fi_handle handle) {
	char buf[6];
	if( io->read_proc(buf, 6, 1, handle) < 1 ) {
		return FALSE;
	}
	BOOL bResult = FALSE;
	if( !strncmp(buf, "GIF", 3) ) {
		if( buf[3] >= '0' && buf[3] <= '9' && buf[4] >= '0' && buf[4] <= '9' && buf[5] >= 'a' && buf[5] <= 'z' ) {
			bResult = TRUE;
		}
	}
	io->seek_proc(handle, -6, SEEK_CUR);
	return bResult;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
end_result_backtrace_entry (CutStreamParser *parser,
                            CutStreamParserPrivate *priv,
                            GMarkupParseContext *context,
                            const gchar *element_name, GError **error)
{
    if (!priv->backtrace_entry)
        return; /* should check file name, line, info? */
    priv->backtrace = g_list_prepend(priv->backtrace, priv->backtrace_entry);
    priv->backtrace_entry = NULL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
compute_all_net_distances(struct Map_info *In, struct Map_info *Net,
				 double netmax, double **dists, double dmax)
{
    int nn, kk, nalines, aline;
    double dist;
    struct line_pnts *Points;
    BOUND_BOX box;
    struct ilist *List;
    Points = Vect_new_line_struct();
    List = Vect_new_list();
    nn = Vect_get_num_primitives(In, GV_POINTS);
    nn = nn * (nn - 1);
    *dists = (double *)G_calloc(nn, sizeof(double));
    kk = 0;
    nalines = Vect_get_num_lines(In);
    for (aline = 1; aline <= nalines; aline++) {
	int i, altype;
	G_debug(3, "  aline = %d", aline);
	altype = Vect_read_line(In, Points, NULL, aline);
	if (!(altype & GV_POINTS))
	    continue;
	box.E = Points->x[0] + dmax;
	box.W = Points->x[0] - dmax;
	box.N = Points->y[0] + dmax;
	box.S = Points->y[0] - dmax;
	box.T = PORT_DOUBLE_MAX;
	box.B = -PORT_DOUBLE_MAX;
	Vect_select_lines_by_box(In, &box, GV_POINT, List);
	G_debug(3, "  %d points in box", List->n_values);
	for (i = 0; i < List->n_values; i++) {
	    int bline, ret;
	    bline = List->value[i];
	    if (bline == aline)
		continue;
	    G_debug(3, "    bline = %d", bline);
	    Vect_get_line_box(In, bline, &box);
	    G_debug(3, "  SP: %f %f -> %f %f", Points->x[0], Points->y[0],
		    box.E, box.N);
	    ret =
		Vect_net_shortest_path_coor(Net, Points->x[0], Points->y[0],
					    0.0, box.E, box.N,
					    0.0, netmax, netmax, &dist, NULL,
					    NULL, NULL, NULL, NULL, NULL);
	    if (ret == 0) {
		G_debug(3, "not reachable");
		continue;	/* Not reachable */
	    }
	    G_debug(3, "  dist = %f", dist);
	    if (dist <= dmax) {
		(*dists)[kk] = dist;
		kk++;
	    }
	    G_debug(3, "  kk = %d", kk);
	}
    }
    return (kk);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
CGUtil_print_header(Codegen *codegen, C4_Model *model){
    register gint i;
    Codegen_printf(codegen,
        "/* Code automatically generated by C4 DP library\n"
        " * Do not attempt to edit this code: it is spagetti.\n"
        " *\n"
        " * Model: %s\n"
        " */\n\n"
        " /* ---< START >--- */\n\n", model->name);
    for(i = 0; i < model->global_code_list->len; i++)
        Codegen_printf(codegen, model->global_code_list->pdata[i]);
    Codegen_printf(codegen, "\n");
    return;
    }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
grab_one(const nstring &project_name)
{
    //
    // get details of the project
    // to put in the structure
    //
    project_ty *pp = project_alloc(project_name.get_ref());
    pp->bind_existing();
    rpt_value_struct *rsp = new rpt_value_struct();
    rpt_value::pointer result(rsp);
    nstring pn(project_name_get(pp));
    rpt_value::pointer value = rpt_value_string::create(pn);
    rsp->assign("name", value);
    int err = project_is_readable(pp);
    if (err)
    {
	rsp->assign("error", rpt_value_string::create(strerror(err)));
    }
    else
    {
	//
	// The development directory of the project change is
	// the one which contains the trunk or branch baseline.
	//
	change::pointer cp = pp->change_get();
	if (cp->is_being_developed())
	{
	    nstring dd(change_development_directory_get(cp, 0));
	    rsp->assign("directory", rpt_value_string::create(dd));
	}
	value = rpt_value_pstate::create(project_name_get(pp));
	rsp->assign("state", value);
    }
    project_free(pp);
    //
    // all done
    //
    return result;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bfa_flash_status_read(void __iomem *pci_bar)
{
	union bfa_flash_dev_status_reg_u	dev_status;
	int				status;
	u32			ret_status;
	int				i;
	status = bfa_flash_fifo_flush(pci_bar);
	if (status < 0)
		return status;
	bfa_flash_set_cmd(pci_bar, 0, 4, 0, BFA_FLASH_READ_STATUS);
	for (i = 0; i < BFA_FLASH_CHECK_MAX; i++) {
		status = bfa_flash_cmd_act_check(pci_bar);
		if (!status)
			break;
	}
	if (status)
		return status;
	dev_status.i = readl(pci_bar + FLI_DEV_STATUS_REG);
	if (!dev_status.r.fifo_cnt)
		return BFA_FLASH_BUSY;
	ret_status = readl(pci_bar + FLI_RDDATA_REG);
	ret_status >>= 24;
	status = bfa_flash_fifo_flush(pci_bar);
	if (status < 0)
		return status;
	return ret_status;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cph_iface_mechanism_call_devices_get_sync (
    CphIfaceMechanism *proxy,
    gint arg_timeout,
    gint arg_limit,
    const gchar *const *arg_include_schemes,
    const gchar *const *arg_exclude_schemes,
    gchar **out_error,
    GVariant **out_devices,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "DevicesGet",
    g_variant_new ("(ii^as^as)",
                   arg_timeout,
                   arg_limit,
                   arg_include_schemes,
                   arg_exclude_schemes),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s@a{ss})",
                 out_error,
                 out_devices);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
GNUNET_DISK_directory_scan (const char *dirName,
                            GNUNET_FileNameCallback callback,
                            void *callback_cls)
{
  DIR *dinfo;
  struct dirent *finfo;
  struct stat istat;
  int count = 0;
  char *name;
  char *dname;
  unsigned int name_len;
  unsigned int n_size;
  GNUNET_assert (dirName != NULL);
  dname = GNUNET_STRINGS_filename_expand (dirName);
  if (dname == NULL)
    return GNUNET_SYSERR;
  while ((strlen (dname) > 0) && (dname[strlen (dname) - 1] == DIR_SEPARATOR))
    dname[strlen (dname) - 1] = '\0';
  if (0 != STAT (dname, &istat))
  {
    LOG_STRERROR_FILE (GNUNET_ERROR_TYPE_WARNING, "stat", dname);
    GNUNET_free (dname);
    return GNUNET_SYSERR;
  }
  if (!S_ISDIR (istat.st_mode))
  {
    LOG (GNUNET_ERROR_TYPE_WARNING, _("Expected `%s' to be a directory!\n"),
         dirName);
    GNUNET_free (dname);
    return GNUNET_SYSERR;
  }
  errno = 0;
  dinfo = OPENDIR (dname);
  if ((errno == EACCES) || (dinfo == NULL))
  {
    LOG_STRERROR_FILE (GNUNET_ERROR_TYPE_WARNING, "opendir", dname);
    if (dinfo != NULL)
      CLOSEDIR (dinfo);
    GNUNET_free (dname);
    return GNUNET_SYSERR;
  }
  name_len = 256;
  n_size = strlen (dname) + name_len + 2;
  name = GNUNET_malloc (n_size);
  while ((finfo = READDIR (dinfo)) != NULL)
  {
    if ((0 == strcmp (finfo->d_name, ".")) ||
        (0 == strcmp (finfo->d_name, "..")))
      continue;
    if (callback != NULL)
    {
      if (name_len < strlen (finfo->d_name))
      {
        GNUNET_free (name);
        name_len = strlen (finfo->d_name);
        n_size = strlen (dname) + name_len + 2;
        name = GNUNET_malloc (n_size);
      }
      /* dname can end in "/" only if dname == "/";
       * if dname does not end in "/", we need to add
       * a "/" (otherwise, we must not!) */
      GNUNET_snprintf (name, n_size, "%s%s%s", dname,
                       (strcmp (dname, DIR_SEPARATOR_STR) ==
                        0) ? "" : DIR_SEPARATOR_STR, finfo->d_name);
      if (GNUNET_OK != callback (callback_cls, name))
      {
        CLOSEDIR (dinfo);
        GNUNET_free (name);
        GNUNET_free (dname);
        return GNUNET_SYSERR;
      }
    }
    count++;
  }
  CLOSEDIR (dinfo);
  GNUNET_free (name);
  GNUNET_free (dname);
  return count;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gs_copy_glyph_options(gs_font *font, gs_glyph glyph, gs_font *copied,
                      int options)
{
    int code;
#define MAX_GLYPH_PIECES 64	/* arbitrary, but 32 is too small - bug 687698. */
    gs_glyph glyphs[MAX_GLYPH_PIECES];
    uint count = 1, i;
    if (copied->procs.font_info != copied_font_info)
        return_error(gs_error_rangecheck);
    code = cf_data(copied)->procs->copy_glyph(font, glyph, copied, options);
    if (code != 0)
        return code;
    /* Copy any sub-glyphs. */
    glyphs[0] = glyph;
    code = psf_add_subset_pieces(glyphs, &count, MAX_GLYPH_PIECES, MAX_GLYPH_PIECES,
                          font);
    if (code < 0)
        return code;
    if (count > MAX_GLYPH_PIECES)
        return_error(gs_error_limitcheck);
    for (i = 1; i < count; ++i) {
        code = gs_copy_glyph_options(font, glyphs[i], copied,
                                     (options & ~COPY_GLYPH_NO_OLD) | COPY_GLYPH_BY_INDEX);
        if (code < 0)
            return code;
        /* if code > 0 then we already have the glyph, so no need to process further.
         * If the original glyph was not a CID then we are copying by name, not by index.
         * But the copy above copies by index which means we don't have an entry for
         * the glyp-h component in the name table. If we are using names then we
         * absolutely *must* have an entry in the name table, so go ahead and add
         * one here. Note that the array returned by psf_add_subset_pieces has the
         * GIDs with an offset of GS_MIN_GLYPH_INDEX added. Previously we removed this
         * offset, but if the resulting GID referenced a name already in use (or later used)
         * then the generated CMAP was incorrect. By leaving the offset in place we get
         * a name generated (numeric name based on GID) which gurantees no name collisions.
         * (Bug #693444).
         */
        if (code == 0 && glyph < GS_MIN_CID_GLYPH && glyphs[i] > GS_MIN_GLYPH_INDEX) {
            code = copy_glyph_name(font, glyphs[i], copied,
                               glyphs[i]);
            if (code < 0)
                return code;
        }
    }
    /*
     * Because 'seac' accesses the Encoding of the font as well as the
     * glyphs, we have to copy the Encoding entries as well.
     */
    if (count == 1)
        return 0;
    switch (font->FontType) {
    case ft_encrypted:
    case ft_encrypted2:
        break;
    default:
        return 0;
    }
#if 0 /* No need to add subglyphs to the Encoding because they always are
         taken from StandardEncoding (See the Type 1 spec about 'seac').
         Attempt to add them to the encoding can cause a conflict,
         if the encoding specifies different glyphs for these char codes
         (See the bug #687172). */
    {
        gs_copied_glyph_t *pcg;
        gs_glyph_data_t gdata;
        gs_char chars[2];
        gdata.memory = font->memory;
        /* Since we just copied the glyph, copied_glyph_slot can't fail. */
        DISCARD(copied_glyph_slot(cf_data(copied), glyph, &pcg));
        gs_glyph_data_from_string(&gdata, pcg->gdata.data, pcg->gdata.size,
                                  NULL);
        code = gs_type1_piece_codes((gs_font_type1 *)font, &gdata, chars);
        if (code <= 0 ||	/* 0 is not possible here */
            (code = gs_copied_font_add_encoding(copied, chars[0], glyphs[1])) < 0 ||
            (code = gs_copied_font_add_encoding(copied, chars[1], glyphs[2])) < 0
            )
            return code;
    }
#endif
    return 0;
#undef MAX_GLYPH_PIECES
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
translate_page_flags(char *buffer, ulong flags)
{
	char buf[BUFSIZE];
	int i, others;
	sprintf(buf, "%lx", flags);
	if (flags) {
		for (i = others = 0; i < vt->nr_pageflags; i++) {
			if (flags & vt->pageflags_data[i].mask)
				sprintf(&buf[strlen(buf)], "%s%s",
					others++ ? "," : " ",
					vt->pageflags_data[i].name);
		}
	}
	strcat(buf, "\n");
	strcpy(buffer, buf);
	return(strlen(buf));
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bnx2x_warpcore_reset_lane(struct bnx2x *bp,
				      struct bnx2x_phy *phy,
				      u8 reset)
{
	u16 val;
	/* Take lane out of reset after configuration is finished */
	bnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,
			MDIO_WC_REG_DIGITAL5_MISC6, &val);
	if (reset)
		val |= 0xC000;
	else
		val &= 0x3FFF;
	bnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,
			 MDIO_WC_REG_DIGITAL5_MISC6, val);
	bnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,
			 MDIO_WC_REG_DIGITAL5_MISC6, &val);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ptaGetPt(PTA        *pta,
         l_int32     index,
         l_float32  *px,
         l_float32  *py)
{
    PROCNAME("ptaGetPt");
    if (!pta)
        return ERROR_INT("pta not defined", procName, 1);
    *px = pta->x[index];
    *py = pta->y[index];
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
merge_star(GList *csl, struct cat_star *new)
{
	GList *sl;
	struct cat_star *cats;
	for (sl = csl; sl != NULL; sl = sl->next) {
		cats = CAT_STAR(sl->data);
		if (cats_is_duplicate(cats, new)) {
			/* these are the funny replacement/reject rules */
			if (CATS_TYPE(cats) == CAT_STAR_TYPE_SREF) {
				cat_star_release(cats);
				cat_star_ref(new);
				sl->data = new;
			} else if (CATS_TYPE(cats) == CAT_STAR_TYPE_ALIGN) {
				if (CATS_TYPE(new) != CAT_STAR_TYPE_SREF) {
					cat_star_release(cats);
					cat_star_ref(new);
					sl->data = new;
				}
			} else if (CATS_TYPE(cats) == CAT_STAR_TYPE_CAT) {
				if (CATS_TYPE(new) != CAT_STAR_TYPE_SREF
				    && CATS_TYPE(new) != CAT_STAR_TYPE_ALIGN) {
					cat_star_release(cats);
					cat_star_ref(new);
					sl->data = new;
				}
			} else if (CATS_TYPE(cats) == CAT_STAR_TYPE_APSTD 
				   || CATS_TYPE(cats) == CAT_STAR_TYPE_APSTAR) {
				if (CATS_TYPE(new) == CAT_STAR_TYPE_APSTD
				    || CATS_TYPE(new) == CAT_STAR_TYPE_APSTAR) {
					cat_star_release(cats);
					cat_star_ref(new);
					sl->data = new;
				}
			}
			break;
		} 
	}
	if (sl == NULL) {
		cat_star_ref(new);
		csl = g_list_prepend(csl, new);
	}
	return csl;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bd_queue_initialize(struct ipw2100_priv *priv,
				struct ipw2100_bd_queue *q, u32 base, u32 size,
				u32 r, u32 w)
{
	IPW_DEBUG_INFO("enter\n");
	IPW_DEBUG_INFO("initializing bd queue at virt=%p, phys=%08x\n", q->drv,
		       (u32) q->nic);
	write_register(priv->net_dev, base, q->nic);
	write_register(priv->net_dev, size, q->entries);
	write_register(priv->net_dev, r, q->oldest);
	write_register(priv->net_dev, w, q->next);
	IPW_DEBUG_INFO("exit\n");
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
open_config() {
    FILE *fp = NULL;
    char *line;
    key_cmd *cmd;
    confentry *lastnode = NULL, *newnode = NULL;
    int lineno = 1, ret = 0;
    size_t n = 0;
    /* Allow the configuration file to be overridden */
    if (!config)
	config = CONFIG;
    fp = fopen(config, "r");
    if (fp == NULL) {
	lprintf("Warning: could not open the configuration file %s: %s\n", config, strerror(errno));
	return OK;
    }
    if (verbose > 1)
	lprintf("Using configuration file %s\n", config);
    while (!feof(fp) && (ret >=0)) {
	line = NULL;
	ret = getline(&line, &n, fp);
	if ((ret > 0) && (proc_config(lineno, line, &cmd) == OK)) {
	    newnode = (confentry *)(malloc(sizeof(confentry)));
	    if (newnode == NULL) {
		lprintf("Error: memory allocation failed\n");
		close_config();
		free(line);
		return MEMERR;
	    }
	    newnode->cmd = cmd;
	    newnode->next = NULL;
	    if (list == NULL) {
		list = newnode;
	    } else {
		lastnode->next = newnode;
	    }
	    lastnode = newnode;
	    if (verbose > 1) {
		lprintf("Config: ");
		lprint_mask(cmd->keys);
		lprintf(" -:- ");
		print_etype(cmd->type);
		lprintf(" -:- ");
		print_attrs(cmd);
		lprintf(" -:- %s\n", cmd->command);
	    }
	}
	free(line);
	++lineno;
    }
    fclose(fp);
    return OK;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
__ioc_wait_on_page (ioc_page_t *page, call_frame_t *frame, off_t offset,
                    size_t size)
{
        ioc_waitq_t *waitq = NULL;
        ioc_local_t *local = NULL;
        GF_VALIDATE_OR_GOTO ("io-cache", frame, out);
        local = frame->local;
        GF_VALIDATE_OR_GOTO (frame->this->name, local, out);
        if (page == NULL) {
                local->op_ret = -1;
                local->op_errno = ENOMEM;
                gf_log (frame->this->name, GF_LOG_WARNING,
                        "asked to wait on a NULL page");
        }
        waitq = GF_CALLOC (1, sizeof (*waitq), gf_ioc_mt_ioc_waitq_t);
        if (waitq == NULL) {
                local->op_ret = -1;
                local->op_errno = ENOMEM;
                goto out;
        }
        gf_log (frame->this->name, GF_LOG_TRACE,
                "frame(%p) waiting on page = %p, offset=%"PRId64", "
                "size=%"GF_PRI_SIZET"",
                frame, page, offset, size);
        waitq->data = frame;
        waitq->next = page->waitq;
        waitq->pending_offset = offset;
        waitq->pending_size = size;
        page->waitq = waitq;
        /* one frame can wait only once on a given page,
         * local->wait_count is number of pages a frame is waiting on */
        ioc_local_lock (local);
        {
                local->wait_count++;
        }
        ioc_local_unlock (local);
out:
        return;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
light_read(struct seq_file *m)
{
	int status;
	if (!tp_features.light) {
		seq_printf(m, "status:\t\tnot supported\n");
	} else if (!tp_features.light_status) {
		seq_printf(m, "status:\t\tunknown\n");
		seq_printf(m, "commands:\ton, off\n");
	} else {
		status = light_get_status();
		if (status < 0)
			return status;
		seq_printf(m, "status:\t\t%s\n", onoff(status, 0));
		seq_printf(m, "commands:\ton, off\n");
	}
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_dxf_ExReadDXRCFiles ()
{
    struct passwd	*pass;
    char		buf [1024];
    struct stat		curr;				/* local dir */
    struct stat		home;				/* home  dir */
    struct stat		sys;				/* system dir */
    struct stat		sys2;				/* system dir */
    int			n;
    char		*root;
    /*
     * Since the inputs get stacked we want them in reverse order.
     *
     * We use the stat calls to make sure that we don't include an init
     * file twice.  This could occur previously if $HOME == current dir,
     * etc.
     */
    /* If we are connected to the UI then this is called from the command
     * to get a license. The linefeed from the license command gets read
     * by the include in the dxrc system file. When we return we don't read
     * the linefeed from the license command and our char ptr is not reset.
     * this will cause a syntax error if the next command is a "$" command.
     */
    if(_dxd_exRemote)
        yycharno = 0;
    curr.st_dev = curr.st_ino = 0;
    home.st_dev = home.st_ino = 0;
    sys .st_dev = sys .st_ino = 0;
    buf[0] = '\0';
    if (getcwd (buf, 1022) == NULL)
	buf[0] = '\0';
    n = strlen (buf);
    sprintf (&buf[n], "/%s", DXRC);
    stat (buf, &curr);
    one_dxrc (DXRC);					/* local dir */
#if DXD_LACKS_UNIX_UID
    sprintf(buf, "C:\\%s", DXRC);
    stat(buf, &home);
    if(DIFFERENT_FILES (curr, home))
	one_dxrc (buf);					/* home dir */
#else
    if ((pass = getpwuid (geteuid ())) != NULL)
    {
	sprintf (buf, "%s/%s", pass->pw_dir, DXRC);
	stat (buf, &home);
	if (DIFFERENT_FILES (curr, home))
	    one_dxrc (buf);				/* home dir */
    }
#endif
    if ((root = (char *) getenv ("DXROOT")) != NULL)
    {
	sprintf (buf, "%s/%s", root, DXRC);
	stat (buf, &sys);
	if (DIFFERENT_FILES (curr, sys) &&
	    DIFFERENT_FILES (home, sys))
	    one_dxrc (buf);				/* system */
	sprintf (buf, "%s/lib/%s", root, SYSDXRC);
	stat (buf, &sys2);
	if (DIFFERENT_FILES (curr, sys2) &&
	    DIFFERENT_FILES (home, sys2) &&
	    DIFFERENT_FILES (sys, sys2))
	    one_dxrc (buf);				/* 2nd system */
    }
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
icmp_load(netsnmp_cache *cache, void *vmagic)
{
    long            ret_value = -1;
    ret_value = linux_read_icmp_stat(&icmpstat);
    if ( ret_value < 0 ) {
        DEBUGMSGTL(("mibII/icmp", "Failed to load ICMP Group (linux)\n"));
    } else {
        DEBUGMSGTL(("mibII/icmp", "Loaded ICMP Group (linux)\n"));
    }
    icmp_stats_load(cache, vmagic);
    icmp_msg_stats_load(cache, vmagic);
    return ret_value;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
RS_isRegis(const char *str)
{
	int			state = RS_IN_WAIT;
	const char *c = str;
	while (*c)
	{
		if (state == RS_IN_WAIT)
		{
			if (t_isalpha(c))
				 /* okay */ ;
			else if (t_iseq(c, '['))
				state = RS_IN_ONEOF;
			else
				return false;
		}
		else if (state == RS_IN_ONEOF)
		{
			if (t_iseq(c, '^'))
				state = RS_IN_NONEOF;
			else if (t_isalpha(c))
				state = RS_IN_ONEOF_IN;
			else
				return false;
		}
		else if (state == RS_IN_ONEOF_IN || state == RS_IN_NONEOF)
		{
			if (t_isalpha(c))
				 /* okay */ ;
			else if (t_iseq(c, ']'))
				state = RS_IN_WAIT;
			else
				return false;
		}
		else
			elog(ERROR, "internal error in RS_isRegis: state %d", state);
		c += pg_mblen(c);
	}
	return (state == RS_IN_WAIT);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
rc_proc_getent(const char *ent)
{
#ifdef __linux__
	FILE *fp;
	char *proc, *p, *value = NULL;
	size_t i, len;
	if (!exists("/proc/cmdline"))
		return NULL;
	if (!(fp = fopen("/proc/cmdline", "r")))
		return NULL;
	proc = NULL;
	i = 0;
	if (rc_getline(&proc, &i, fp) == -1 || proc == NULL)
		return NULL;
	if (proc != NULL) {
		len = strlen(ent);
		while ((p = strsep(&proc, " "))) {
			if (strncmp(ent, p, len) == 0 && (p[len] == '\0' || p[len] == ' ' || p[len] == '=')) {
				p += len;
				if (*p == '=')
					p++;
				value = xstrdup(p);
			}
		}
	}
	if (!value)
		errno = ENOENT;
	fclose(fp);
	free(proc);
	return value;
#else
	return NULL;
#endif
}
CWE-119  False
CWE-120  False
CWE-469  True
CWE-476  False
CWE-other  False
--------------------------
canSplitCriticalExits(const SplitAnalysis::LoopBlocks &Blocks,
                                     BlockPtrSet &CriticalExits) {
  // If we don't allow critical edge splitting, require no critical exits.
  if (!AllowSplit)
    return CriticalExits.empty();
  for (BlockPtrSet::iterator I = CriticalExits.begin(), E = CriticalExits.end();
       I != E; ++I) {
    const MachineBasicBlock *Succ = *I;
    // We want to insert a new pre-exit MBB before Succ, and change all the
    // in-loop blocks to branch to the pre-exit instead of Succ.
    // Check that all the in-loop predecessors can be changed.
    for (MachineBasicBlock::const_pred_iterator PI = Succ->pred_begin(),
         PE = Succ->pred_end(); PI != PE; ++PI) {
      const MachineBasicBlock *Pred = *PI;
      // The external predecessors won't be altered.
      if (!Blocks.Loop.count(Pred) && !Blocks.Preds.count(Pred))
        continue;
      if (!canAnalyzeBranch(Pred))
        return false;
    }
    // If Succ's layout predecessor falls through, that too must be analyzable.
    // We need to insert the pre-exit block in the gap.
    MachineFunction::const_iterator MFI = Succ;
    if (MFI == mf_.begin())
      continue;
    if (!canAnalyzeBranch(--MFI))
      return false;
  }
  // No problems found.
  return true;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
render(Window& srcWindow, const ColourRect* modcols, const Rect* clipper) const
    {
        // TODO: Fix layer priority handling
        // render all layers defined for this state
        for(LayersList::const_iterator curr = d_layers.begin(); curr != d_layers.end(); ++curr)
            (*curr).render(srcWindow, modcols, clipper, d_clipToDisplay);
    }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
directory_info_has_arrived(time_t now, int from_cache)
{
  const or_options_t *options = get_options();
  if (!router_have_minimum_dir_info()) {
    int quiet = directory_too_idle_to_fetch_descriptors(options, now);
    log(quiet ? LOG_INFO : LOG_NOTICE, LD_DIR,
        "I learned some more directory information, but not enough to "
        "build a circuit: %s", get_dir_info_status_string());
    update_all_descriptor_downloads(now);
    return;
  } else {
    if (directory_fetches_from_authorities(options)) {
      update_all_descriptor_downloads(now);
    }
    /* if we have enough dir info, then update our guard status with
     * whatever we just learned. */
    entry_guards_compute_status(options, now);
    /* Don't even bother trying to get extrainfo until the rest of our
     * directory info is up-to-date */
    if (options->DownloadExtraInfo)
      update_extrainfo_downloads(now);
  }
  if (server_mode(options) && !net_is_disabled() && !from_cache &&
      (can_complete_circuit || !any_predicted_circuits(now)))
    consider_testing_reachability(1, 1);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
PyFF_Font_get_woffMajor(PyFF_Font *self,void *closure) {
    int version = self->fv->sf->woffMajor;
    if ( version==woffUnset )
Py_RETURN_NONE;
return( Py_BuildValue("i", version ));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
add_layer_request(struct FlattenSpec *spec, const char *layer)
{
  spec->layers = realloc(spec->layers,
                         sizeof(struct xcfLayer) * (1+spec->numLayers));
  if( spec->layers == NULL )
    FatalUnexpected(_("Out of memory"));
  spec->layers[spec->numLayers].name = layer ;
  spec->layers[spec->numLayers].mode = (GimpLayerModeEffects)-1 ;
  spec->layers[spec->numLayers].opacity = 9999 ;
  spec->layers[spec->numLayers].hasMask = -1 ;
  spec->numLayers++ ;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
DoValAndDictTypesMatch(
	QTYPES	eValType,
	FLMUINT	uiDictType)
{
	if (uiDictType > FLM_CONTEXT_TYPE)
	{
		return( FALSE);
	}
	else
	{
		// subtract 1 from QTYPES - array doesn't have space for the NO_TYPE enum
		return gv_DoValAndDictTypesMatch[ ((int)eValType) - FIRST_VALUE][ uiDictType];
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ccid_error(int error, const char *file, int line, const char *function)
{
	const char *text;
	char var_text[30];
	switch (error)
	{
		case 0x00:
			text = "Command not supported or not allowed";
			break;
		case 0x01:
			text = "Wrong command length";
			break;
		case 0x05:
			text = "Invalid slot number";
			break;
		case 0xA2:
			text = "Card short-circuiting. Card powered off";
			break;
		case 0xA3:
			text = "ATR too long (> 33)";
			break;
		case 0xAB:
			text = "No data exchanged";
			break;
		case 0xB0:
			text = "Reader in EMV mode and T=1 message too long";
			break;
		case 0xBB:
			text = "Protocol error in EMV mode";
			break;
		case 0xBD:
			text = "Card error during T=1 exchange";
			break;
		case 0xBE:
			text = "Wrong APDU command length";
			break;
		case 0xE0:
			text = "Slot busy";
			break;
		case 0xEF:
			text = "PIN cancelled";
			break;
		case 0xF0:
			text = "PIN timeout";
			break;
		case 0xF2:
			text = "Busy with autosequence";
			break;
		case 0xF3:
			text = "Deactivated protocol";
			break;
		case 0xF4:
			text = "Procedure byte conflict";
			break;
		case 0xF5:
			text = "Class not supported";
			break;
		case 0xF6:
			text = "Protocol not supported";
			break;
		case 0xF7:
			text = "Invalid ATR checksum byte (TCK)";
			break;
		case 0xF8:
			text = "Invalid ATR first byte";
			break;
		case 0xFB:
			text = "Hardware error";
			break;
		case 0xFC:
			text = "Overrun error";
			break;
		case 0xFD:
			text = "Parity error during exchange";
			break;
		case 0xFE:
			text = "Card absent or mute";
			break;
		case 0xFF:
			text = "Activity aborted by Host";
			break;
		default:
			if ((error >= 1) && (error <= 127))
				(void)snprintf(var_text, sizeof(var_text), "error on byte %d",
					error);
			else
				(void)snprintf(var_text, sizeof(var_text),
					"Unknown CCID error: 0x%02X", error);
			text = var_text;
			break;
	}
	log_msg(PCSC_LOG_ERROR, "%s:%d:%s %s", file, line, function, text);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gst_video_format_from_rgb24_masks (int red_mask, int green_mask, int blue_mask)
{
  if (red_mask == 0xff0000 && green_mask == 0x00ff00 && blue_mask == 0x0000ff) {
    return GST_VIDEO_FORMAT_RGB;
  }
  if (red_mask == 0x0000ff && green_mask == 0x00ff00 && blue_mask == 0xff0000) {
    return GST_VIDEO_FORMAT_BGR;
  }
  return GST_VIDEO_FORMAT_UNKNOWN;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gwy_debug_objects_creation_detailed(GObject *object,
                                    const gchar *details)
{
    DebugObjectInfo *info;
    if (!G_UNLIKELY(debug_objects_enabled))
        return;
    if (!id) {
        g_assert(!debug_objects_timer && !debug_objects);
        debug_objects_timer = g_timer_new();
    }
    info = g_slice_new(DebugObjectInfo);
    info->id = ++id;
    info->type = G_TYPE_FROM_INSTANCE(object);
    info->address = object;
    info->details = details;
    info->create_time = g_timer_elapsed(debug_objects_timer, NULL);
    info->destroy_time = -1;
    g_object_weak_ref(info->address, &debug_objects_set_time,
                      &info->destroy_time);
    debug_objects = g_list_prepend(debug_objects, info);
    gwy_debug("Added watch for %s %p",
              g_type_name(info->type), info->address);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
get_result (char *buf, RcvMsg * rmsg)
{
  enum ck_msg_type type;
  CheckMsg msg;
  int n;
  n = upack (buf, &msg, &type);
  if (n == -1)
    eprintf ("Error in call to upack", __FILE__, __LINE__ - 2);
  if (type == CK_MSG_CTX) {
    CtxMsg *cmsg = (CtxMsg *) & msg;
    rcvmsg_update_ctx (rmsg, cmsg->ctx);
  } else if (type == CK_MSG_LOC) {
    LocMsg *lmsg = (LocMsg *) & msg;
    if (rmsg->failctx == CK_CTX_INVALID) {
      rcvmsg_update_loc (rmsg, lmsg->file, lmsg->line);
    }
    free (lmsg->file);
  } else if (type == CK_MSG_FAIL) {
    FailMsg *fmsg = (FailMsg *) & msg;
    if (rmsg->msg == NULL) {
      rmsg->msg = emalloc (strlen (fmsg->msg) + 1);
      strcpy (rmsg->msg, fmsg->msg);
      rmsg->failctx = rmsg->lastctx;
    } else {
      /* Skip subsequent failure messages, only happens for CK_NOFORK */
    }
    free (fmsg->msg);
  } else
    check_type (type, __FILE__, __LINE__);
  return n;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
isABalanced(scapegoat *goat, btree* run, btree* parent, size_t *size){
	size_t a = 0, b = 0;
	a = *size;
	//btree_info(run, NULL, NULL, NULL, NULL, &a, NULL, NULL);
	//determine which child run->data is (avoid re-evaluating the lhs)
	btree_info(btree_sibling(parent, run), NULL, NULL, NULL, NULL, &b, NULL, NULL);
	//wparent += w + 1;
	*size = a+1+b;//goes up by at least 1
	return (a <= (goat->a*(a+1+b))) && (b <= (goat->a*(a+1+b)));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
makeconstdata(nc_type nctype)
{
    Constant con = nullconstant;
    consttype = nctype;
    con.nctype = nctype;
    con.lineno = lineno;
    switch (nctype) {
	case NC_CHAR: con.value.charv = char_val; break;
        case NC_BYTE: con.value.int8v = byte_val; break;
        case NC_SHORT: con.value.int16v = int16_val; break;
        case NC_INT: con.value.int32v = int32_val; break;
        case NC_FLOAT:
	    con.value.floatv = float_val;
	    break;
        case NC_DOUBLE:
	    con.value.doublev = double_val;
	    break;
        case NC_STRING: { /* convert to a set of chars*/
	    int len;
	    len = strlen(lextext);
	    con.value.stringv.len = len;
	    con.value.stringv.stringv = nulldup(lextext);
	    }
	    break;
	/* Allow these constants even in netcdf-3 */
        case NC_UBYTE: con.value.uint8v = ubyte_val; break;
        case NC_USHORT: con.value.uint16v = uint16_val; break;
        case NC_UINT: con.value.uint32v = uint32_val; break;
        case NC_INT64: con.value.int64v = int64_val; break;
        case NC_UINT64: con.value.uint64v = uint64_val; break;
#ifdef USE_NETCDF4
	case NC_OPAQUE: {
	    char* s;
	    int len,padlen;
	    len = strlen(lextext);
	    padlen = len;
	    if(padlen < 16) padlen = 16;
	    if((padlen % 2) == 1) padlen++;
	    s = (char*)emalloc(padlen+1);
	    memset((void*)s,'0',padlen);
	    s[padlen]='\0';
	    strncpy(s,lextext,len);
	    con.value.opaquev.stringv = s;
	    con.value.opaquev.len = padlen;
	    } break;
#endif
	case NC_FILLVALUE:
	    break; /* no associated value*/
	default:
	    yyerror("Data constant: unexpected NC type: %s",
		    nctypename(nctype));
	    con.value.stringv.stringv = NULL;    
	    con.value.stringv.len = 0;
    }
    return con;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
snd_usb_add_audio_stream(struct snd_usb_audio *chip,
			     int stream,
			     struct audioformat *fp)
{
	struct snd_usb_stream *as;
	struct snd_usb_substream *subs;
	struct snd_pcm *pcm;
	int err;
	list_for_each_entry(as, &chip->pcm_list, list) {
		if (as->fmt_type != fp->fmt_type)
			continue;
		subs = &as->substream[stream];
		if (subs->ep_num == fp->endpoint) {
			list_add_tail(&fp->list, &subs->fmt_list);
			subs->num_formats++;
			subs->formats |= fp->formats;
			return 0;
		}
	}
	/* look for an empty stream */
	list_for_each_entry(as, &chip->pcm_list, list) {
		if (as->fmt_type != fp->fmt_type)
			continue;
		subs = &as->substream[stream];
		if (subs->ep_num)
			continue;
		err = snd_pcm_new_stream(as->pcm, stream, 1);
		if (err < 0)
			return err;
		snd_usb_init_substream(as, stream, fp);
		return add_chmap(as->pcm, stream, subs);
	}
	/* create a new pcm */
	as = kzalloc(sizeof(*as), GFP_KERNEL);
	if (!as)
		return -ENOMEM;
	as->pcm_index = chip->pcm_devs;
	as->chip = chip;
	as->fmt_type = fp->fmt_type;
	err = snd_pcm_new(chip->card, "USB Audio", chip->pcm_devs,
			  stream == SNDRV_PCM_STREAM_PLAYBACK ? 1 : 0,
			  stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1,
			  &pcm);
	if (err < 0) {
		kfree(as);
		return err;
	}
	as->pcm = pcm;
	pcm->private_data = as;
	pcm->private_free = snd_usb_audio_pcm_free;
	pcm->info_flags = 0;
	if (chip->pcm_devs > 0)
		sprintf(pcm->name, "USB Audio #%d", chip->pcm_devs);
	else
		strcpy(pcm->name, "USB Audio");
	snd_usb_init_substream(as, stream, fp);
	/*
	 * Keep using head insertion for M-Audio Audiophile USB (tm) which has a
	 * fix to swap capture stream order in conf/cards/USB-audio.conf
	 */
	if (chip->usb_id == USB_ID(0x0763, 0x2003))
		list_add(&as->list, &chip->pcm_list);
	else
		list_add_tail(&as->list, &chip->pcm_list);
	chip->pcm_devs++;
	snd_usb_proc_pcm_format_add(as);
	return add_chmap(pcm, stream, &as->substream[stream]);
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
check_vendor_extension(u64 paddr,
				   struct set_error_type_with_address *v5param)
{
	int	offset = v5param->vendor_extension;
	struct	vendor_error_type_extension *v;
	u32	sbdf;
	if (!offset)
		return;
	v = acpi_os_map_iomem(paddr + offset, sizeof(*v));
	if (!v)
		return;
	sbdf = v->pcie_sbdf;
	sprintf(vendor_dev, "%x:%x:%x.%x vendor_id=%x device_id=%x rev_id=%x\n",
		sbdf >> 24, (sbdf >> 16) & 0xff,
		(sbdf >> 11) & 0x1f, (sbdf >> 8) & 0x7,
		 v->vendor_id, v->device_id, v->rev_id);
	acpi_os_unmap_iomem(v, sizeof(*v));
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bnx2x_update_sge_prod(struct bnx2x_fastpath *fp,
					 u16 sge_len,
					 struct eth_end_agg_rx_cqe *cqe)
{
	struct bnx2x *bp = fp->bp;
	u16 last_max, last_elem, first_elem;
	u16 delta = 0;
	u16 i;
	if (!sge_len)
		return;
	/* First mark all used pages */
	for (i = 0; i < sge_len; i++)
		BIT_VEC64_CLEAR_BIT(fp->sge_mask,
			RX_SGE(le16_to_cpu(cqe->sgl_or_raw_data.sgl[i])));
	DP(NETIF_MSG_RX_STATUS, "fp_cqe->sgl[%d] = %d\n",
	   sge_len - 1, le16_to_cpu(cqe->sgl_or_raw_data.sgl[sge_len - 1]));
	/* Here we assume that the last SGE index is the biggest */
	prefetch((void *)(fp->sge_mask));
	bnx2x_update_last_max_sge(fp,
		le16_to_cpu(cqe->sgl_or_raw_data.sgl[sge_len - 1]));
	last_max = RX_SGE(fp->last_max_sge);
	last_elem = last_max >> BIT_VEC64_ELEM_SHIFT;
	first_elem = RX_SGE(fp->rx_sge_prod) >> BIT_VEC64_ELEM_SHIFT;
	/* If ring is not full */
	if (last_elem + 1 != first_elem)
		last_elem++;
	/* Now update the prod */
	for (i = first_elem; i != last_elem; i = NEXT_SGE_MASK_ELEM(i)) {
		if (likely(fp->sge_mask[i]))
			break;
		fp->sge_mask[i] = BIT_VEC64_ELEM_ONE_MASK;
		delta += BIT_VEC64_ELEM_SZ;
	}
	if (delta > 0) {
		fp->rx_sge_prod += delta;
		/* clear page-end entries */
		bnx2x_clear_sge_mask_next_elems(fp);
	}
	DP(NETIF_MSG_RX_STATUS,
	   "fp->last_max_sge = %d  fp->rx_sge_prod = %d\n",
	   fp->last_max_sge, fp->rx_sge_prod);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
piix4_get_smb(void)
{
    unsigned long x;
    int result;
    result = pci_conf_read(0, smbdev, smbfun, 0x08, 1, &x);
    if(x < 0x40){   
 			// SB600/700
 			result = pci_conf_read(0, smbdev, smbfun, 0x90, 2, &x);
  		if (result == 0) smbusbase = (unsigned short) x & 0xFFFE;
  	} else {
  		// SB800
			sb800_get_smb();
  	} 	
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
parse_prefix6(struct parse *cfile, struct group *group) {
	struct iaddr lo, hi;
	int bits;
	enum dhcp_token token;
	const char *val;
	struct iaddrcidrnetlist *nets;
	struct iaddrcidrnetlist *p;
	if (local_family != AF_INET6) {
		parse_warn(cfile, "prefix6 statement is only supported "
				  "in DHCPv6 mode.");
		skip_to_semi(cfile);
		return;
	}
	/* This is enforced by the caller, so it's just a sanity check. */
	if (group->subnet == NULL)
		log_fatal("Impossible condition at %s:%d.", MDL);
	/*
	 * Read starting and ending address.
	 */
	if (!parse_ip6_addr(cfile, &lo)) {
		return;
	}
	if (!parse_ip6_addr(cfile, &hi)) {
		return;
	}
	/*
	 * Next is '/' number ';'.
	 */
	token = next_token(NULL, NULL, cfile);
	if (token != SLASH) {
		parse_warn(cfile, "expecting '/'");
		if (token != SEMI)
			skip_to_semi(cfile);
		return;
	}
	token = next_token(&val, NULL, cfile);
	if (token != NUMBER) {
		parse_warn(cfile, "expecting number");
		if (token != SEMI)
			skip_to_semi(cfile);
		return;
	}
	bits = atoi(val);
	if ((bits <= 0) || (bits >= 128)) {
		parse_warn(cfile, "networks have 0 to 128 bits (exclusive)");
		return;
	}
	if (!is_cidr_mask_valid(&lo, bits) ||
	    !is_cidr_mask_valid(&hi, bits)) {
		parse_warn(cfile, "network mask too short");
		return;
	}
	token = next_token(NULL, NULL, cfile);
	if (token != SEMI) {
		parse_warn(cfile, "semicolon expected.");
		skip_to_semi(cfile);
		return;
	}
	/*
	 * Convert our range to a set of CIDR networks.
	 */
	nets = NULL;
	if (range2cidr(&nets, &lo, &hi) != ISC_R_SUCCESS) {
		log_fatal("Error converting prefix to CIDR");
	}
	for (p = nets; p != NULL; p = p->next) {
		/* Normalize and check. */
		if (p->cidrnet.bits == 128) {
			p->cidrnet.bits = bits;
		}
		if (p->cidrnet.bits > bits) {
			parse_warn(cfile, "impossible mask length");
			continue;
		}
		add_ipv6_pool_to_subnet(group->subnet, D6O_IA_PD,
					&p->cidrnet.lo_addr,
					p->cidrnet.bits, bits);
	}
	free_iaddrcidrnetlist(&nets);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Iidlerun (int argc, lvar_t *argv) {
    Tobj mo;
    char *ms;
    int mode;
    if (Tgettype ((mo = argv[0].o)) != T_STRING)
        return L_SUCCESS;
    ms = Tgetstring (mo);
    if (strcmp (ms, "on") == 0)
        mode = 1;
    else if (strcmp (ms, "off") == 0)
        mode = 0;
    else
        return L_FAILURE;
    idlerunmode = mode;
    return L_SUCCESS;
}
CWE-119  False
CWE-120  False
CWE-469  True
CWE-476  False
CWE-other  False
--------------------------
l2tp_tunnel_start(struct l2tp_conn_t *conn,
			     triton_event_func start_func,
			     void *start_param)
{
	if (triton_context_register(&conn->ctx, NULL) < 0) {
		log_error("l2tp: impossible to start new tunnel:"
			  " context registration failed\n");
		goto err;
	}
	triton_md_register_handler(&conn->ctx, &conn->hnd);
	if (triton_md_enable_handler(&conn->hnd, MD_MODE_READ) < 0) {
		log_error("l2tp: impossible to start new tunnel:"
			  " enabling handler failed\n");
		goto err_ctx;
	}
	triton_context_wakeup(&conn->ctx);
	if (triton_timer_add(&conn->ctx, &conn->timeout_timer, 0) < 0) {
		log_error("l2tp: impossible to start new tunnel:"
			  " setting tunnel establishment timer failed\n");
		goto err_ctx_md;
	}
	if (triton_context_call(&conn->ctx, start_func, start_param) < 0) {
		log_error("l2tp: impossible to start new tunnel:"
			  " call to tunnel context failed\n");
		goto err_ctx_md_timer;
	}
	return 0;
err_ctx_md_timer:
	triton_timer_del(&conn->timeout_timer);
err_ctx_md:
	triton_md_unregister_handler(&conn->hnd, 0);
err_ctx:
	triton_context_unregister(&conn->ctx);
err:
	return -1;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
move_repair(piece_info_t *obj)
{
    path_map_t path_map[MAP_SIZE];
    loc_t loc;
    ASSERT (obj->type > FIGHTER);
    if (obj->hits == piece_attr[obj->type].max_hits) {
	obj->func = NOFUNC;
	return;
    }
    if (user_map[obj->loc].contents == 'O') { /* it is in port? */
	obj->moved += 1;
	return;
    }
    loc = vmap_find_wobj (path_map, user_map, obj->loc, &user_ship_repair);
    if (loc == obj->loc) return; /* no reachable city */
    vmap_mark_path (path_map, user_map, loc);
    /* try to be next to ocean to avoid enemy pieces */
    loc = vmap_find_dir (path_map, user_map, obj->loc, ".O", ".");
    if (loc != obj->loc) move_obj (obj, loc);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
dot(const double* v1, unsigned s, const double* v2, unsigned n)
{
  double sum=0.0;
  for (unsigned i=0;i<n;++i,v1+=s) sum+= (*v1)*v2[i];
  return sum;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bfusb_load_firmware(struct bfusb_data *data,
			       const unsigned char *firmware, int count)
{
	unsigned char *buf;
	int err, pipe, len, size, sent = 0;
	BT_DBG("bfusb %p udev %p", data, data->udev);
	BT_INFO("BlueFRITZ! USB loading firmware");
	buf = kmalloc(BFUSB_MAX_BLOCK_SIZE + 3, GFP_KERNEL);
	if (!buf) {
		BT_ERR("Can't allocate memory chunk for firmware");
		return -ENOMEM;
	}
	pipe = usb_sndctrlpipe(data->udev, 0);
	if (usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,
				0, 1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT) < 0) {
		BT_ERR("Can't change to loading configuration");
		kfree(buf);
		return -EBUSY;
	}
	data->udev->toggle[0] = data->udev->toggle[1] = 0;
	pipe = usb_sndbulkpipe(data->udev, data->bulk_out_ep);
	while (count) {
		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE + 3);
		memcpy(buf, firmware + sent, size);
		err = usb_bulk_msg(data->udev, pipe, buf, size,
					&len, BFUSB_BLOCK_TIMEOUT);
		if (err || (len != size)) {
			BT_ERR("Error in firmware loading");
			goto error;
		}
		sent  += size;
		count -= size;
	}
	err = usb_bulk_msg(data->udev, pipe, NULL, 0,
					&len, BFUSB_BLOCK_TIMEOUT);
	if (err < 0) {
		BT_ERR("Error in null packet request");
		goto error;
	}
	pipe = usb_sndctrlpipe(data->udev, 0);
	err = usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,
				0, 2, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);
	if (err < 0) {
		BT_ERR("Can't change to running configuration");
		goto error;
	}
	data->udev->toggle[0] = data->udev->toggle[1] = 0;
	BT_INFO("BlueFRITZ! USB device ready");
	kfree(buf);
	return 0;
error:
	kfree(buf);
	pipe = usb_sndctrlpipe(data->udev, 0);
	usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,
				0, 0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);
	return err;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
load_config(gchar *path)
	{
	FILE			*f;
	PluginConfigRec	*cfg;
	gchar			buf[128+32+2], config[32], arg[128];
	gchar			*s, *plugin_config_block = NULL;
	//g_print("Trying to load config from file '%s'\n", path);
	f = g_fopen(path, "r");
	if (!f)
		return;
	while (fgets(buf, sizeof(buf), f))
		{
		if (!buf[0] || buf[0] == '#')
			continue;
		if (buf[0] == '[' || buf[0] == '<')
			{
			if (buf[1] == '/')
				{
				g_free(plugin_config_block);
				plugin_config_block = NULL;
				}
			else
				{
				if (   (s = strchr(buf, ']')) != NULL
					|| (s = strchr(buf, '>')) != NULL
				   )
					*s = '\0';
				plugin_config_block = g_strdup(&buf[1]);
				}
			continue;
			}
		if (plugin_config_block)
			{
			cfg = g_new0(PluginConfigRec, 1);
			cfg->name = g_strdup(plugin_config_block);
			if ((s = strchr(buf, '\n')) != NULL)
				*s = '\0';
			cfg->line = g_strdup(buf);
			gkrellmd_plugin_config_list
						= g_list_append(gkrellmd_plugin_config_list, cfg);
			}
		else	/* main gkrellmd config line */
			{
			arg[0] = '\0';
			sscanf(buf, "%31s %127s", config, arg);
			parse_config(config, arg);
			}
		}
	fclose(f);
	}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
focus_in_event_ModelessOther(GtkWidget *widget,GdkEvent */*event*/,
	std::pointer_to_unary_function<int, gboolean> *other_function)
{
      XAP_App *pApp=static_cast<XAP_App *>(g_object_get_data(G_OBJECT(widget), "pApp"));
      XAP_Frame *pFrame= pApp->getLastFocussedFrame();
      if(pFrame == static_cast<XAP_Frame *>(NULL)) 
      {
             UT_uint32 nframes =  pApp->getFrameCount();
             if(nframes > 0 && nframes < 10)
	     {     
	            pFrame = pApp->getFrame(0);
	     }
             else
	     {
	            return FALSE;
	      }
      }
      if(pFrame == static_cast<XAP_Frame *>(NULL)) 
	return FALSE;
      AV_View * pView = pFrame->getCurrentView();
      if(pView!= NULL)
      {
            pView->focusChange(AV_FOCUS_MODELESS);
            (*other_function)(0);
      }
      return FALSE;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
page_to_file(int page_num) const
{
   GCriticalSectionLock lock((GCriticalSection *) &class_lock);
   return (page_num<page2file.size())?page2file[page_num]:(GP<DjVmDir::File>(0));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
write_properties_between(uchar *p, int mark, int from, int to)
{   int j, k, prop_number, prop_length;
    /* Note that p is properties_table. */
    for (prop_number=to; prop_number>=from; prop_number--)
    {   for (j=0; j<full_object.l; j++)
        {   if ((full_object.pp[j].num == prop_number)
                && (full_object.pp[j].l != 100))
            {   prop_length = 2*full_object.pp[j].l;
                if (mark+2+prop_length >= MAX_PROP_TABLE_SIZE)
                    memoryerror("MAX_PROP_TABLE_SIZE",MAX_PROP_TABLE_SIZE);
                if (version_number == 3)
                    p[mark++] = prop_number + (prop_length - 1)*32;
                else
                {   switch(prop_length)
                    {   case 1:
                          p[mark++] = prop_number; break;
                        case 2:
                          p[mark++] = prop_number + 0x40; break;
                        default:
                          p[mark++] = prop_number + 0x80;
                          p[mark++] = prop_length + 0x80; break;
                    }
                }
                for (k=0; k<full_object.pp[j].l; k++)
                {   if (full_object.pp[j].ao[k].marker != 0)
                        backpatch_zmachine(full_object.pp[j].ao[k].marker,
                            PROP_ZA, mark);
                    p[mark++] = full_object.pp[j].ao[k].value/256;
                    p[mark++] = full_object.pp[j].ao[k].value%256;
                }
            }
        }
    }
    p[mark++]=0;
    return(mark);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ecryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm,
			    char *cipher_name, size_t *key_size)
{
	char dummy_key[ECRYPTFS_MAX_KEY_BYTES];
	char *full_alg_name = NULL;
	int rc;
	*key_tfm = NULL;
	if (*key_size > ECRYPTFS_MAX_KEY_BYTES) {
		rc = -EINVAL;
		printk(KERN_ERR "Requested key size is [%zd] bytes; maximum "
		      "allowable is [%d]\n", *key_size, ECRYPTFS_MAX_KEY_BYTES);
		goto out;
	}
	rc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name, cipher_name,
						    "ecb");
	if (rc)
		goto out;
	*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(*key_tfm)) {
		rc = PTR_ERR(*key_tfm);
		printk(KERN_ERR "Unable to allocate crypto cipher with name "
		       "[%s]; rc = [%d]\n", full_alg_name, rc);
		goto out;
	}
	crypto_blkcipher_set_flags(*key_tfm, CRYPTO_TFM_REQ_WEAK_KEY);
	if (*key_size == 0) {
		struct blkcipher_alg *alg = crypto_blkcipher_alg(*key_tfm);
		*key_size = alg->max_keysize;
	}
	get_random_bytes(dummy_key, *key_size);
	rc = crypto_blkcipher_setkey(*key_tfm, dummy_key, *key_size);
	if (rc) {
		printk(KERN_ERR "Error attempting to set key of size [%zd] for "
		       "cipher [%s]; rc = [%d]\n", *key_size, full_alg_name,
		       rc);
		rc = -EINVAL;
		goto out;
	}
out:
	kfree(full_alg_name);
	return rc;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
change_definition(const sharedptr<const Field>& fieldOld, const sharedptr<const Field>& field)
{
  BusyCursor busy_cursor(get_app_window());
  //DB field definition:
  sharedptr<Field> result;
  if(!fieldOld || !field)
    return result;
  type_vec_const_fields old_fields;
  type_vec_fields new_fields;
  if(fieldOld->get_primary_key() != field->get_primary_key())
  {
    //Note: We have already checked whether this change of primary key is likely to succeed.
    if(field->get_primary_key())
    {
      //Unset the current primary key:
      //(There should be one.)
      sharedptr<Field> existing_primary_key = get_field_primary_key_for_table(m_table_name);
      if(existing_primary_key)
      {
        sharedptr<Field> existing_primary_key_unset = glom_sharedptr_clone(existing_primary_key);
        existing_primary_key_unset->set_primary_key(false);
	old_fields.push_back(existing_primary_key);
	new_fields.push_back(existing_primary_key_unset);
      }
    }
    //Forget the remembered currently-viewed primary key value, 
    //because it will be useless with a different field as the primary key, or with no field as primary key:
    Document* document = get_document();
    document->forget_layout_record_viewed(m_table_name);
  }
  old_fields.push_back(fieldOld);
  new_fields.push_back(glom_sharedptr_clone(field));
  //TODO: Warn about a delay, and possible loss of precision, before actually
  //changing types or when the backend needs to recreate the whole column or
  //table.
  // TODO: Don't call change_columns if only the field title has changed,
  // since the title is only stored in the document anyway.
  if(change_columns(m_table_name, old_fields, new_fields, get_app_window()))
  {
    result = new_fields.back();
  }
  else
  {
    //Give up. Don't update the document. Hope that we can read the current field properties from the database.
    fill_fields();
    //fill_from_database(); //We should not change the database definition in a cell renderer signal handler.
    //Select the same field again:
    m_AddDel.select_item(field->get_name(), m_colName, false);
    return glom_sharedptr_clone(old_fields.back());
  }
  //Extra Glom field definitions:
  Document* pDoc = static_cast<Document*>(get_document());
  if(pDoc)
  {
    //Get Table's fields:
    Document::type_vec_fields vecFields = pDoc->get_table_fields(m_table_name);
    for(unsigned int i = 0; i < old_fields.size(); ++ i)
    {
      //Find old field:
      const Glib::ustring field_name_old = old_fields[i]->get_name();
      Document::type_vec_fields::iterator iterFind = std::find_if( vecFields.begin(), vecFields.end(), predicate_FieldHasName<Field>(field_name_old) );
      if(iterFind != vecFields.end()) //If it was found:
      {
        //Change it to the new Fields's value:
        *iterFind = glom_sharedptr_clone(new_fields[i]);
      }
      else
      {
        //Add it, because it's not there already:
        vecFields.push_back( glom_sharedptr_clone(new_fields[i]) );
      }
      // TODO_Performance: Can we do this at the end, after the loop? Or do
      // the following operations depend on this?
      pDoc->set_table_fields(m_table_name, vecFields);
      //Update field names where they are used in relationships or on layouts:
      if(field_name_old != new_fields[i]->get_name())
      {
        pDoc->change_field_name(m_table_name, field_name_old, new_fields[i]->get_name());
      }
      // TODO_Performance: Do we even need to do this if only the primary key
      // flag changed, such as for the first entry in the new_fields vector?
      //Recalculate if necessary:
      if(new_fields[i]->get_has_calculation())
      {
        const Glib::ustring calculation = new_fields[i]->get_calculation();
        if(calculation != old_fields[i]->get_calculation())
          calculate_field_in_all_records(m_table_name, new_fields[i]);
      }
    }
  }
  //Update UI:
  fill_fields();
  //fill_from_database(); //We should not change the database definition in a cell renderer signal handler.
  //Select the same field again:
  m_AddDel.select_item(field->get_name(), m_colName, false);
  return result;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
FloodAreaConnections (void)
{
	int		i;
	carea_t	*area;
	int		floodnum;
	// all current floods are now invalid
	floodvalid++;
	floodnum = 0;
	// area 0 is not used
	for (i=1 ; i<numareas ; i++)
	{
		area = &map_areas[i];
		if (area->floodvalid == floodvalid)
			continue;		// already flooded into
		floodnum++;
		FloodArea_r (area, floodnum);
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ixgbe_acquire_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
{
	s32 status;
	status = ixgbe_acquire_swfw_sync_X540(hw, mask);
	if (status)
		return status;
	if (mask & IXGBE_GSSR_I2C_MASK)
		ixgbe_set_mux(hw, 1);
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bna_enet_sm_pause_init_wait(struct bna_enet *enet,
				enum bna_enet_event event)
{
	switch (event) {
	case ENET_E_STOP:
		enet->flags &= ~BNA_ENET_F_PAUSE_CHANGED;
		bfa_fsm_set_state(enet, bna_enet_sm_last_resp_wait);
		break;
	case ENET_E_FAIL:
		enet->flags &= ~BNA_ENET_F_PAUSE_CHANGED;
		bfa_fsm_set_state(enet, bna_enet_sm_stopped);
		break;
	case ENET_E_PAUSE_CFG:
		enet->flags |= BNA_ENET_F_PAUSE_CHANGED;
		break;
	case ENET_E_MTU_CFG:
		/* No-op */
		break;
	case ENET_E_FWRESP_PAUSE:
		if (enet->flags & BNA_ENET_F_PAUSE_CHANGED) {
			enet->flags &= ~BNA_ENET_F_PAUSE_CHANGED;
			bna_bfi_pause_set(enet);
		} else {
			bfa_fsm_set_state(enet, bna_enet_sm_started);
			bna_enet_chld_start(enet);
		}
		break;
	default:
		bfa_sm_fault(event);
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
match_gai_table(struct sockaddr *sa, const struct gai_table *tbl)
{
	struct sockaddr_in *sin = (void *)sa;
	struct sockaddr_in6 *sin6 = (void *)sa;
	void *addr;
	if (sa->sa_family == AF_INET) {
		addr = v4mapped;
		memcpy(v4mapped+12, &sin->sin_addr, NS_INADDRSZ);
	} else
		addr = &sin6->sin6_addr;
	while (1) {
		if (mask_compare(addr, tbl->addr, tbl->mask))
			return tbl->value;
		tbl++;
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cgroup_config_unload_controller(const struct cgroup_mount_point *mount_info)
{
	int ret, error;
	struct cgroup *cgroup = NULL;
	struct cgroup_controller *cgc = NULL;
	char path[FILENAME_MAX];
	void *handle;
	cgroup = cgroup_new_cgroup(".");
	if (cgroup == NULL)
		return ECGFAIL;
	cgc = cgroup_add_controller(cgroup, mount_info->name);
	if (cgc == NULL) {
		ret = ECGFAIL;
		goto out_error;
	}
	ret = cgroup_delete_cgroup_ext(cgroup, CGFLAG_DELETE_RECURSIVE);
	if (ret != 0)
		goto out_error;
	/* unmount everything */
	ret = cgroup_get_subsys_mount_point_begin(mount_info->name, &handle,
			path);
	while (ret == 0) {
		error = umount(path);
		if (error) {
			last_errno = errno;
			ret = ECGOTHER;
			goto out_error;
		}
		ret = cgroup_get_subsys_mount_point_next(&handle, path);
	}
	cgroup_get_subsys_mount_point_end(&handle);
	if (ret == ECGEOF)
		ret = 0;
out_error:
	if (cgroup)
		cgroup_free(&cgroup);
	return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
update_arrival_stats (RTPSession * sess, RTPArrivalStats * arrival,
    gboolean rtp, GstBuffer * buffer, GstClockTime current_time,
    GstClockTime running_time, guint64 ntpnstime)
{
  /* get time of arrival */
  arrival->current_time = current_time;
  arrival->running_time = running_time;
  arrival->ntpnstime = ntpnstime;
  /* get packet size including header overhead */
  arrival->bytes = GST_BUFFER_SIZE (buffer) + sess->header_len;
  if (rtp) {
    arrival->payload_len = gst_rtp_buffer_get_payload_len (buffer);
  } else {
    arrival->payload_len = 0;
  }
  /* for netbuffer we can store the IP address to check for collisions */
  arrival->have_address = GST_IS_NETBUFFER (buffer);
  if (arrival->have_address) {
    GstNetBuffer *netbuf = (GstNetBuffer *) buffer;
    memcpy (&arrival->address, &netbuf->from, sizeof (GstNetAddress));
  }
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
getTracedRays(CSetOfLinesPtr &res) const	{
	if (!meshUpToDate) updateMesh();
	size_t count=0;
	for (size_t i=0;i<validityMatrix.getRowCount();i++) for (size_t j=0;j<validityMatrix.getColCount();j++) if (validityMatrix(i,j)) count++;
	res->reserve(count);
	for (size_t i=0;i<actualMesh.getRowCount();i++) for (size_t j=0;j<actualMesh.getColCount();j++) if (validityMatrix(i,j)) res->appendLine(TPose3D(scanSet[i].sensorPose),actualMesh(i,j));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
enet_protocol_handle_send_unsequenced (ENetHost * host, ENetPeer * peer, const ENetProtocol * command, enet_uint8 ** currentData)
{
    ENetPacket * packet;
    enet_uint32 unsequencedGroup, index;
    size_t dataLength;
    if (command -> header.channelID >= peer -> channelCount ||
        (peer -> state != ENET_PEER_STATE_CONNECTED && peer -> state != ENET_PEER_STATE_DISCONNECT_LATER))
      return -1;
    dataLength = ENET_NET_TO_HOST_16 (command -> sendUnsequenced.dataLength);
    * currentData += dataLength;
    if (* currentData > & host -> receivedData [host -> receivedDataLength])
      return -1; 
    unsequencedGroup = ENET_NET_TO_HOST_16 (command -> sendUnsequenced.unsequencedGroup);
    index = unsequencedGroup % ENET_PEER_UNSEQUENCED_WINDOW_SIZE;
    if (unsequencedGroup < peer -> incomingUnsequencedGroup)
      unsequencedGroup += 0x10000;
    if (unsequencedGroup >= (enet_uint32) peer -> incomingUnsequencedGroup + ENET_PEER_FREE_UNSEQUENCED_WINDOWS * ENET_PEER_UNSEQUENCED_WINDOW_SIZE)
      return 0;
    unsequencedGroup &= 0xFFFF;
    if (unsequencedGroup - index != peer -> incomingUnsequencedGroup)
    {
        peer -> incomingUnsequencedGroup = unsequencedGroup - index;
        memset (peer -> unsequencedWindow, 0, sizeof (peer -> unsequencedWindow));
    }
    else
    if (peer -> unsequencedWindow [index / 32] & (1 << (index % 32)))
      return 0;
    packet = enet_packet_create ((const enet_uint8 *) command + sizeof (ENetProtocolSendUnsequenced),
                                 dataLength,
                                 ENET_PACKET_FLAG_UNSEQUENCED);
    if (packet == NULL ||
        enet_peer_queue_incoming_command (peer, command, packet, 0) == NULL)
      return -1;
    peer -> unsequencedWindow [index / 32] |= 1 << (index % 32);
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
verify_absent_1(struct cache_entry *ce,
				 enum unpack_trees_error_types error_type,
				 struct unpack_trees_options *o)
{
	int len;
	struct stat st;
	if (o->index_only || o->reset || !o->update)
		return 0;
	len = check_leading_path(ce->name, ce_namelen(ce));
	if (!len)
		return 0;
	else if (len > 0) {
		char path[PATH_MAX + 1];
		memcpy(path, ce->name, len);
		path[len] = 0;
		if (lstat(path, &st))
			return error("cannot stat '%s': %s", path,
					strerror(errno));
		return check_ok_to_remove(path, len, DT_UNKNOWN, NULL, &st,
				error_type, o);
	} else if (lstat(ce->name, &st)) {
		if (errno != ENOENT)
			return error("cannot stat '%s': %s", ce->name,
				     strerror(errno));
		return 0;
	} else {
		return check_ok_to_remove(ce->name, ce_namelen(ce),
					  ce_to_dtype(ce), ce, &st,
					  error_type, o);
	}
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
json_print_pwr_wghfreq_stats(struct activity *a, int curr, int tab,
					     unsigned long long itv)
{
	int i, k;
	struct stats_pwr_wghfreq *spc, *spp, *spc_k, *spp_k;
	unsigned long long tis, tisfreq;
	int sep = FALSE;
	char cpuno[8];
	if (!IS_SELECTED(a->options) || (a->nr <= 0))
		goto close_json_markup;
	json_markup_power_management(tab, OPEN_JSON_MARKUP);
	tab++;
	xprintf(tab++, "\"cpu-weighted-frequency\": [");
	for (i = 0; (i < a->nr) && (i < a->bitmap->b_size + 1); i++) {
		spc = (struct stats_pwr_wghfreq *) ((char *) a->buf[curr]  + i * a->msize * a->nr2);
		spp = (struct stats_pwr_wghfreq *) ((char *) a->buf[!curr] + i * a->msize * a->nr2);
		/* Should current CPU (including CPU "all") be displayed? */
		if (a->bitmap->b_array[i >> 3] & (1 << (i & 0x07))) {
			/* Yes... */
			tisfreq = 0;
			tis = 0;
			for (k = 0; k < a->nr2; k++) {
				spc_k = (struct stats_pwr_wghfreq *) ((char *) spc + k * a->msize);
				if (!spc_k->freq)
					break;
				spp_k = (struct stats_pwr_wghfreq *) ((char *) spp + k * a->msize);
				tisfreq += (spc_k->freq / 1000) *
				           (spc_k->time_in_state - spp_k->time_in_state);
				tis     += (spc_k->time_in_state - spp_k->time_in_state);
			}
			if (!i) {
				/* This is CPU "all" */
				strcpy(cpuno, "all");
			}
			else {
				sprintf(cpuno, "%d", i - 1);
			}
			if (sep) {
				printf(",\n");
			}
			sep = TRUE;
			xprintf0(tab, "{\"number\": \"%s\", "
				 "\"weighted-frequency\": %.2f}",
				 cpuno,
				 tis ? ((double) tisfreq) / tis : 0.0);
		}
	}
	printf("\n");
	xprintf0(--tab, "]");
	tab--;
close_json_markup:
	if (CLOSE_MARKUP(a->options)) {
		json_markup_power_management(tab, CLOSE_JSON_MARKUP);
	}
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
test_partial_ipv4_tcp_msg(void)
{
	int sk, received = 0;
	sk = connect_tcp_socket("127.0.0.1");
	g_assert_cmpint(sk, >=, 0);
	change_msg(msg, 2, 20, '1');
	send_msg(sk, msg, sizeof(msg), 1);
	received = receive_message(sk, 10, sizeof(msg), NULL);
	close(sk);
	g_assert_cmpint(received, >=, sizeof(msg));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gameFinished() {
	QSettings settings;
	int count = settings.value("Current/Count").toInt();
	int length = settings.value("Current/Length").toInt();
	int msecs = settings.value("Current/Time").toInt();
	m_clock->stop();
	m_clock->setDisabled(true);
	m_pause_action->setDisabled(true);
	m_success->show();
	m_scores->addScore(qRound(msecs / 1000.0), count, length);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
bnxt_free_stats(struct bnxt *bp)
{
	u32 size, i;
	struct pci_dev *pdev = bp->pdev;
	if (!bp->bnapi)
		return;
	size = sizeof(struct ctx_hw_stats);
	for (i = 0; i < bp->cp_nr_rings; i++) {
		struct bnxt_napi *bnapi = bp->bnapi[i];
		struct bnxt_cp_ring_info *cpr = &bnapi->cp_ring;
		if (cpr->hw_stats) {
			dma_free_coherent(&pdev->dev, size, cpr->hw_stats,
					  cpr->hw_stats_map);
			cpr->hw_stats = NULL;
		}
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
allocateCandidatesAndFindBasisForAdd(
    Value *LHS, Value *RHS, Instruction *I) {
  Value *S = nullptr;
  ConstantInt *Idx = nullptr;
  if (match(RHS, m_Mul(m_Value(S), m_ConstantInt(Idx)))) {
    // I = LHS + RHS = LHS + Idx * S
    allocateCandidatesAndFindBasis(Candidate::Add, SE->getSCEV(LHS), Idx, S, I);
  } else if (match(RHS, m_Shl(m_Value(S), m_ConstantInt(Idx)))) {
    // I = LHS + RHS = LHS + (S << Idx) = LHS + S * (1 << Idx)
    APInt One(Idx->getBitWidth(), 1);
    Idx = ConstantInt::get(Idx->getContext(), One << Idx->getValue());
    allocateCandidatesAndFindBasis(Candidate::Add, SE->getSCEV(LHS), Idx, S, I);
  } else {
    // At least, I = LHS + 1 * RHS
    ConstantInt *One = ConstantInt::get(cast<IntegerType>(I->getType()), 1);
    allocateCandidatesAndFindBasis(Candidate::Add, SE->getSCEV(LHS), One, RHS,
                                   I);
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cd_device_set_enabled (CdDevice *device,
		       gboolean enabled,
		       GError **error)
{
	CdDevicePrivate *priv = device->priv;
	gboolean ret;
	GError *error_local = NULL;
	/* device is already the correct state */
	if (priv->enabled == enabled) {
		ret = TRUE;
		goto out;
	}
	/* update database */
	ret = cd_device_db_set_property (device->priv->device_db,
					 device->priv->id,
					 "Enabled",
					 enabled ? "True" : "False",
					 &error_local);
	if (!ret) {
		g_set_error (error,
			     CD_DEVICE_ERROR,
			     CD_DEVICE_ERROR_INTERNAL,
			     "%s", error_local->message);
		g_error_free (error_local);
		goto out;
	}
	/* change property */
	priv->enabled = enabled;
	/* reset modification time */
	cd_device_reset_modified (device);
	/* emit */
	cd_device_dbus_emit_property_changed (device,
					      "Enabled",
					      g_variant_new_boolean (enabled));
	/* emit global signal */
	cd_device_dbus_emit_device_changed (device);
out:
	return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
new_g15_screen(int screentype)
{
    struct sigaction new_sigaction;
    int g15screen_fd;
    struct sockaddr_in serv_addr;
    static int sighandler_init=0;
    /* raise the priority of our packets */
    int tos = 0x6;
    char buffer[256];
    if(sighandler_init==0) {
#ifdef HAVE_BACKTRACE
      new_sigaction.sa_handler = g15_sighandler;
      new_sigaction.sa_flags = 0;
      sigaction(SIGSEGV,&new_sigaction,NULL);
#endif      
      sighandler_init=1;
    }
    g15screen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (g15screen_fd < 0) 
        return -1;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family      = AF_INET;
    inet_aton (G15SERVER_ADDR, &serv_addr.sin_addr);
    serv_addr.sin_port        = htons(G15SERVER_PORT);
    if (connect(g15screen_fd,(struct sockaddr *)&serv_addr,sizeof(serv_addr)) < 0) 
        return -1;
    setsockopt(g15screen_fd, SOL_SOCKET, SO_PRIORITY, &tos, sizeof(tos));
    if (fcntl(g15screen_fd, F_SETFL, O_NONBLOCK) <0 ) {
    }
    memset(buffer,0,256);
    if(g15_recv(g15screen_fd, buffer, 16)<0)
        return -1;
    /* here we check that we're really talking to the g15daemon */
    if(strcmp(buffer,"G15 daemon HELLO") != 0)
        return -1;
    if(screentype == G15_TEXTBUF) /* txt buffer - not supported yet */
        g15_send(g15screen_fd,"TBUF",4);
    else if(screentype == G15_WBMPBUF) /* wbmp buffer */
        g15_send(g15screen_fd,"WBUF",4);
    else if(screentype == G15_G15RBUF)
        g15_send(g15screen_fd,"RBUF",4);
    else 
        g15_send(g15screen_fd,"GBUF",4);
    return g15screen_fd;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ajp_msg_append_string_ex(ajp_msg_t *msg, const char *value,
                                      int convert)
{
    apr_size_t len;
    if (value == NULL) {
        return(ajp_msg_append_uint16(msg, 0xFFFF));
    }
    len = strlen(value);
    if ((msg->len + len + 3) > msg->max_size) {
        return ajp_log_overflow(msg, "ajp_msg_append_cvt_string");
    }
    /* ignore error - we checked once */
    ajp_msg_append_uint16(msg, (apr_uint16_t)len);
    /* We checked for space !!  */
    memcpy(msg->buf + msg->len, value, len + 1); /* including \0 */
    if (convert) {
        /* convert from EBCDIC if needed */
        ap_xlate_proto_to_ascii((char *)msg->buf + msg->len, len + 1);
    }
    msg->len += len + 1;
    return APR_SUCCESS;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
msg_puts_long_len_attr(longstr, len, attr)
    char_u	*longstr;
    int		len;
    int		attr;
{
    int		slen = len;
    int		room;
    room = Columns - msg_col;
    if (len > room && room >= 20)
    {
	slen = (room - 3) / 2;
	msg_outtrans_len_attr(longstr, slen, attr);
	msg_puts_attr((char_u *)"...", hl_attr(HLF_8));
    }
    msg_outtrans_len_attr(longstr + len - slen, slen, attr);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
is_equal(const ExecutionPath *e) const
    {
        const UninitVar *c = static_cast<const UninitVar *>(e);
        return (varname == c->varname && pointer == c->pointer && array == c->array && alloc == c->alloc && strncpy_ == c->strncpy_);
    }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
mul_under_dim_size(Array_table *atbl, const int udim)
{
    int i;
    SemTree *ret = make_semtree_const_int(1);
    for (i = 0; i < udim; i++) {
        SemTree *dim_size;
        dim_size = get_array_table_dim_size(atbl, i);
        ret = concat_semtree(OPE_MUL, ret, dim_size);
    }
    semtree_process(ret);
    return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
string_sequence_new (gchar **strings)
{
    GSequence *sequence;
    sequence = g_sequence_new(g_free);
    for (; *strings; strings++) {
        g_sequence_append(sequence, g_strdup(*strings));
    }
    return sequence;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ufs2_update_inode(struct inode *inode, struct ufs2_inode *ufs_inode)
{
	struct super_block *sb = inode->i_sb;
 	struct ufs_inode_info *ufsi = UFS_I(inode);
	UFSD("ENTER\n");
	ufs_inode->ui_mode = cpu_to_fs16(sb, inode->i_mode);
	ufs_inode->ui_nlink = cpu_to_fs16(sb, inode->i_nlink);
	ufs_inode->ui_uid = cpu_to_fs32(sb, i_uid_read(inode));
	ufs_inode->ui_gid = cpu_to_fs32(sb, i_gid_read(inode));
	ufs_inode->ui_size = cpu_to_fs64(sb, inode->i_size);
	ufs_inode->ui_atime = cpu_to_fs64(sb, inode->i_atime.tv_sec);
	ufs_inode->ui_atimensec = cpu_to_fs32(sb, inode->i_atime.tv_nsec);
	ufs_inode->ui_ctime = cpu_to_fs64(sb, inode->i_ctime.tv_sec);
	ufs_inode->ui_ctimensec = cpu_to_fs32(sb, inode->i_ctime.tv_nsec);
	ufs_inode->ui_mtime = cpu_to_fs64(sb, inode->i_mtime.tv_sec);
	ufs_inode->ui_mtimensec = cpu_to_fs32(sb, inode->i_mtime.tv_nsec);
	ufs_inode->ui_blocks = cpu_to_fs64(sb, inode->i_blocks);
	ufs_inode->ui_flags = cpu_to_fs32(sb, ufsi->i_flags);
	ufs_inode->ui_gen = cpu_to_fs32(sb, inode->i_generation);
	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
		/* ufs_inode->ui_u2.ui_addr.ui_db[0] = cpu_to_fs32(sb, inode->i_rdev); */
		ufs_inode->ui_u2.ui_addr.ui_db[0] = ufsi->i_u1.u2_i_data[0];
	} else if (inode->i_blocks) {
		memcpy(&ufs_inode->ui_u2.ui_addr, ufsi->i_u1.u2_i_data,
		       sizeof(ufs_inode->ui_u2.ui_addr));
	} else {
		memcpy(&ufs_inode->ui_u2.ui_symlink, ufsi->i_u1.i_symlink,
		       sizeof(ufs_inode->ui_u2.ui_symlink));
 	}
	if (!inode->i_nlink)
		memset (ufs_inode, 0, sizeof(struct ufs2_inode));
	UFSD("EXIT\n");
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
OnHash(const unsigned char *srcmac,
			   const unsigned char *dstmac, struct evbuffer *evb) {
    if (evbuffer_get_length(evb) < 4 + Sha1Hash::SIZE) {
	eprintf("%s #%u incorrect size in eth has\n", tintstr(), my_channel);
	return;
    }
    bin_t range = bin_fromUInt32(evbuffer_remove_32be(evb));
    rec_ranges.set(range);
    Sha1Hash hash = evbuffer_remove_hash(evb);
    transfer->file().OfferHash(range, hash);
    char bin_name_buf[32];
    dprintf("%s #%u -hash %s\n",tintstr(),my_channel,range.str(bin_name_buf));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ListExpr2 (
    Obj                 list,
    Expr                expr )
{
    Obj                 sub;            /* value of a subexpression        */
    Int                 len;            /* logical length of the list      */
    Int                 i;              /* loop variable                   */
    Int                 posshole;       /* initially 0, set to 1 at
                                           first empty position, then
                                           next full position causes
                                           the list to be made
                                           non-dense */
    /* get the length of the list                                          */
    len = SIZE_EXPR(expr) / sizeof(Expr);
    /* initially we have not seen a hole                                   */
    posshole = 0;
    /* handle the subexpressions                                           */
    for ( i = 1; i <= len; i++ ) {
        /* if the subexpression is empty                                   */
        if ( ADDR_EXPR(expr)[i-1] == 0 ) {
          if (!posshole)
            posshole = 1;
          continue;
        }
        else 
          {
            if (posshole == 1)
              {
                SET_FILT_LIST(list, FN_IS_NDENSE);
                posshole = 2;
              }
            /* special case if subexpression is a list expression              */
            if ( TNUM_EXPR( ADDR_EXPR(expr)[i-1] ) == T_LIST_EXPR ) {
              sub = ListExpr1( ADDR_EXPR(expr)[i-1] );
              SET_ELM_PLIST( list, i, sub );
              CHANGED_BAG( list );
              ListExpr2( sub, ADDR_EXPR(expr)[i-1] );
            }
            /* special case if subexpression is a record expression            */
            else if ( TNUM_EXPR( ADDR_EXPR(expr)[i-1] ) == T_REC_EXPR ) {
              sub = RecExpr1( ADDR_EXPR(expr)[i-1] );
              SET_ELM_PLIST( list, i, sub );
              CHANGED_BAG( list );
              RecExpr2( sub, ADDR_EXPR(expr)[i-1] );
            }
            /* general case                                                    */
            else {
              sub = EVAL_EXPR( ADDR_EXPR(expr)[i-1] );
              SET_ELM_PLIST( list, i, sub );
              CHANGED_BAG( list );
            }
          }
    }
    if (!posshole)
      SET_FILT_LIST(list, FN_IS_DENSE);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
jt1_i(void)
{
	UINT8 adr = ROP_ARG(PC);
	PC += 1;
	if( !(ENABLE & CNT) )
	{
		UINT8 level = RP(I8X41_t1);
		if( level ) CONTROL |= TEST1;
		else CONTROL &= ~TEST1;
	}
	if( (CONTROL & TEST1) )
		PC = (PC & 0x700) | adr;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
instance_reduce(object instance_obj)
  {
      list result;
      object instance_class(instance_obj.attr("__class__"));
      result.append(instance_class);
      object none;
      if (!getattr(instance_obj, "__safe_for_unpickling__", none))
      {
          str type_name(getattr(instance_class, "__name__"));
          str module_name(getattr(instance_class, "__module__", object("")));
          if (module_name)
              module_name += ".";
          PyErr_SetObject(
               PyExc_RuntimeError,
               ( "Pickling of \"%s\" instances is not enabled"
                 " (http://www.boost.org/libs/python/doc/v2/pickle.html)"
                  % (module_name+type_name)).ptr()
          );
          throw_error_already_set();
      }
      object getinitargs = getattr(instance_obj, "__getinitargs__", none);
      tuple initargs;
      if (!getinitargs.is_none()) {
          initargs = tuple(getinitargs());
      }
      result.append(initargs);
      object getstate = getattr(instance_obj, "__getstate__", none);
      object instance_dict = getattr(instance_obj, "__dict__", none);
      long len_instance_dict = 0;
      if (!instance_dict.is_none()) {
          len_instance_dict = len(instance_dict);
      }
      if (!getstate.is_none()) {
          if (len_instance_dict > 0) {
              object getstate_manages_dict = getattr(
                instance_obj, "__getstate_manages_dict__", none);
              if (getstate_manages_dict.is_none()) {
                  PyErr_SetString(PyExc_RuntimeError,
                    "Incomplete pickle support"
                    " (__getstate_manages_dict__ not set)");
                  throw_error_already_set();
              }
          }
          result.append(getstate());
      }
      else if (len_instance_dict > 0) {
          result.append(instance_dict);
      }
      return tuple(result);
  }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
get_device(int number, char *device, int device_len) {
	FILE *proc_file;
	char *current_device;
	char *lineptr = NULL;
	char *saveptr = NULL;
	size_t bufflen;
	int i, count, counter;
	int return_value = 0;
	proc_file = fopen("/proc/sys/dev/cdrom/info", "r");
	if (proc_file != NULL) {
		/* skip to line containing device names */
		do {
			if (getline(&lineptr, &bufflen, proc_file) < 0) {
				return 0;
			}
		} while (strstr(lineptr, "drive name:") == NULL);
		/* count number of devices = number of tabs - 1*/
		count = -1;
		for (i = 0; i < strlen(lineptr); i++) {
			if (lineptr[i] == '\t') count++;
		}
		/* go through devices, they are in reverse order */
		current_device = strtok_r(lineptr, "\t", &saveptr);
		/* skip column title */
		current_device = strtok_r(NULL, "\t", &saveptr);
		counter = count;
		while (current_device != NULL && counter >= number) {
			if (counter == number) {
				snprintf(device, device_len,
					 "/dev/%s", current_device);
				return_value = 1;
			}
			/* go to next in list */
			current_device = strtok_r(NULL, "\t", &saveptr);
			counter--;
		}
		/* trim the trailing \n for the last entry = first device */
		if (default_device[strlen(default_device)-1] == '\n') {
			default_device[strlen(default_device)-1] = '\0';
		}
		free(lineptr);
		fclose(proc_file);
	}
	return return_value;
}
CWE-119  False
CWE-120  False
CWE-469  True
CWE-476  False
CWE-other  False
--------------------------
uwb_rsv_handle_timeout_work(struct work_struct *work)
{
	struct uwb_rsv *rsv = container_of(work, struct uwb_rsv,
					   handle_timeout_work);
	struct uwb_rc *rc = rsv->rc;
	mutex_lock(&rc->rsvs_mutex);
	uwb_rsv_dump("TO", rsv);
	switch (rsv->state) {
	case UWB_RSV_STATE_O_INITIATED:
		if (rsv->is_multicast) {
			uwb_rsv_set_state(rsv, UWB_RSV_STATE_O_ESTABLISHED);
			goto unlock;
		}
		break;
	case UWB_RSV_STATE_O_MOVE_EXPANDING:
		if (rsv->is_multicast) {
			uwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MOVE_COMBINING);
			goto unlock;
		}
		break;
	case UWB_RSV_STATE_O_MOVE_COMBINING:
		if (rsv->is_multicast) {
			uwb_rsv_set_state(rsv, UWB_RSV_STATE_O_MOVE_REDUCING);
			goto unlock;
		}
		break;
	case UWB_RSV_STATE_O_MOVE_REDUCING:
		if (rsv->is_multicast) {
			uwb_rsv_set_state(rsv, UWB_RSV_STATE_O_ESTABLISHED);
			goto unlock;
		}
		break;
	case UWB_RSV_STATE_O_ESTABLISHED:
		if (rsv->is_multicast)
			goto unlock;
		break;
	case UWB_RSV_STATE_T_EXPANDING_ACCEPTED:
		/*
		 * The time out could be for the main or of the
		 * companion DRP, assume it's for the companion and
		 * drop that first.  A further time out is required to
		 * drop the main.
		 */
		uwb_rsv_set_state(rsv, UWB_RSV_STATE_T_ACCEPTED);
		uwb_drp_avail_release(rsv->rc, &rsv->mv.companion_mas);
		goto unlock;
	case UWB_RSV_STATE_NONE:
		goto unlock;
	default:
		break;
	}
	uwb_rsv_remove(rsv);
unlock:
	mutex_unlock(&rc->rsvs_mutex);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
OpUnmap()
{
  pmd_unmap_it in ;
  pmd_unmap_ot out ;
  if (!readn(newsock, (char *)&in, sizeof( pmd_unmap_it)))
     return ;                   /* read input for operation */
  if (ntohl(in.pid) > 0)        /* remove all entries for pid */
     out.count = unmapPid(ntohl(in.pid)) ;
  else                          /* remove entry for mapid */
     out.count = unmapMapid(in.mapid, ntohs(in.protocol)) ;
  if (out.count > 0)
   {
      out.status = htons(SUCCESS) ;
      out.error = htons(PMD_ER_NOERROR) ;
   }
  else
   {
      out.status = htons(FAILURE) ;
      out.error = htons(PMD_ER_NOENTRY) ;
   }
                                /* return the # of entries unmapped */
  out.count = htons(out.count) ;
  writen(newsock, (char *)&out, sizeof(pmd_unmap_ot)) ;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
parse_menuitem(char *buff, void *state)
{
    static menu_t *menu;
    menuitem_t *curitem;
    ASSERT_RVAL(state != NULL, (void *) (file_skip_to_end(), NULL));
    if (*buff == SPIFCONF_BEGIN_CHAR) {
        menu = (menu_t *) state;
        curitem = menuitem_create(NULL);
        return ((void *) curitem);
    }
    curitem = (menuitem_t *) state;
    ASSERT_RVAL(menu != NULL, state);
    if (*buff == SPIFCONF_END_CHAR) {
        if (!(curitem->text)) {
            libast_print_error("Parse error in file %s, line %lu:  Menuitem context ended with no text given.  Discarding this entry.\n",
                        file_peek_path(), file_peek_line());
            FREE(curitem);
        } else {
            menu_add_item(menu, curitem);
        }
        return ((void *) menu);
    }
    if (!BEG_STRCASECMP(buff, "text ")) {
        char *text = spiftool_get_word(2, buff);
        if (!text) {
            libast_print_error("Parse error in file %s, line %lu:  Missing menuitem text.\n", file_peek_path(), file_peek_line());
            return ((void *) curitem);
        }
        menuitem_set_text(curitem, text);
        FREE(text);
    } else if (!BEG_STRCASECMP(buff, "rtext ")) {
        char *rtext = spiftool_get_word(2, buff);
        if (!rtext) {
            libast_print_error("Parse error in file %s, line %lu:  Missing menuitem right-justified text.\n", file_peek_path(),
                        file_peek_line());
            return ((void *) curitem);
        }
        menuitem_set_rtext(curitem, rtext);
        FREE(rtext);
    } else if (!BEG_STRCASECMP(buff, "icon ")) {
    } else if (!BEG_STRCASECMP(buff, "action ")) {
        char *type = spiftool_get_pword(2, buff);
        char *action = spiftool_get_word(3, buff);
        if (!BEG_STRCASECMP(type, "submenu ")) {
            menuitem_set_action(curitem, MENUITEM_SUBMENU, action);
        } else if (!BEG_STRCASECMP(type, "string ")) {
            menuitem_set_action(curitem, MENUITEM_STRING, action);
        } else if (!BEG_STRCASECMP(type, "script ")) {
            menuitem_set_action(curitem, MENUITEM_SCRIPT, action);
        } else if (!BEG_STRCASECMP(type, "echo ")) {
            menuitem_set_action(curitem, MENUITEM_ECHO, action);
        } else if (!BEG_STRCASECMP(type, "separator")) {
            menuitem_set_action(curitem, MENUITEM_SEP, action);
        } else {
            libast_print_error("Parse error in file %s, line %lu:  Invalid menu item action \"%s\"\n", file_peek_path(), file_peek_line(),
                        NONULL(type));
        }
        FREE(action);
    } else {
        libast_print_error("Parse error in file %s, line %lu:  Attribute \"%s\" is not valid within context menu\n", file_peek_path(),
                    file_peek_line(), buff);
    }
    return ((void *) curitem);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
sendResults(IDB_HANDLE ** handle, FIS_HANDLE ** fisHandle,
	    DMAN_HANDLE ** dmanHandle, const char *accessionNumber,
	    const char *studyInstanceUID,
	    char *requestingAETitle, char *remoteAETitle)
{
    FIS_STUDYRECORD study;
    FIS_RESULTSRECORD results;
    CONDITION cond = 0;
    FIS_INTERPRETATIONRECORD *interp;
    memset(&study, 0, sizeof study);
    study.Type = FIS_K_STUDY;
    findStudy(handle, fisHandle, accessionNumber, studyInstanceUID, &study);
    FIS_DumpRecord(&study, stdout);
    findResults(fisHandle, study.StuInsUID, &results);
    FIS_DumpRecord(&results, stdout);
    cond = FIS_SendEvent(fisHandle, dmanHandle, FIS_K_RESULTS, &results,
		   FIS_K_RESULTS_CREATED, requestingAETitle, remoteAETitle);
    if (cond != FIS_NORMAL) {
	COND_DumpConditions();
	THR_Shutdown();
	exit(1);
    }
    interp = LST_Head(&results.InterpretationList);
    LST_Position(&results.InterpretationList, interp);
    while (interp != NULL) {
	FIS_DumpRecord(interp, stdout);
	cond = FIS_SendEvent(fisHandle, dmanHandle, FIS_K_INTERPRETATION, interp,
	    FIS_K_INTERPRETATION_CREATED, requestingAETitle, remoteAETitle);
	if (cond != FIS_NORMAL) {
	    COND_DumpConditions();
	    THR_Shutdown();
	    exit(1);
	}
	cond = FIS_SendEvent(fisHandle, dmanHandle, FIS_K_INTERPRETATION, interp,
	   FIS_K_INTERPRETATION_APPROVED, requestingAETitle, remoteAETitle);
	if (cond != FIS_NORMAL) {
	    COND_DumpConditions();
	    THR_Shutdown();
	    exit(1);
	}
	interp = LST_Next(&results.InterpretationList);
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
unknownFieldMsg(emf_ObjectData_X* object_data, bool is_fatal)
{
  UserInterface* gui = theControlCenter->getGui();
  strstream strm;
  if ( is_fatal ) {
    strm << "***ERROR: Unknown field name (";
  } else {
    strm << "***WARNING: Unknown field name (";
  }
  strm << object_data->field_name
       << ") when reading object: "
       << object_data->object_name;
  if ( object_data->object_id != NO_INDEX ) {
    strm << " " << object_data->object_id;
  }
  strm << ends;
  gui->showMsg(strm.str());
  if (is_fatal)
    return notOk;
  else
    return isOk;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
table_share_hash_get_key(const uchar *entry, size_t *length,
                                       my_bool)
{
  const PFS_table_share * const *typed_entry;
  const PFS_table_share *share;
  const void *result;
  typed_entry= reinterpret_cast<const PFS_table_share* const *> (entry);
  DBUG_ASSERT(typed_entry != NULL);
  share= *typed_entry;
  DBUG_ASSERT(share != NULL);
  *length= share->m_key.m_key_length;
  result= &share->m_key.m_hash_key[0];
  return const_cast<uchar*> (reinterpret_cast<const uchar*> (result));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ircd_running (void)
{
  int pid;
  if (file_exists(IRCDPID_PATH)) {
    pid = read_pid(IRCDPID_PATH);
    if (pid > 0) {
      return(verify_pid(pid) == 1);
    } else {
      return(-1);
    }
  }
  return(0);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
pf_key_v2_register_sa_seq(u_int8_t *spi, size_t sz, u_int8_t proto,
    struct sockaddr *dst, int dstlen, u_int32_t seq)
{
	struct pf_key_v2_sa_seq *node = 0;
	node = malloc(sizeof *node);
	if (!node)
		goto cleanup;
	memset(node, '0', sizeof *node);
	node->spi = malloc(sz);
	if (!node->spi)
		goto cleanup;
	node->dst = malloc(sysdep_sa_len(dst));
	if (!node->dst)
		goto cleanup;
	memcpy(node->dst, dst, sysdep_sa_len(dst));
	node->dstlen = sysdep_sa_len(dst);
	memcpy(node->spi, spi, sz);
	node->sz = sz;
	node->proto = proto;
	node->seq = seq;
	TAILQ_INSERT_TAIL(&pf_key_v2_sa_seq_map, node, link);
	return 1;
cleanup:
	if (node->dst)
		free(node->dst);
	if (node)
		free(node);
	return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
denali_irq_init(struct denali_nand_info *denali)
{
	uint32_t int_mask;
	int i;
	/* Disable global interrupts */
	denali_set_intr_modes(denali, false);
	int_mask = DENALI_IRQ_ALL;
	/* Clear all status bits */
	for (i = 0; i < denali->max_banks; ++i)
		iowrite32(0xFFFF, denali->flash_reg + INTR_STATUS(i));
	denali_irq_enable(denali, int_mask);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
command_pause (int unitnum, int paused)
{
	struct cdunit *cdu = unitisopen (unitnum);
	if (!cdu)
		return -1;
	int old = cdu->cdda_paused;
	cdu->cdda_paused = paused;
	return old;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
SetConfigDefaults(int bSet)
{
   int i;
   void *var_ptr = NULL;
   for(i = 0; ConfigVars[i].var_name[0] != 0; i++) {
      if(strcmp(ConfigVars[i].var_type,"%s") == 0) {
         if(ConfigVars[i].Flags & CON_FLG_BASED_VAR) {
            if(ConfigPass == 0) {
            // Prior to first pass, class variables haven't been created yet
               continue;
            }
         }
         else {
            var_ptr = ConfigVars[i].var_ptr;
         }
         if(*((char **) var_ptr) != NULL)
         {
            free(*((char **) var_ptr));
            *((char **) var_ptr) = NULL;
         }
      }
      else if(strcmp(ConfigVars[i].var_type,"%F") == 0) {
         if(!(ConfigVars[i].Flags & CON_FLG_BASED_VAR)) {
            ConfigVars[i].AccessFunc(&ConfigVars[i],NULL,AF_SET_DEFAULT,0);
         }
      }
   }
   if(bSet) {
      ConferenceID = strdup(PACKAGE " V " VERSION);
      DirServerHost[0] = strdup("server1.echolink.org");
      AppName = strdup("tlb");
      RunDir = strdup("/var/run/");
   }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
ptaGetLinearLSF(PTA        *pta,
                l_float32  *pa,
                l_float32  *pb,
                NUMA      **pnafit)
{
l_int32     n, i;
l_float32   factor, sx, sy, sxx, sxy, val;
l_float32  *xa, *ya;
    PROCNAME("ptaGetLinearLSF");
    if (!pta)
        return ERROR_INT("pta not defined", procName, 1);
    if (!pa && !pb)
        return ERROR_INT("&a and/or &b not defined", procName, 1);
    if (pa) *pa = 0.0;
    if (pb) *pb = 0.0;
    if ((n = ptaGetCount(pta)) < 2)
        return ERROR_INT("less than 2 pts not found", procName, 1);
    xa = pta->x;  /* not a copy */
    ya = pta->y;  /* not a copy */
    sx = sy = sxx = sxy = 0.;
    if (pa && pb) {
        for (i = 0; i < n; i++) {
            sx += xa[i];
            sy += ya[i];
            sxx += xa[i] * xa[i];
            sxy += xa[i] * ya[i];
        }
        factor = n * sxx - sx * sx;
        if (factor == 0.0)
            return ERROR_INT("no solution found", procName, 1);
        factor = 1. / factor;
        *pa = factor * ((l_float32)n * sxy - sx * sy);
        *pb = factor * (sxx * sy - sx * sxy);
    }
    else if (pa) {  /* line through origin */
        for (i = 0; i < n; i++) {
            sxx += xa[i] * xa[i];
            sxy += xa[i] * ya[i];
        }
        if (sxx == 0.0)
            return ERROR_INT("no solution found", procName, 1);
        *pa = sxy / sxx;
    }
    else {  /* a = 0; horizontal line */
        for (i = 0; i < n; i++)
            sy += ya[i];
        *pb = sy / (l_float32)n;
    }
    if (pnafit) {
        *pnafit = numaCreate(n);
        for (i = 0; i < n; i++) {
            val = (*pa) * xa[i] + *pb;
            numaAddNumber(*pnafit, val);
        }
    }
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
vlog_msgf(int fd, int lf, const char* fmt, va_list ap, int with_errno)
{
    int level = LOG_PRI(lf);
    char buf[1024];
    if (level_ < level)
    {
        return 0;
    }
    if (fd > -1)
    {
        if (dprintf(fd, "%s;", flty_[level]) < 0)
        {
            return -1;
        }
        if (vdprintf(fd, fmt, ap) < 0)
        {
            return -1;
        }
        if (with_errno)
        {
            if (dprintf(fd, " (%s)", strerror(errno)) < 0)
            {
                return -1;
            }
        }
        if (dprintf(fd, "\n") < 0)
        {
            return -1;
        }
    }
    else
    {
        if (vsnprintf(buf, sizeof(buf), fmt, ap) < 0)
        {
            return -1;
        }
        syslog(level | LOG_DAEMON, "%s", buf);
    }
    return 0;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
operator=(const Theorem& th) {
    // Handle self-assignment
    if(this == &th) return *this;
    if(d_thm == th.d_thm) return *this;
    long tmp = th.d_thm;
    // Increase the refcount on th
    if (tmp & 0x1) {
      TheoremValue* tv = (TheoremValue*) (tmp & (~(0x1)));
      DebugAssert(tv->d_refcount > 0,
                  "Theorem::operator=: invariant violated");
      ++(tv->d_refcount);
    }
    else if (tmp != 0) {
      th.exprValue()->incRefcount();
    }
    // Decrease the refcount on this
    if (d_thm & 0x1) {
      TheoremValue* tv = thm();
      DebugAssert(tv->d_refcount > 0,
                  "Theorem::operator=: invariant violated");
      if(--(tv->d_refcount) == 0) {
        MemoryManager* mm = tv->getMM();
        delete tv;
        mm->deleteData(tv);
      }
    }
    else if (d_thm != 0) {
      exprValue()->decRefcount();
    }
    d_thm = tmp;
    return *this;
  }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
DateCalc_Blank(charptr *target, Z_int count)
{
    while (count-- > 0) *(*target)++ = ' ';
    *(*target) = '\0';
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
camel_internet_address_find_address (CamelInternetAddress *addr,
                                     const gchar *address,
                                     const gchar **namep)
{
	struct _address *a;
	gint i, len;
	g_assert (CAMEL_IS_INTERNET_ADDRESS (addr));
	len = ((CamelAddress *) addr)->addresses->len;
	for (i = 0; i < len; i++) {
		a = g_ptr_array_index (((CamelAddress *) addr)->addresses, i);
		if (!strcmp (a->address, address)) {
			if (namep)
				*namep = a->name;
			return i;
		}
	}
	return -1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
rqs_match_host_scope(lList *scope, const char *name, lList *master_hgroup_list, bool is_xscope) 
{
   lListElem *ep;
   DENTER(TOP_LAYER, "rqs_match_host_scope");
   if (lGetElemStr(scope, ST_name, "*")) {
      DRETURN(true);
   }
   if (sge_is_pattern(name) || is_hgroup_name(name)) {
      DRETURN(rqs_match_user_host_scope(scope, FILTER_HOSTS, name, NULL, master_hgroup_list, NULL, is_xscope));
   }
   /* at this stage we know 'name' is a simple hostname */
   for_each(ep, scope) {
      if (!qref_list_host_rejected(lGetString(ep, ST_name), name, master_hgroup_list)) {
         DRETURN(true);
      }
   }
   DRETURN(false);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
doFinalization(Module &M) {
  const DataLayout &DL = getDataLayout();
  bool isPPC64 = DL.getPointerSizeInBits() == 64;
  PPCTargetStreamer &TS =
      static_cast<PPCTargetStreamer &>(*OutStreamer->getTargetStreamer());
  if (!TOC.empty()) {
    MCSectionELF *Section;
    if (isPPC64)
      Section = OutStreamer->getContext().getELFSection(
          ".toc", ELF::SHT_PROGBITS, ELF::SHF_WRITE | ELF::SHF_ALLOC);
        else
          Section = OutStreamer->getContext().getELFSection(
              ".got2", ELF::SHT_PROGBITS, ELF::SHF_WRITE | ELF::SHF_ALLOC);
    OutStreamer->SwitchSection(Section);
    for (MapVector<MCSymbol*, MCSymbol*>::iterator I = TOC.begin(),
         E = TOC.end(); I != E; ++I) {
      OutStreamer->EmitLabel(I->second);
      MCSymbol *S = I->first;
      if (isPPC64)
        TS.emitTCEntry(*S);
      else
        OutStreamer->EmitSymbolValue(S, 4);
    }
  }
  return AsmPrinter::doFinalization(M);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
find_sections_buffered(section_t *section, char *start, char *key,
						va_list args, char *buf, int len, array_t **sections)
{
	section_t *found = NULL, *fallback;
	char *pos;
	int i;
	if (!section)
	{
		return;
	}
	pos = strchr(key, '.');
	if (pos)
	{
		*pos = '\0';
	}
	if (!print_key(buf, len, start, key, args))
	{
		return;
	}
	if (pos)
	{	/* restore so we can follow fallbacks */
		*pos = '.';
	}
	if (!strlen(buf))
	{
		found = section;
	}
	else
	{
		array_bsearch(section->sections, buf, settings_section_find, &found);
	}
	if (found)
	{
		if (pos)
		{
			find_sections_buffered(found, start, pos+1, args, buf, len,
								   sections);
		}
		else
		{
			array_insert_create(sections, ARRAY_TAIL, found);
			for (i = 0; i < array_count(found->fallbacks); i++)
			{
				array_get(found->fallbacks, i, &fallback);
				array_insert_create(sections, ARRAY_TAIL, fallback);
			}
		}
	}
	if (section->fallbacks)
	{
		for (i = 0; i < array_count(section->fallbacks); i++)
		{
			array_get(section->fallbacks, i, &fallback);
			find_sections_buffered(fallback, start, key, args, buf, len,
								   sections);
		}
	}
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
installedEntries() const
{
    EntryInternal::List entries;
    foreach (const EntryInternal& entry, mCachedEntries) {
        if (entry.status() == Entry::Installed || entry.status() == Entry::Updateable) {
            entries.append(entry);
        }
    }
    return entries;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
extend_info_get_description(char *buf, const extend_info_t *ei)
{
  if (!ei)
    return "<null>";
  return format_node_description(buf,
                                 ei->identity_digest,
                                 0,
                                 ei->nickname,
                                 &ei->addr,
                                 0);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
pccard_store_card_pm_state(struct device *dev,
					  struct device_attribute *attr,
					  const char *buf, size_t count)
{
	struct pcmcia_socket *s = to_socket(dev);
	ssize_t ret = count;
	if (!count)
		return -EINVAL;
	if (!strncmp(buf, "off", 3))
		pcmcia_parse_uevents(s, PCMCIA_UEVENT_SUSPEND);
	else {
		if (!strncmp(buf, "on", 2))
			pcmcia_parse_uevents(s, PCMCIA_UEVENT_RESUME);
		else
			ret = -EINVAL;
	}
	return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
getAddrCount(SPtr<TDUID> duid)
{
    SPtr <TAddrClient> ptrClient;
    ClntsLst.first();
    while ( ptrClient = ClntsLst.get() ) {
        if ( (*ptrClient->getDUID()) == (*duid))
            break;
    }
    // Have we found this client?
    if (!ptrClient) {
        return 0;
    }
    unsigned long count=0;
    // look at each of client's IAs
    SPtr <TAddrIA> ptrIA;
    ptrClient->firstIA();
    while ( ptrIA = ptrClient->getIA() ) {
        count += ptrIA->countAddr();
    }
    return count;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
multi_data_handle_incoming(int handle)
{	
	int player_index = -1;
	PSNET_SOCKET_RELIABLE sock = INVALID_SOCKET;	
	char *fname;		
	// get the player who is sending us this file	
	sock = multi_xfer_get_sock(handle);
	player_index = find_player_socket(sock);
	// get the filename of the file
	fname = multi_xfer_get_filename(handle);
	if(fname == NULL){
		nprintf(("Network", "Could not get file xfer filename! wacky...!\n"));
		// kill the stream
		multi_xfer_xor_flags(handle, MULTI_XFER_FLAG_REJECT);
		return;
	}
	// if this is not a valid data file
	if(!multi_data_is_data(fname)){
		nprintf(("Network", "Not accepting xfer request because its not a valid data file!\n"));
		// kill the stream		
		multi_xfer_xor_flags(handle, MULTI_XFER_FLAG_REJECT);	
		return;
	}	
	// if we already have a copy of this file, abort the xfer		
	// Does file exist in \multidata?
	if (cf_exists(fname, CF_TYPE_MULTI_CACHE)) {
		nprintf(("Network", "Not accepting file xfer because a duplicate exists!\n"));			
		// kill the stream		
		multi_xfer_xor_flags(handle, MULTI_XFER_FLAG_REJECT);	
		// if we're the server, we still need to add it to the list though
		if((Net_player->flags & NETINFO_FLAG_AM_MASTER) && (player_index >= 0)){
			multi_data_add_new(fname, player_index);
		}
		return;
	}	
	// if I'm the server of the game, do stuff a little differently
	if(Net_player->flags & NETINFO_FLAG_AM_MASTER){		
		if(player_index == -1){
			nprintf(("Network", "Could not find player for incoming player data stream!\n"));
			// kill the stream
			multi_xfer_xor_flags(handle, MULTI_XFER_FLAG_REJECT);
			return;
		}	
		// attempt to add the file
		if(!multi_data_add_new(fname, player_index)){
			// kill the stream
			multi_xfer_xor_flags(handle, MULTI_XFER_FLAG_REJECT);
			return;
		} else {
			// force the file to go into the multi cache directory
			multi_xfer_handle_force_dir(handle, CF_TYPE_MULTI_CACHE);
			// mark it as autodestroy			
			multi_xfer_xor_flags(handle, MULTI_XFER_FLAG_AUTODESTROY);
		}
	}
	// if i'm a client, this is an incoming file from the server
	else {
		// if i'm not accepting pilot pics, abort
		if(!(Net_player->p_info.options.flags & MLO_FLAG_ACCEPT_PIX)){
			nprintf(("Network", "Client not accepting files because we don't want 'em!\n"));
			// kill the stream		
			multi_xfer_xor_flags(handle, MULTI_XFER_FLAG_REJECT);	
			return;
		}
		// set the xfer handle to autodestroy itself since we don't really want to have to manage all incoming pics
		multi_xfer_xor_flags(handle, MULTI_XFER_FLAG_AUTODESTROY);
		// force the file to go into the multi cache directory
		multi_xfer_handle_force_dir(handle, CF_TYPE_MULTI_CACHE);
		// begin receiving the file
		nprintf(("Network", "Client receiving xfer handle %d\n",handle));
	}		
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
SVGCircleElement(const QualifiedName& tagName, Document* doc)
    : SVGStyledTransformableElement(tagName, doc)
    , SVGTests()
    , SVGLangSpace()
    , SVGExternalResourcesRequired()
    , m_cx(SVGLength(this, LengthModeWidth))
    , m_cy(SVGLength(this, LengthModeHeight))
    , m_r(SVGLength(this, LengthModeOther))
{
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
drain_mpi(int4 node, int4 pid, int fd)
{
	struct _gps	*world;			/* GPS array */
	int4		n_index, n_flags;	/* node entry info */
	int4		p_index, p_flags;	/* pid entry info */
	int4		curr_node;		/* current target */
	int4		r;			/* length of traces ret'd */
	int4		nworld;			/* # GPS records */
	int		flush_delay;		/* signal then delay */
	int		i;
	if (fl_verbose) nodespin_init("searching for an MPI world,");
	do {
		do {
			curr_node = node;
			if (fl_verbose) nodespin_next(node);
			if (ao_taken(op, "k")) {
				r = lam_rtrfget(node, TRWORLD, pid, fd);
				if (r < 0) lamfail("lamtrace (lam_rtrfget)");
			} else {
				r = lam_rtrfforget(node, TRWORLD, pid, fd);
				if (r < 0) lamfail("lamtrace (lam_rtrfget)");
			}
			nid_get(&n_index, &node, &n_flags);
		} while (n_index && (r == 0));
		pid_get(&p_index, &pid, &p_flags);
	} while ((p_index > 0) && (r == 0));
	if (fl_verbose) nodespin_end();
	if (r == 0) {
	  show_help("lamtrace", "nompiworld", NULL);
		return;
	}
	VERBOSE("found an MPI world on %s\n", nid_fmt(curr_node));
/*
 * Rewind and read GPS information from the file.
 */
	if (lseek(fd, (off_t) sizeof(int4), SEEK_SET) < 0)
			lamfail("lamtrace (lseek)");
	if (read(fd, (char *) &nworld, sizeof(int4)) < 0)
			lamfail("lamtrace (read)");
	nworld = ttol(nworld);
	VERBOSE("MPI world size is %d.\n", nworld);
	world = (struct _gps *) malloc((unsigned) (sizeof(struct _gps) *
			nworld));
	if (world == 0) lamfail("lamtrace (malloc)");
	if (read(fd, (char *) world, sizeof(struct _gps) * nworld) < 0)
			lamfail("lamtrace (read)");
/*
 * Convert GPS array to local byte order.
 */
	for (i = 0; i < nworld; ++i) {
		world[i].gps_node = ttol(world[i].gps_node);
		world[i].gps_pid = ttol(world[i].gps_pid);
		world[i].gps_idx = ttol(world[i].gps_idx);
		world[i].gps_grank = ttol(world[i].gps_grank);
	}
/*
 * Determine flush delay.
 */
	if (ao_taken(op, "f")) {
	    ao_intparam(op, "f", 0, 0, &flush_delay);
	} else {
	    flush_delay = -1;
	}
	VERBOSE("draining MPI traces ...\n");
	if (trdrain_mpi(fd, world, nworld, ao_taken(op, "k"), flush_delay))
			lamfail("lamtrace (trdrain_mpi)");
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
cq_periodic_main_add(int period, cq_invoke_t event, void *arg)
{
	cq_main_init();
	return cq_periodic_add(callout_queue, period, event, arg);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
strnl0(const char *s) /* replace "\\n" by "\n" in a cmd-line arg */
{
  char *t,*u;
  t=malloc(strlen(s)+1);
  u=t;
  while (*s!=0) {
    if ((*s=='\\')&&(s[1]=='n')) { *u='\n'; s++; }
    else *u=*s;
    s++; u++;
  }
  *u=0;
  return t;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
__lambda35_ (Block8Data* _data8_) {
	UnityResultPreviewer * self;
	void* result = NULL;
	UnityAbstractPreview* preview = NULL;
	UnityAbstractPreview* _tmp0_ = NULL;
	UnityAbstractPreviewCallback _tmp1_ = NULL;
	void* _tmp1__target = NULL;
	self = _data8_->self;
	_tmp0_ = unity_result_previewer_run (self);
	preview = _tmp0_;
	_tmp1_ = _data8_->async_callback;
	_tmp1__target = _data8_->async_callback_target;
	_tmp1_ (self, preview, _tmp1__target);
	result = NULL;
	_g_object_unref0 (preview);
	return result;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
update_after_action (Sheet *sheet, WorkbookControl *wbc)
{
	gnm_app_recalc ();
	if (sheet != NULL) {
		g_return_if_fail (IS_SHEET (sheet));
		sheet_mark_dirty (sheet);
		sheet_update (sheet);
		if (sheet->workbook == wb_control_get_workbook (wbc))
			WORKBOOK_VIEW_FOREACH_CONTROL (wb_control_view (wbc), control,
				  wb_control_sheet_focus (control, sheet););
	} else if (wbc != NULL) {
		Sheet *sheet = wb_control_cur_sheet (wbc);
		if (sheet)
			sheet_update (sheet);
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
nocustom (void)
{
	if (picasso_on && currprefs.picasso96_nocustom)
		return true;
	return false;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gda_tree_node_get_parent (GdaTreeNode *node)
{
	GdaTreeNode *parent;
	g_return_val_if_fail (GDA_IS_TREE_NODE (node), NULL);
	parent = node->priv->parent;
	if (parent && !parent->priv->parent)
		return NULL; /* avoid returning the private GdaTree's ROOT node */
	else
		return parent;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
parse_timezone(const char *tz)
{
	const char *rfc822_timezones[][4] = {
		{ "M", NULL },			/* UTC-12 */
		{ "L", NULL },
		{ "K", NULL },
		{ "I", NULL },
		{ "H", "PST", NULL }, 		/* UTC-8 */
		{ "G", "MST", "PDT", NULL },	/* UTC-7 */
		{ "F", "CST", "MDT", NULL },	/* UTC-6 */
		{ "E", "EST", "CDT", NULL },	/* UTC-5 */
		{ "D", "EDT", NULL },		/* UTC-4 */
		{ "C", NULL },
		{ "B", NULL },
		{ "A", NULL },
		{ "Z", "UT", "GMT", NULL },	/* UTC */
		{ "N", NULL },
		{ "O", NULL },
		{ "P", NULL },
		{ "Q", NULL },
		{ "R", NULL },
		{ "S", NULL },
		{ "T", NULL },
		{ "U", NULL },
		{ "V", NULL },
		{ "W", NULL },
		{ "X", NULL },
		{ "Y", NULL },			/* UTC+12 */
		{ NULL },
	};
	unsigned int i, j;
	if ((*tz == '+' || *tz == '-') && strlen(tz) == 5) {
		i = atoi(tz);
		return ((i/100)*60 + i%100) * 60;
	}
	for (i = 0; i < nitems(rfc822_timezones); ++i)
		for (j = 0; rfc822_timezones[i][j] != NULL; ++j)
			if (strcmp(rfc822_timezones[i][j], tz) == 0)
				return (i - 12) * 3600;
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
folks_debug_print_heading (FolksDebug* self, const gchar* domain, GLogLevelFlags level, const gchar* format, ...) {
	static const gint heading_colours[] = {31, 32, 34};
	gchar* wrapper_format = NULL;
	gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	va_list valist = {0};
	gchar* output = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	GLogLevelFlags _tmp11_ = 0;
	const gchar* _tmp12_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (domain != NULL);
	g_return_if_fail (format != NULL);
	_tmp0_ = g_strdup ("%s");
	wrapper_format = _tmp0_;
	_tmp1_ = folks_debug_get_colour_enabled (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == TRUE) {
		guint indentation = 0U;
		guint _tmp3_ = 0U;
		guint _tmp4_ = 0U;
		guint _tmp5_ = 0U;
		gint _tmp6_ = 0;
		gchar* _tmp7_ = NULL;
		_tmp3_ = self->priv->_indentation;
		_tmp4_ = CLAMP (_tmp3_, (guint) 0, (guint) (G_N_ELEMENTS (heading_colours) - 1));
		indentation = _tmp4_;
		_tmp5_ = indentation;
		_tmp6_ = heading_colours[_tmp5_];
		_tmp7_ = g_strdup_printf ("\033[1;%im%%s\033[0m", _tmp6_);
		_g_free0 (wrapper_format);
		wrapper_format = _tmp7_;
	}
	va_start (valist, format);
	_tmp8_ = format;
	_tmp9_ = g_strdup_vprintf (_tmp8_, valist);
	output = _tmp9_;
	_tmp10_ = domain;
	_tmp11_ = level;
	_tmp12_ = wrapper_format;
	folks_debug_print_line (self, _tmp10_, _tmp11_, _tmp12_, output);
	_g_free0 (output);
	va_end (valist);
	_g_free0 (wrapper_format);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
scsi_data_dir_opcode(unsigned char op)
{
	enum data_direction dir;
	switch (op) {
	case WRITE_6:
	case WRITE_10:
	case WRITE_VERIFY:
	case WRITE_12:
	case WRITE_16:
		dir = DATA_WRITE;
		break;
	default:
		dir = DATA_READ;
		break;
	}
	return dir;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
MixCoder_Free(CMixCoder *p)
{
  int i;
  for (i = 0; i < p->numCoders; i++)
  {
    IStateCoder *sc = &p->coders[i];
    if (p->alloc && sc->p)
      sc->Free(sc->p, p->alloc);
  }
  p->numCoders = 0;
  if (p->buf)
    p->alloc->Free(p->alloc, p->buf);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
battery_level(DBusConnection *conn, DBusMessage *msg,
					void *data)
{
	dbus_uint32_t level;
	if (!dbus_message_get_args(msg, NULL, DBUS_TYPE_UINT32, &level,
						DBUS_TYPE_INVALID))
		return btd_error_invalid_args(msg);
	if (level > 5)
		return btd_error_invalid_args(msg);
	telephony_update_indicator(dummy_indicators, "battchg", level);
	DBG("telephony-dummy: battery level set to %u", level);
	return dbus_message_new_method_return(msg);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_exvGettext(const char* str)
{
    static bool exvGettextInitialized = false;
    if (!exvGettextInitialized) {
        bindtextdomain(EXV_PACKAGE, EXV_LOCALEDIR);
# ifdef EXV_HAVE_BIND_TEXTDOMAIN_CODESET
        bind_textdomain_codeset (EXV_PACKAGE, "UTF-8");
# endif
        exvGettextInitialized = true;
    }
    return dgettext(EXV_PACKAGE, str);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
nfs_idmap_lookup_id(const char *name, size_t namelen, const char *type,
			       __u32 *id, struct idmap *idmap)
{
	char id_str[NFS_UINT_MAXLEN];
	long id_long;
	ssize_t data_size;
	int ret = 0;
	data_size = nfs_idmap_get_key(name, namelen, type, id_str, NFS_UINT_MAXLEN, idmap);
	if (data_size <= 0) {
		ret = -EINVAL;
	} else {
		ret = kstrtol(id_str, 10, &id_long);
		*id = (__u32)id_long;
	}
	return ret;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ffm_write_data(AVFormatContext *s,
                           const uint8_t *buf, int size,
                           int64_t dts, int header)
{
    FFMContext *ffm = s->priv_data;
    int len;
    if (header && ffm->frame_offset == 0) {
        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;
        ffm->dts = dts;
    }
    /* write as many packets as needed */
    while (size > 0) {
        len = ffm->packet_end - ffm->packet_ptr;
        if (len > size)
            len = size;
        memcpy(ffm->packet_ptr, buf, len);
        ffm->packet_ptr += len;
        buf += len;
        size -= len;
        if (ffm->packet_ptr >= ffm->packet_end)
            flush_packet(s);
    }
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
TMX_TestStepOffset(void)
{
  struct timex txc;
  /* Zero maxerror and check it's reset to a maximum after ADJ_SETOFFSET.
     This seems to be the only way how to verify that the kernel really
     supports the ADJ_SETOFFSET mode as it doesn't return an error on unknown
     mode. */
  txc.modes = ADJ_MAXERROR;
  txc.maxerror = 0;
  if (adjtimex(&txc) < 0 || txc.maxerror != 0)
    return -1;
  txc.modes = ADJ_SETOFFSET;
  txc.time.tv_sec = 0;
  txc.time.tv_usec = 0;
  if (adjtimex(&txc) < 0 || txc.maxerror < 100000)
    return -1;
  return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ProcessPreview(OFLibDlg *d,PreviewThread *cur) {
    char *pt, *name;
    FILE *final;
    int ch;
    cur->fi->downloading_in_background = false;
    if ( cur->result==NULL )		/* Finished, but didn't work */
return;
    rewind(cur->result);
    pt = strrchr(cur->active->url,'/');
    if ( pt==NULL ) {	/* Can't happen */
	fclose(cur->result);
return;
    }
    name = galloc(strlen(getOFLibDir()) + strlen(pt) + 10 );
    sprintf( name,"%s%s", getOFLibDir(), pt);
    final = fopen(name,"w");
    if ( final==NULL ) {
	fclose(cur->result);
return;
    }
    GDrawSetCursor(d->gw,ct_watch);
    if ( cur->is_image ) {
	while ( (ch=getc(cur->result))!=EOF )
	    putc(ch,final);
	fclose(final);
	fclose(cur->result);
    } else {
	SplineFont *sf = _ReadSplineFont(cur->result,cur->active->url,0);
	/* The above routine closes cur->result */
	if ( sf==NULL ) {
	    fclose(final);
	    unlink(name);
	    free(name);
	    GDrawSetCursor(d->gw,ct_mypointer);
return;
	}
	pt = strrchr(name,'.');
	if ( pt==NULL || pt<strrchr(name,'/') )
	    strcat(name,".png");
	else
	    strcpy(pt,".png");
	SFDefaultImage(sf,name);
	SplineFontFree(sf);
    }
    cur->fi->preview_filename = copy(strrchr(name,'/')+1);
    free(name);
    OFLibEnableButtons(d);		/* This will load the image */
    DumpOFLibState(&d->all);
    GDrawSetCursor(d->gw,ct_mypointer);
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
__lambda9_ (FsoTestGsmCallTest* self, GAsyncResult* res, GError** error) {
	FreeSmartphoneGSMNetwork* _tmp0_ = NULL;
	GAsyncResult* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
#line 157 "/tmp/buildd/fso-gsmd-0.12.0/tests/integration/calltests.vala"
	g_return_if_fail (res != NULL);
#line 157 "/tmp/buildd/fso-gsmd-0.12.0/tests/integration/calltests.vala"
	_tmp0_ = ((FsoTestGsmBaseTest*) self)->gsm_network;
#line 157 "/tmp/buildd/fso-gsmd-0.12.0/tests/integration/calltests.vala"
	_tmp1_ = res;
#line 157 "/tmp/buildd/fso-gsmd-0.12.0/tests/integration/calltests.vala"
	free_smartphone_gsm_network_get_signal_strength_finish (_tmp0_, _tmp1_, &_inner_error_);
#line 157 "/tmp/buildd/fso-gsmd-0.12.0/tests/integration/calltests.vala"
	if (_inner_error_ != NULL) {
#line 157 "/tmp/buildd/fso-gsmd-0.12.0/tests/integration/calltests.vala"
		g_propagate_error (error, _inner_error_);
#line 157 "/tmp/buildd/fso-gsmd-0.12.0/tests/integration/calltests.vala"
		return;
#line 2482 "calltests.c"
	}
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
listCert(char* tokenName) {
  /* int expired = 0; */
  CERTCertList *certList;
  CERTCertListNode *cln;
  PK11SlotInfo *slot = PK11_FindSlotByName(tokenName);
  PK11SlotInfo *internal_slot;
  char *internalTokenName;
  if (!slot) {
	  errorRpt(GENERAL_FAILURE, getResourceString(DBT_TOKEN_NAME));
	  return;
  }
  if (PK11_IsInternal(slot)) {
	  internal_slot = slot;
  } else {
	  internal_slot = PK11_GetInternalKeySlot();
	  if (!internal_slot) {
		  errorRpt(GENERAL_FAILURE, getResourceString(DBT_INIT_FAIL));
		  return;
	  }
  }
  internalTokenName =  PK11_GetTokenName(internal_slot);
  if (PK11_NeedUserInit(internal_slot) == PR_TRUE) {
	  fprintf(stdout, "<NEEDINIT_INTERNAL>TRUE</NEEDINIT_INTERNAL>\n");
  } else {
	  fprintf(stdout, "<NEEDINIT_INTERNAL>FALSE</NEEDINIT_INTERNAL>\n");
  }
  certList = PK11_ListCerts(PK11CertListUnique, NULL);
  if (certList == NULL) {
    errorRpt(GENERAL_FAILURE, getResourceString(DBT_CERT_LIST_FAIL));
  }
  for (cln = CERT_LIST_HEAD(certList); !CERT_LIST_END(cln,certList);
       cln = CERT_LIST_NEXT(cln)) {
       char *certTokenName=NULL;
       if (cln->cert->slot == NULL) {
           certTokenName = internalTokenName;
       }
       else {
           certTokenName = PK11_GetTokenName(cln->cert->slot);
       }
       /* Output the cert if it belongs to this token */
       if (strcmp(tokenName, certTokenName) == 0) {
           printCert(cln->cert, /*showDetail=*/PR_FALSE, NULL);
       }
       /* 
        * List "Builtin Object Token" as if it is the internal token 
        * This is a special NSS read-only token for storing predefined CA certs
        */ 
       else if ((strcmp(tokenName, internalTokenName) == 0) &&
                (strcmp(certTokenName, "Builtin Object Token") == 0)) {
           printCert(cln->cert, /*showDetail=*/PR_FALSE, NULL);
       }
  }
  CERT_DestroyCertList(certList);
  if (PK11_IsInternal(slot)) {
    showCRL(certdb, SEC_CRL_TYPE);
    showCRL(certdb, SEC_KRL_TYPE);
  }
  if (slot != internal_slot) {
	  PK11_FreeSlot(internal_slot);
  }
  PK11_FreeSlot(slot);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
l2t_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	v = l2t_get_idx(seq, *pos);
	if (v)
		++*pos;
	return v;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
libmail_gpg_deletekey(const char *gpgdir, int secret,
			  const char *fingerprint,
			  int (*dump_func)(const char *, size_t, void *),
			  void *voidarg)
{
	char *argvec[8];
	int rc;
	argvec[0]="gpg";
	argvec[1]="--command-fd";
	argvec[2]="0";
	argvec[3]= secret ? "--delete-secret-key":"--delete-key";
	argvec[4]="-q";
	argvec[5]="--no-tty";
	argvec[6]=(char *)fingerprint;
	argvec[7]=0;
	if (libmail_gpg_fork(&libmail_gpg_stdin, &libmail_gpg_stdout, NULL,
			     gpgdir, argvec) < 0)
		rc= -1;
	else
	{
		int rc2;
		rc=dodeletekey(dump_func, voidarg);
		rc2=libmail_gpg_cleanup();
		if (rc2)
			rc=rc2;
	}
	return (rc);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
entangle_camera_picker_finalize(GObject *object)
{
    EntangleCameraPicker *picker = ENTANGLE_CAMERA_PICKER(object);
    EntangleCameraPickerPrivate *priv = picker->priv;
    ENTANGLE_DEBUG("Finalize camera picker");
    gtk_list_store_clear(priv->model);
    if (priv->cameras)
        g_object_unref(priv->cameras);
    g_object_unref(priv->model);
    g_object_unref(priv->builder);
    G_OBJECT_CLASS(entangle_camera_picker_parent_class)->finalize(object);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
vmlfb_alloc_vram_area(struct vram_area *va, unsigned max_order,
				 unsigned min_order)
{
	gfp_t flags;
	unsigned long i;
	max_order++;
	do {
		/*
		 * Really try hard to get the needed memory.
		 * We need memory below the first 32MB, so we
		 * add the __GFP_DMA flag that guarantees that we are
		 * below the first 16MB.
		 */
		flags = __GFP_DMA | __GFP_HIGH | __GFP_KSWAPD_RECLAIM;
		va->logical =
			 __get_free_pages(flags, --max_order);
	} while (va->logical == 0 && max_order > min_order);
	if (!va->logical)
		return -ENOMEM;
	va->phys = virt_to_phys((void *)va->logical);
	va->size = PAGE_SIZE << max_order;
	va->order = max_order;
	/*
	 * It seems like __get_free_pages only ups the usage count
	 * of the first page. This doesn't work with fault mapping, so
	 * up the usage count once more (XXX: should use split_page or
	 * compound page).
	 */
	memset((void *)va->logical, 0x00, va->size);
	for (i = va->logical; i < va->logical + va->size; i += PAGE_SIZE) {
		get_page(virt_to_page(i));
	}
	/*
	 * Change caching policy of the linear kernel map to avoid
	 * mapping type conflicts with user-space mappings.
	 */
	set_pages_uc(virt_to_page(va->logical), va->size >> PAGE_SHIFT);
	printk(KERN_DEBUG MODULE_NAME
	       ": Allocated %ld bytes vram area at 0x%08lx\n",
	       va->size, va->phys);
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
PyFFContour_init(PyFF_Contour *self, PyObject *args, PyObject *kwds) {
    int quad=0;
    if ( args!=NULL && !PyArg_ParseTuple(args, "|i", &quad))
return -1;
    self->is_quadratic = (quad!=0);
return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
gst_asf_demux_add_video_stream (GstASFDemux * demux,
    asf_stream_video_format * video, guint16 id,
    guint8 ** p_data, guint64 * p_size)
{
  GstTagList *tags = NULL;
  GstBuffer *extradata = NULL;
  GstPad *src_pad;
  GstCaps *caps;
  gchar *str;
  gchar *name = NULL;
  gchar *codec_name = NULL;
  gint size_left = video->size - 40;
  /* Create the video pad */
  name = g_strdup_printf ("video_%u", demux->num_video_streams);
  src_pad = gst_pad_new_from_static_template (&video_src_template, name);
  g_free (name);
  /* Now try some gstreamer formatted MIME types (from gst_avi_demux_strf_vids) */
  if (size_left) {
    GST_LOG ("Video header has %d bytes of codec specific data", size_left);
    g_assert (size_left <= *p_size);
    gst_asf_demux_get_buffer (&extradata, size_left, p_data, p_size);
  }
  GST_DEBUG ("video codec %" GST_FOURCC_FORMAT, GST_FOURCC_ARGS (video->tag));
  /* yes, asf_stream_video_format and gst_riff_strf_vids are the same */
  caps = gst_riff_create_video_caps (video->tag, NULL,
      (gst_riff_strf_vids *) video, extradata, NULL, &codec_name);
  if (caps == NULL) {
    caps = gst_caps_new_simple ("video/x-asf-unknown", "fourcc",
        G_TYPE_UINT, video->tag, NULL);
  } else {
    GstStructure *s;
    gint ax, ay;
    s = gst_asf_demux_get_metadata_for_stream (demux, id);
    if (gst_structure_get_int (s, "AspectRatioX", &ax) &&
        gst_structure_get_int (s, "AspectRatioY", &ay) && (ax > 0 && ay > 0)) {
      gst_caps_set_simple (caps, "pixel-aspect-ratio", GST_TYPE_FRACTION,
          ax, ay, NULL);
    } else {
      guint ax, ay;
      /* retry with the global metadata */
      GST_DEBUG ("Retrying with global metadata %" GST_PTR_FORMAT,
          demux->global_metadata);
      s = demux->global_metadata;
      if (gst_structure_get_uint (s, "AspectRatioX", &ax) &&
          gst_structure_get_uint (s, "AspectRatioY", &ay)) {
        GST_DEBUG ("ax:%d, ay:%d", ax, ay);
        if (ax > 0 && ay > 0)
          gst_caps_set_simple (caps, "pixel-aspect-ratio", GST_TYPE_FRACTION,
              ax, ay, NULL);
      }
    }
    s = gst_caps_get_structure (caps, 0);
    gst_structure_remove_field (s, "framerate");
  }
  /* add fourcc format to caps, some proprietary decoders seem to need it */
  str = g_strdup_printf ("%" GST_FOURCC_FORMAT, GST_FOURCC_ARGS (video->tag));
  gst_caps_set_simple (caps, "format", G_TYPE_STRING, str, NULL);
  g_free (str);
  if (codec_name) {
    tags = gst_tag_list_new (GST_TAG_VIDEO_CODEC, codec_name, NULL);
    g_free (codec_name);
  }
  if (extradata)
    gst_buffer_unref (extradata);
  GST_INFO ("Adding video stream #%u, id %u, codec %"
      GST_FOURCC_FORMAT " (0x%08x)", demux->num_video_streams, id,
      GST_FOURCC_ARGS (video->tag), video->tag);
  ++demux->num_video_streams;
  return gst_asf_demux_setup_pad (demux, src_pad, caps, id, TRUE, tags);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
wilc1000_wlan_init(struct net_device *dev, perInterface_wlan_t *p_nic)
{
	wilc_wlan_inp_t nwi;
	perInterface_wlan_t *nic = p_nic;
	int ret = 0;
	struct wilc *wl = nic->wilc;
	if (!wl->initialized) {
		wl->mac_status = WILC_MAC_STATUS_INIT;
		wl->close = 0;
		wlan_init_locks(dev);
		linux_to_wlan(&nwi, wl);
		ret = wilc_wlan_init(&nwi);
		if (ret < 0) {
			PRINT_ER("Initializing WILC_Wlan FAILED\n");
			ret = -EIO;
			goto _fail_locks_;
		}
#if (!defined WILC_SDIO) || (defined WILC_SDIO_IRQ_GPIO)
		if (init_irq(dev)) {
			PRINT_ER("couldn't initialize IRQ\n");
			ret = -EIO;
			goto _fail_locks_;
		}
#endif
		ret = wlan_initialize_threads(dev);
		if (ret < 0) {
			PRINT_ER("Initializing Threads FAILED\n");
			ret = -EIO;
			goto _fail_wilc_wlan_;
		}
#if (defined WILC_SDIO) && (!defined WILC_SDIO_IRQ_GPIO)
		if (enable_sdio_interrupt()) {
			PRINT_ER("couldn't initialize IRQ\n");
			ret = -EIO;
			goto _fail_irq_init_;
		}
#endif
		if (linux_wlan_get_firmware(nic)) {
			PRINT_ER("Can't get firmware\n");
			ret = -EIO;
			goto _fail_irq_enable_;
		}
		/*Download firmware*/
		ret = linux_wlan_firmware_download(wl);
		if (ret < 0) {
			PRINT_ER("Failed to download firmware\n");
			ret = -EIO;
			goto _fail_irq_enable_;
		}
		/* Start firmware*/
		ret = linux_wlan_start_firmware(nic);
		if (ret < 0) {
			PRINT_ER("Failed to start firmware\n");
			ret = -EIO;
			goto _fail_irq_enable_;
		}
		wilc_bus_set_max_speed();
		if (wilc_wlan_cfg_get(1, WID_FIRMWARE_VERSION, 1, 0)) {
			int size;
			char Firmware_ver[20];
			size = wilc_wlan_cfg_get_val(
					WID_FIRMWARE_VERSION,
					Firmware_ver, sizeof(Firmware_ver));
			Firmware_ver[size] = '\0';
			PRINT_D(INIT_DBG, "***** Firmware Ver = %s  *******\n", Firmware_ver);
		}
		/* Initialize firmware with default configuration */
		ret = linux_wlan_init_test_config(dev, wl);
		if (ret < 0) {
			PRINT_ER("Failed to configure firmware\n");
			ret = -EIO;
			goto _fail_fw_start_;
		}
		wl->initialized = true;
		return 0; /*success*/
_fail_fw_start_:
		wilc_wlan_stop();
_fail_irq_enable_:
#if (defined WILC_SDIO) && (!defined WILC_SDIO_IRQ_GPIO)
		disable_sdio_interrupt();
_fail_irq_init_:
#endif
#if (!defined WILC_SDIO) || (defined WILC_SDIO_IRQ_GPIO)
		deinit_irq(dev);
#endif
		wlan_deinitialize_threads(dev);
_fail_wilc_wlan_:
		wilc_wlan_cleanup(dev);
_fail_locks_:
		wlan_deinit_locks(dev);
		PRINT_ER("WLAN Iinitialization FAILED\n");
	} else {
		PRINT_D(INIT_DBG, "wilc1000 already initialized\n");
	}
	return ret;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
PR_RWLock_Wlock(PRRWLock *rwlock)
{
#if defined(DEBUG)
PRThread *me = PR_GetCurrentThread();
#endif
#if defined(HAVE_UNIX98_RWLOCK) || defined(HAVE_UI_RWLOCK)
int err;
#endif
#ifdef _PR_RWLOCK_RANK_ORDER_DEBUG
	/*
	 * assert that rank ordering is not violated; the rank of 'rwlock' should
	 * be equal to or greater than the highest rank of all the locks held by
	 * the thread.
	 */
	PR_ASSERT((rwlock->rw_rank == PR_RWLOCK_RANK_NONE) || 
					(rwlock->rw_rank >= _PR_GET_THREAD_RWLOCK_RANK()));
#endif
#if defined(HAVE_UNIX98_RWLOCK) || defined(HAVE_UI_RWLOCK)
	err = RWLOCK_WRLOCK(&rwlock->rw_lock);
	PR_ASSERT(err == 0);
#else
	PR_Lock(rwlock->rw_lock);
	/*
	 * wait if read locked
	 */
	while (rwlock->rw_lock_cnt != 0) {
		rwlock->rw_writer_cnt++;
		PR_WaitCondVar(rwlock->rw_writer_waitq, PR_INTERVAL_NO_TIMEOUT);
		rwlock->rw_writer_cnt--;
	}
	/*
	 * apply write lock
	 */
	rwlock->rw_lock_cnt--;
	PR_ASSERT(rwlock->rw_lock_cnt == -1);
#ifdef DEBUG
	PR_ASSERT(me != NULL);
	rwlock->rw_owner = me;
#endif
	PR_Unlock(rwlock->rw_lock);
#endif
#ifdef _PR_RWLOCK_RANK_ORDER_DEBUG
	/*
	 * update thread's lock rank
	 */
	if (rwlock->rw_rank != PR_RWLOCK_RANK_NONE)
		_PR_SET_THREAD_RWLOCK_RANK(rwlock);
#endif
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
guess_got_query_key(enum udp_ping_ret type,
	const struct gnutella_node *n, void *data)
{
	struct guess_qk_context *ctx = data;
	guess_t *gq;
	const gnet_host_t *host = ctx->host;
	gq = guess_is_alive(ctx->gid);
	if (NULL == gq) {
		if (UDP_PING_EXPIRED == type || UDP_PING_TIMEDOUT == type)
			guess_qk_context_free(ctx);
		return;
	}
	g_assert(atom_is_host(ctx->host));
	switch (type) {
	case UDP_PING_TIMEDOUT:
		/*
		 * Maybe we got the query key through a ping sent separately (by
		 * the background GUESS discovery logic)?
		 */
		{
			struct qkdata *qk = get_qkdata(host);
			if (
				qk != NULL && qk->length != 0 &&
				delta_time(tm_time(), qk->last_update) <= GUESS_QK_LIFE
			) {
				if (GNET_PROPERTY(guess_client_debug) > 2) {
					g_info("GUESS QUERY[%s] concurrently got query key for %s",
						nid_to_string(&gq->gid), gnet_host_to_string(host));
				}
				guess_send_query(gq, host);
				guess_qk_context_free(ctx);
				break;
			}
			/*
			 * If we don't have the host in the query key cache, it may mean
			 * its IP:port is plain wrong.  LimeWire nodes are known to
			 * generate wrong pongs for incoming GUESS ultrapeer connections
			 * because they use the port of the incoming TCP connection instead
			 * of parsing the Node: header from the handshake to gather the
			 * proper listening port.
			 */
			if (NULL == qk) {
				if (GNET_PROPERTY(guess_client_debug) > 2) {
					g_debug("GUESS QUERY[%s] timed out waiting query key "
						"from new host %s",
						nid_to_string(&gq->gid), gnet_host_to_string(host));
				}
				guess_alien_host(gq, host, FALSE);
				guess_qk_context_free(ctx);
				goto no_query_key;
			}
		}
		if (GNET_PROPERTY(guess_client_debug) > 2) {
			g_debug("GUESS QUERY[%s] timed out waiting query key from %s",
				nid_to_string(&gq->gid), gnet_host_to_string(host));
		}
		/*
		 * Mark timeout from host.  This will delay further usage of the
		 * host by other queries.
		 */
		guess_timeout_from(host);
		aging_remove(guess_qk_reqs, host);
		/* FALL THROUGH */
	case UDP_PING_EXPIRED:
		guess_qk_context_free(ctx);
		goto no_query_key;
	case UDP_PING_REPLY:
		if G_UNLIKELY(NULL == link_cache)
			break;
		guess_traffic_from(host);
		if (guess_extract_qk(n, host)) {
			if (GNET_PROPERTY(guess_client_debug) > 2) {
				g_debug("GUESS QUERY[%s] got query key from %s, sending query",
					nid_to_string(&gq->gid), gnet_host_to_string(host));
			}
			guess_send_query(gq, host);
		} else {
			uint16 port = peek_le16(&n->data[0]);
			host_addr_t addr = guess_extract_host_addr(n);
			/*
			 * This is probably a batch of Pong messages we're getting in
			 * reply from our Ping.
			 */
			if (GNET_PROPERTY(guess_client_debug) > 4) {
				g_debug("GUESS QUERY[%s] extra pong %s from %s",
					nid_to_string(&gq->gid),
					host_addr_port_to_string(addr, port),
					gnet_host_to_string(host));
			}
			/*
			 * If it is a pong for itself, and we don't know the query
			 * key for the host yet, then we got a plain pong because
			 * the host did not understand the "QK" GGEP key in the ping.
			 *
			 * This is not a GUESS host so remove it from the cache.
			 */
			if (
				gnet_host_get_port(host) == port &&
				host_addr_equal(gnet_host_get_addr(host), addr)
			) {
				struct qkdata *qk = get_qkdata(host);
				if (NULL == qk || 0 == qk->length) {
					guess_alien_host(gq, host, TRUE);
				}
				if (qk != NULL)
					delete_qkdata(host);
				guess_remove_link_cache(host);
				goto no_query_key;
			}
		}
		guess_extract_ipp(gq, n, host);
		break;
	}
	return;
no_query_key:
	guess_iterate(gq);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
on_copy_text_messages_activate (GtkMenuItem * menuitem, 
                                gpointer user_data)
{
	GSQL_TRACE_FUNC;
	GtkTreeView *treeview = user_data;
	GtkTreeSelection *sel;
	GtkTreeModel *model;
	GdkDisplay *disp;
	GtkClipboard *clip;
	GtkTreeIter iter;
	gchar *body_message;
	gchar *tmp;
	sel = gtk_tree_view_get_selection(treeview);
	model = gtk_tree_view_get_model (treeview);
	gtk_tree_selection_set_mode (sel, GTK_SELECTION_SINGLE);
	if (!gtk_tree_selection_get_selected (sel, &model, &iter))
		// have no one selected. 
		return;
	gtk_tree_model_get (model,	&iter,
			    3, &body_message, -1);
	gtk_tree_selection_set_mode (sel, GTK_SELECTION_MULTIPLE);
	pango_parse_markup (body_message, -1, 0, NULL, &tmp, NULL, NULL);
	body_message = tmp;
	disp = gdk_display_get_default();
	clip = gtk_clipboard_get_for_display (disp, GDK_SELECTION_CLIPBOARD);
	gtk_clipboard_set_text (clip, body_message, GSQL_MESSAGE_LEN);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
rhcs_parse_config_info(struct pluginDevice* sd, StonithNVpair * info)
{
	char * 		key;
	char *		value;
	StonithNVpair *	nv;
	sd->hostlist = NULL;
	sd->cmd_opts = g_hash_table_new(g_str_hash, g_str_equal);
	/* TODO: Maybe treat "" as delimeters too so
	 * whitespace can be passed to the plugins... */
	for (nv = info; nv->s_name; nv++) {
		if (!nv->s_name || !nv->s_value) {
			continue;
		}
		key = STRDUP(nv->s_name);
		if (!key) {
			goto err_mem;
		}
		value = STRDUP(nv->s_value);
		if (!value) {
			FREE(key);
			goto err_mem;
		}
		if (!strcmp(key,"hostlist")) {
			sd->hostlist = value;
			FREE(key);
		} else {
			g_hash_table_insert(sd->cmd_opts, key, value);
		}
	}
	return(S_OK);
err_mem:
	LOG(PIL_CRIT, "%s: out of memory!", __FUNCTION__);
	rhcs_unconfig(sd);
	return(S_OOPS);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
AcpiDsDoImplicitReturn (
    ACPI_OPERAND_OBJECT     *ReturnDesc,
    ACPI_WALK_STATE         *WalkState,
    BOOLEAN                 AddReference)
{
    ACPI_FUNCTION_NAME (DsDoImplicitReturn);
    /*
     * Slack must be enabled for this feature, and we must
     * have a valid return object
     */
    if ((!AcpiGbl_EnableInterpreterSlack) ||
        (!ReturnDesc))
    {
        return (FALSE);
    }
    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
            "Result %p will be implicitly returned; Prev=%p\n",
            ReturnDesc,
            WalkState->ImplicitReturnObj));
    /*
     * Delete any "stale" implicit return value first. However, in
     * complex statements, the implicit return value can be
     * bubbled up several levels, so we don't clear the value if it
     * is the same as the ReturnDesc.
     */
    if (WalkState->ImplicitReturnObj)
    {
        if (WalkState->ImplicitReturnObj == ReturnDesc)
        {
            return (TRUE);
        }
        AcpiDsClearImplicitReturn (WalkState);
    }
    /* Save the implicit return value, add a reference if requested */
    WalkState->ImplicitReturnObj = ReturnDesc;
    if (AddReference)
    {
        AcpiUtAddReference (ReturnDesc);
    }
    return (TRUE);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
tagtoname(char const tag[],char const *&t)
{
  char const *s;
  for(s=tag;isspace(*s);s++);
  for(t=s;(*t)&&((*t)!='>')&&((*t)!='/')&&!isspace(*t);++t);
  return GUTF8String(s,t-s);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
child_watch(GPid pid, gint status, gpointer data) {
	GtkTextBuffer *buffer;
	GtkTextIter iter;
	gchar *tmpc, *str, buf[5];
	sprintf(buf, "%i", WEXITSTATUS(status));
	str = g_strconcat(_("Rsync process exit status: "), buf, "\n", NULL);
	buffer = gtk_text_view_get_buffer((GtkTextView*)data);
	if (status == 0) {
		gtk_text_buffer_insert_at_cursor(buffer, str, -1);
	} else {
		gtk_text_buffer_get_end_iter(buffer, &iter);
		gtk_text_buffer_insert_with_tags_by_name(buffer, &iter, str, -1, "fore-red", NULL);
		tmpc = g_strconcat(error_list, str, NULL);
		g_free(error_list);
		error_list = tmpc;
		had_error = TRUE;
	}
	scroll_to_end((GtkTextView*)data, FALSE);
	if (config_log) fputs(str, log_file);
	g_free(str);
	rsync_cleanup(NULL);
	must_scroll = TRUE;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
_e_mod_ind_win_cb_menu_pre(void *data, E_Menu *mn) 
{
   Ind_Win *iwin;
   E_Menu_Item *mi;
   if (!(iwin = data)) return;
   e_menu_pre_activate_callback_set(mn, NULL, NULL);
   mi = e_menu_item_new(mn);
   e_menu_item_label_set(mi, _("Set Contents"));
   e_util_menu_item_theme_icon_set(mi, "preferences-desktop-shelf");
   e_menu_item_callback_set(mi, _e_mod_ind_win_cb_menu_contents, iwin);
   mi = e_menu_item_new(mn);
   if (iwin->gadcon->editing) 
     e_menu_item_label_set(mi, _("End Move/Resize Items"));
   else
     e_menu_item_label_set(mi, _("Begin Move/Resize Items"));
   e_util_menu_item_theme_icon_set(mi, "transform-scale");
   e_menu_item_callback_set(mi, _e_mod_ind_win_cb_menu_edit, iwin);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
insertRowBefore(unsigned row_,const MSBinaryVector& aBinaryVector_)
{
  if (row_+1>rows()) return *this;
  if (aBinaryVector_.length()!=columns())
   {
     error("MSBinaryMatrix length error.");
     return *this;
   }
  unsigned newLength=(rows()+1)*columns();
  MSTypeData<unsigned char,MSAllocator<unsigned char> > *d=MSTypeData<unsigned char,MSAllocator<unsigned char> >::allocateWithLength(newLength);  
  unsigned char *dp=d->elements();
  unsigned char *mp=data();
  unsigned char *vp=aBinaryVector_.data();
  unsigned i,j;
  for (j=0;j<rows()+1;j++)
   {
     for (i=0;i<columns();i++) *dp++=(j==row_)?*vp++:*mp++;
   }
  freeData();
  _pData=d;
  _rows++;
  _count=newLength;
  changed();  
  return *this;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
vorbis_inverse_coupling(float *mag, float *ang, int blocksize)
{
    int i;
    for(i=0; i<blocksize; i++)
    {
        if (mag[i]>0.0) {
            if (ang[i]>0.0) {
                ang[i]=mag[i]-ang[i];
            } else {
                float temp=ang[i];
                ang[i]=mag[i];
                mag[i]+=temp;
            }
        } else {
            if (ang[i]>0.0) {
                ang[i]+=mag[i];
            } else {
                float temp=ang[i];
                ang[i]=mag[i];
                mag[i]-=temp;
            }
        }
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
GrowHeap(Length n) {
  ASSERT(kMaxPages >= kMinSystemAlloc);
  if (n > kMaxValidPages) return false;
  Length ask = (n>kMinSystemAlloc) ? n : static_cast<Length>(kMinSystemAlloc);
  size_t actual_size;
  void* ptr = NULL;
  if (EnsureLimit(ask)) {
      ptr = TCMalloc_SystemAlloc(ask << kPageShift, &actual_size, kPageSize);
  }
  if (ptr == NULL) {
    if (n < ask) {
      // Try growing just "n" pages
      ask = n;
      if (EnsureLimit(ask)) {
        ptr = TCMalloc_SystemAlloc(ask << kPageShift, &actual_size, kPageSize);
      }
    }
    if (ptr == NULL) return false;
  }
  ask = actual_size >> kPageShift;
  RecordGrowth(ask << kPageShift);
  uint64_t old_system_bytes = stats_.system_bytes;
  stats_.system_bytes += (ask << kPageShift);
  const PageID p = reinterpret_cast<uintptr_t>(ptr) >> kPageShift;
  ASSERT(p > 0);
  // If we have already a lot of pages allocated, just pre allocate a bunch of
  // memory for the page map. This prevents fragmentation by pagemap metadata
  // when a program keeps allocating and freeing large blocks.
  if (old_system_bytes < kPageMapBigAllocationThreshold
      && stats_.system_bytes >= kPageMapBigAllocationThreshold) {
    pagemap_.PreallocateMoreMemory();
  }
  // Make sure pagemap_ has entries for all of the new pages.
  // Plus ensure one before and one after so coalescing code
  // does not need bounds-checking.
  if (pagemap_.Ensure(p-1, ask+2)) {
    // Pretend the new area is allocated and then Delete() it to cause
    // any necessary coalescing to occur.
    Span* span = NewSpan(p, ask);
    RecordSpan(span);
    Delete(span);
    ASSERT(Check());
    return true;
  } else {
    // We could not allocate memory within "pagemap_"
    // TODO: Once we can return memory to the system, return the new span
    return false;
  }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Outline_cellhd(View * view, struct Cell_head *cellhd)
{
    int row, col;
    int top, bottom, left, right;
    row = northing_to_row(&view->cell.head, cellhd->north) + .5;
    top = row_to_view(view, row);
    if (top < view->top)
	top = view->top;
    col = easting_to_col(&view->cell.head, cellhd->west) + .5;
    left = col_to_view(view, col);
    if (left < view->left)
	left = view->left;
    row = northing_to_row(&view->cell.head, cellhd->south) + .5;
    bottom = row_to_view(view, row);
    if (bottom > view->bottom)
	bottom = view->bottom;
    col = easting_to_col(&view->cell.head, cellhd->east) + .5;
    right = col_to_view(view, col);
    if (right > view->right)
	right = view->right;
    Outline_box(top, bottom, left, right);
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
img_set_blush(img, brush)
    VALUE img, brush;
{
    gdImagePtr im, br;
    Data_Get_Struct(img, gdImage, im);
    image_req(brush);
    Data_Get_Struct(brush, gdImage, br);
    gdImageSetBrush(im, br);
    return img;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
process_psqlrc(char *argv0)
{
	char		home[MAXPGPATH];
	char		rc_file[MAXPGPATH];
	char		my_exec_path[MAXPGPATH];
	char		etc_path[MAXPGPATH];
	find_my_exec(argv0, my_exec_path);
	get_etc_path(my_exec_path, etc_path);
	snprintf(rc_file, MAXPGPATH, "%s/%s", etc_path, SYSPSQLRC);
	process_psqlrc_file(rc_file);
	if (get_home_path(home))
	{
		snprintf(rc_file, MAXPGPATH, "%s/%s", home, PSQLRC);
		process_psqlrc_file(rc_file);
	}
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
page_width_set(int n)
{
    sub_context_ty  *scp;
    if (page_width)
    {
        arg_duplicate(arglex_token_page_width, 0);
        /* NOTREACHED */
    }
    if (n < MIN_PAGE_WIDTH || n > MAX_PAGE_WIDTH)
    {
        scp = sub_context_new();
        sub_var_set(scp, "Number", "%d", n);
        fatal_intl(scp, i18n("page width $number out of range"));
        /* NOTREACHED */
    }
    page_width = n;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
total_conflicts()
{
    fprintf(stderr, "%s: ", myname);
    if (SRtotal == 1)
	fprintf(stderr, "1 shift/reduce conflict");
    else if (SRtotal > 1)
	fprintf(stderr, "%d shift/reduce conflicts", SRtotal);
    if (SRtotal && RRtotal)
	fprintf(stderr, ", ");
    if (RRtotal == 1)
	fprintf(stderr, "1 reduce/reduce conflict");
    else if (RRtotal > 1)
	fprintf(stderr, "%d reduce/reduce conflicts", RRtotal);
    fprintf(stderr, ".\n");
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
opt3001_irq(int irq, void *_iio)
{
	struct iio_dev *iio = _iio;
	struct opt3001 *opt = iio_priv(iio);
	int ret;
	if (!opt->ok_to_ignore_lock)
		mutex_lock(&opt->lock);
	ret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);
	if (ret < 0) {
		dev_err(opt->dev, "failed to read register %02x\n",
				OPT3001_CONFIGURATION);
		goto out;
	}
	if ((ret & OPT3001_CONFIGURATION_M_MASK) ==
			OPT3001_CONFIGURATION_M_CONTINUOUS) {
		if (ret & OPT3001_CONFIGURATION_FH)
			iio_push_event(iio,
					IIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,
							IIO_EV_TYPE_THRESH,
							IIO_EV_DIR_RISING),
					iio_get_time_ns());
		if (ret & OPT3001_CONFIGURATION_FL)
			iio_push_event(iio,
					IIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,
							IIO_EV_TYPE_THRESH,
							IIO_EV_DIR_FALLING),
					iio_get_time_ns());
	} else if (ret & OPT3001_CONFIGURATION_CRF) {
		ret = i2c_smbus_read_word_swapped(opt->client, OPT3001_RESULT);
		if (ret < 0) {
			dev_err(opt->dev, "failed to read register %02x\n",
					OPT3001_RESULT);
			goto out;
		}
		opt->result = ret;
		opt->result_ready = true;
		wake_up(&opt->result_ready_queue);
	}
out:
	if (!opt->ok_to_ignore_lock)
		mutex_unlock(&opt->lock);
	return IRQ_HANDLED;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ReadHashItem_bin( const char *srcbuf, HASH_ITEM *pItem, int item_index )
{
	int len, i;
	const char *pc;
	memset( pItem, 0, sizeof(HASH_ITEM) );
	/* freq info */
	pItem->data.userfreq	= GetInt32(&srcbuf[ 0 ]);
	pItem->data.recentTime	= GetInt32(&srcbuf[ 4 ]);
	pItem->data.maxfreq	= GetInt32(&srcbuf[ 8 ]);
	pItem->data.origfreq	= GetInt32(&srcbuf[ 12 ]);
	/* phone seq, length in num of chi words */
	len = (int) srcbuf[ 16 ];
	pItem->data.phoneSeq = ALC( uint16_t, len + 1 );
	pc = &srcbuf[ 17 ];
	for ( i = 0; i < len; i++ ) {
		pItem->data.phoneSeq[ i ] = GetUint16( pc );
		pc += 2;
	}
	pItem->data.phoneSeq[ i ] = 0;
	/* phrase, length in num of bytes */
	pItem->data.wordSeq = ALC( char, (*pc) + 1 );
	strcpy( pItem->data.wordSeq, (char *) (pc + 1) );
	pItem->data.wordSeq[ (unsigned int) *pc ] = '\0';
	/* Invalid UTF-8 Chinese characters found */
	if ( ! isValidChineseString( pItem->data.wordSeq ) ) {
		goto ignore_corrupted_record;
	}
	/* set item_index */
	pItem->item_index = item_index;
	return 1; /* continue */
ignore_corrupted_record:
	if ( pItem->data.phoneSeq != NULL ) {
		free( pItem->data.phoneSeq );
		pItem->data.phoneSeq = NULL;
	}
	if ( pItem->data.wordSeq != NULL ) {
		free( pItem->data.wordSeq );
		pItem->data.wordSeq = NULL;
	}
	return -1; /* ignore */
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
add_frame_hooker(const char *arg)
{
    int argc = 0;
    char *argv[64];
    int i;
    char *args = av_strdup(arg);
    using_vhook = 1;
    argv[0] = strtok(args, " ");
    while (argc < 62 && (argv[++argc] = strtok(NULL, " "))) {
    }
    i = frame_hook_add(argc, argv);
    if (i != 0) {
        fprintf(stderr, "Failed to add video hook function: %s\n", arg);
        av_exit(1);
    }
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
lwline_serialize_buf(LWLINE *line, uchar *buf, size_t *retsize)
{
	char hasSRID;
	uchar *loc;
	int ptsize;
	size_t size;
	LWDEBUGF(2, "lwline_serialize_buf(%p, %p, %p) called",
		line, buf, retsize);
	if (line == NULL)
		lwerror("lwline_serialize:: given null line");
	if ( TYPE_GETZM(line->type) != TYPE_GETZM(line->points->dims) )
		lwerror("Dimensions mismatch in lwline");
	ptsize = pointArray_ptsize(line->points);
	hasSRID = (line->SRID != -1);
	buf[0] = (uchar) lwgeom_makeType_full(
		TYPE_HASZ(line->type), TYPE_HASM(line->type),
		hasSRID, LINETYPE, line->bbox ? 1 : 0);
	loc = buf+1;
	LWDEBUGF(3, "lwline_serialize_buf added type (%d)", line->type);
	if (line->bbox)
	{
		memcpy(loc, line->bbox, sizeof(BOX2DFLOAT4));
		loc += sizeof(BOX2DFLOAT4);
		LWDEBUG(3, "lwline_serialize_buf added BBOX");
	}
	if (hasSRID)
	{
		memcpy(loc, &line->SRID, sizeof(int32));
		loc += sizeof(int32);
		LWDEBUG(3, "lwline_serialize_buf added SRID");
	}
	memcpy(loc, &line->points->npoints, sizeof(uint32));
	loc += sizeof(uint32);
	LWDEBUGF(3, "lwline_serialize_buf added npoints (%d)",
		line->points->npoints);
	/*copy in points */
	size = line->points->npoints*ptsize;
	memcpy(loc, getPoint_internal(line->points, 0), size);
	loc += size;
	LWDEBUGF(3, "lwline_serialize_buf copied serialized_pointlist (%d bytes)",
		ptsize * line->points->npoints);
	if (retsize) *retsize = loc-buf;
	/*printBYTES((uchar *)result, loc-buf); */
	LWDEBUGF(3, "lwline_serialize_buf returning (loc: %p, size: %d)",
		loc, loc-buf);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
HasCategoryCooldown(uint32 spell_id) const
{
    SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell_id);
    if (!spellInfo)
        return false;
    CreatureSpellCooldowns::const_iterator itr = m_CreatureCategoryCooldowns.find(spellInfo->Category);
    return (itr != m_CreatureCategoryCooldowns.end() && time_t(itr->second + (spellInfo->CategoryRecoveryTime / IN_MILLISECONDS)) > time(NULL));
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
accept(ir_hierarchical_visitor *v)
{
   ir_visitor_status s = v->visit_enter(this);
   if (s != visit_continue)
      return (s == visit_continue_with_parent) ? visit_continue : s;
   s = this->val->accept(v);
   return (s == visit_stop) ? s : v->visit_leave(this);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cheaderwrite(struct cheader *ch, FILE *fpout)
{
	int error=0;
  	if(!fwrite((char *) &ch->sig, 4, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->res1, 4, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->size, 4, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->res2, 4, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->offsetfiles, 4, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->res3, 4, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->versionMIN, 1, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->versionMAJ, 1, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->nfolders, 2, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->nfiles, 2, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->flags, 2, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->setID, 2, 1, fpout)) error=1;
       	if(!fwrite((char *) &ch->cabID, 2, 1, fpout)) error=1;
	return !error;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
l3dss1_resume_ack(struct l3_process *pc, u_char pr, void *arg)
{
	struct sk_buff *skb = arg;
	int id, ret;
	if ((id = l3dss1_get_channel_id(pc, skb)) > 0) {
		if ((0 == id) || ((3 == id) && (0x10 == pc->para.moderate))) {
			if (pc->debug & L3_DEB_WARN)
				l3_debug(pc->st, "resume ack with wrong chid %x", id);
			pc->para.cause = 100;
			l3dss1_status_send(pc, pr, NULL);
			return;
		}
		pc->para.bchannel = id;
	} else if (1 == pc->state) {
		if (pc->debug & L3_DEB_WARN)
			l3_debug(pc->st, "resume ack without chid (ret %d)", id);
		pc->para.cause = 96;
		l3dss1_status_send(pc, pr, NULL);
		return;
	}
	ret = check_infoelements(pc, skb, ie_RESUME_ACKNOWLEDGE);
	if (ERR_IE_COMPREHENSION == ret) {
		l3dss1_std_ie_err(pc, ret);
		return;
	}
	L3DelTimer(&pc->timer);
	pc->st->l3.l3l4(pc->st, CC_RESUME | CONFIRM, pc);
	newl3state(pc, 10);
	if (ret) /* STATUS for none mandatory IE errors after actions are taken */
		l3dss1_std_ie_err(pc, ret);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (result) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
get_member_status(struct call_queue *q, int max_penalty, int min_penalty, enum empty_conditions conditions)
{
	struct member *member;
	struct ao2_iterator mem_iter;
	ao2_lock(q);
	mem_iter = ao2_iterator_init(q->members, 0);
	for (; (member = ao2_iterator_next(&mem_iter)); ao2_ref(member, -1)) {
		if ((max_penalty && (member->penalty > max_penalty)) || (min_penalty && (member->penalty < min_penalty))) {
			if (conditions & QUEUE_EMPTY_PENALTY) {
				ast_debug(4, "%s is unavailable because his penalty is not between %d and %d\n", member->membername, min_penalty, max_penalty);
				continue;
			}
		}
		switch (member->status) {
		case AST_DEVICE_INVALID:
			if (conditions & QUEUE_EMPTY_INVALID) {
				ast_debug(4, "%s is unavailable because his device state is 'invalid'\n", member->membername);
				break;
			}
			goto default_case;
		case AST_DEVICE_UNAVAILABLE:
			if (conditions & QUEUE_EMPTY_UNAVAILABLE) {
				ast_debug(4, "%s is unavailable because his device state is 'unavailable'\n", member->membername);
				break;
			}
			goto default_case;
		case AST_DEVICE_INUSE:
			if (conditions & QUEUE_EMPTY_INUSE) {
				ast_debug(4, "%s is unavailable because his device state is 'inuse'\n", member->membername);
				break;
			}
			goto default_case;
		case AST_DEVICE_RINGING:
			if (conditions & QUEUE_EMPTY_RINGING) {
				ast_debug(4, "%s is unavailable because his device state is 'ringing'\n", member->membername);
				break;
			}
			goto default_case;
		case AST_DEVICE_UNKNOWN:
			if (conditions & QUEUE_EMPTY_UNKNOWN) {
				ast_debug(4, "%s is unavailable because his device state is 'unknown'\n", member->membername);
				break;
			}
			/* Fall-through */
		default:
		default_case:
			if (member->paused && (conditions & QUEUE_EMPTY_PAUSED)) {
				ast_debug(4, "%s is unavailable because he is paused'\n", member->membername);
				break;
			} else if ((conditions & QUEUE_EMPTY_WRAPUP) && member->lastcall && q->wrapuptime && (time(NULL) - q->wrapuptime < member->lastcall)) {
				ast_debug(4, "%s is unavailable because it has only been %d seconds since his last call (wrapup time is %d)\n", member->membername, (int) (time(NULL) - member->lastcall), q->wrapuptime);
				break;
			} else {
				ao2_ref(member, -1);
				ao2_iterator_destroy(&mem_iter);
				ao2_unlock(q);
				ast_debug(4, "%s is available.\n", member->membername);
				return 0;
			}
			break;
		}
	}
	ao2_iterator_destroy(&mem_iter);
	ao2_unlock(q);
	return -1;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
test_gvariant (const void *_subject)
{
  const gchar *subject = (const gchar *) _subject;
  PolkitIdentity *identity, *new_identity;
  GError *error = NULL;
  GVariant *value;
  /* Create the subject from a string */
  identity = polkit_identity_from_string (subject, &error);
  g_assert_no_error (error);
  g_assert (identity);
  /* Create a GVariant for the subject */
  value = polkit_identity_to_gvariant (identity);
  g_assert (value);
  /* Unserialize the subject */
  new_identity = polkit_identity_new_for_gvariant (value, &error);
  g_assert_no_error (error);
  g_assert (new_identity);
  g_variant_unref (value);
  /* Make sure the two identities are equal */
  g_assert (new_identity);
  g_assert (polkit_identity_equal (identity, new_identity));
  g_object_unref (identity);
  g_object_unref (new_identity);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
copy_all_sub_arg_operand(Operand *opt)
{
    Operand     *npt = NULL, *opt_head = NULL;
    int         i;
    opt_head = opt;
    while (opt != NULL) {
        if(npt == NULL) {
            npt = alloc_operand();
            opt_head = npt;
        }
        npt->kind  = opt->kind;
        npt->entry = opt->entry;
	npt->nsub  = opt->nsub;
	if ((npt->sub = calloc(opt->nsub, sizeof(Sub_data*))) == NULL) {
	    fatal("No room for Sub_data.\n");
	}
        switch (opt->kind) {
            case KIND_VAR:
                npt->tbl.v = opt->tbl.v;
                break;
            case KIND_ARRAY:
                npt->tbl.a = copy_partial_array_table(opt->tbl.a,opt->entry);
                break;
            case KIND_CONST:
                npt->tbl.c = opt->tbl.c;
                break;
            default:
                npt->tbl.v = NULL;
        }
        for (i = 0; i < opt->nsub; i++) {
            if (opt->sub[i] != NULL)
                npt->sub[i] = copy_all_sub_data(opt->sub[i]);
        }
        npt->inner = copy_operand_list(opt->inner);
        if(opt->next != NULL) {
            npt->next = alloc_operand();
            npt = npt->next;
        }
    opt = opt->next;
    }
    npt = opt_head;
    return npt;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
findMatchingBlock(fl_BlockLayout * pBlock)
{
	TOCEntry * pThisEntry = NULL;
	fl_BlockLayout * pThisBL = NULL;
	UT_sint32 i = 0;
	bool bFound = false;
	for(i=0; i< m_vecEntries.getItemCount(); i++)
	{
		pThisEntry = m_vecEntries.getNthItem(i);
		pThisBL = pThisEntry->getBlock();
		if(pThisBL->getStruxDocHandle() == pBlock->getStruxDocHandle())
		{
			bFound = true;
			break;
		}
	}
	if(bFound)
	{
		return pThisBL;
	}
	return NULL;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
WaitOnLock(LOCALLOCK *locallock, ResourceOwner owner)
{
	LOCKMETHODID lockmethodid = LOCALLOCK_LOCKMETHOD(*locallock);
	LockMethod	lockMethodTable = LockMethods[lockmethodid];
	char	   *volatile new_status = NULL;
	LOCK_PRINT("WaitOnLock: sleeping on lock",
			   locallock->lock, locallock->tag.mode);
	/* Report change to waiting status */
	if (update_process_title)
	{
		const char *old_status;
		int			len;
		old_status = get_ps_display(&len);
		new_status = (char *) palloc(len + 8 + 1);
		memcpy(new_status, old_status, len);
		strcpy(new_status + len, " waiting");
		set_ps_display(new_status, false);
		new_status[len] = '\0'; /* truncate off " waiting" */
	}
	pgstat_report_waiting(true);
	awaitedLock = locallock;
	awaitedOwner = owner;
	/*
	 * NOTE: Think not to put any shared-state cleanup after the call to
	 * ProcSleep, in either the normal or failure path.  The lock state must
	 * be fully set by the lock grantor, or by CheckDeadLock if we give up
	 * waiting for the lock.  This is necessary because of the possibility
	 * that a cancel/die interrupt will interrupt ProcSleep after someone else
	 * grants us the lock, but before we've noticed it. Hence, after granting,
	 * the locktable state must fully reflect the fact that we own the lock;
	 * we can't do additional work on return.
	 *
	 * We can and do use a PG_TRY block to try to clean up after failure, but
	 * this still has a major limitation: elog(FATAL) can occur while waiting
	 * (eg, a "die" interrupt), and then control won't come back here. So all
	 * cleanup of essential state should happen in LockWaitCancel, not here.
	 * We can use PG_TRY to clear the "waiting" status flags, since doing that
	 * is unimportant if the process exits.
	 */
	PG_TRY();
	{
		if (ProcSleep(locallock, lockMethodTable) != STATUS_OK)
		{
			/*
			 * We failed as a result of a deadlock, see CheckDeadLock(). Quit
			 * now.
			 */
			awaitedLock = NULL;
			LOCK_PRINT("WaitOnLock: aborting on lock",
					   locallock->lock, locallock->tag.mode);
			LWLockRelease(LockHashPartitionLock(locallock->hashcode));
			/*
			 * Now that we aren't holding the partition lock, we can give an
			 * error report including details about the detected deadlock.
			 */
			DeadLockReport();
			/* not reached */
		}
	}
	PG_CATCH();
	{
		/* In this path, awaitedLock remains set until LockWaitCancel */
		/* Report change to non-waiting status */
		pgstat_report_waiting(false);
		if (update_process_title)
		{
			set_ps_display(new_status, false);
			pfree(new_status);
		}
		/* and propagate the error */
		PG_RE_THROW();
	}
	PG_END_TRY();
	awaitedLock = NULL;
	/* Report change to non-waiting status */
	pgstat_report_waiting(false);
	if (update_process_title)
	{
		set_ps_display(new_status, false);
		pfree(new_status);
	}
	LOCK_PRINT("WaitOnLock: wakeup on lock",
			   locallock->lock, locallock->tag.mode);
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
P_Getenv(Object e) {
    extern char *getenv();
    char *s;
    return (s = getenv(Get_String(e))) ? Make_String(s, strlen(s)) : False;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Is_Printable_String(const char *s)
{
  int result = TRUE;
#if USE_WIDEC_SUPPORT
  int count = mbstowcs(0, s, 0);
  wchar_t *temp = 0;
  assert(s);
  if (count > 0
      && (temp = typeCalloc(wchar_t, (2 + (unsigned)count))) != 0)
    {
      int n;
      mbstowcs(temp, s, (unsigned)count);
      for (n = 0; n < count; ++n)
	if (!iswprint((wint_t) temp[n]))
	  {
	    result = FALSE;
	    break;
	  }
      free(temp);
    }
#else
  assert(s);
  while (*s)
    {
      if (!isprint(UChar(*s)))
	{
	  result = FALSE;
	  break;
	}
      s++;
    }
#endif
  return result;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
setCurrentOption ( const std::string value )
{
     int action = parameterOption(value);
     if (action >= 0)
          currentKeyWord_ = action;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
glp_netgen_prob(int nprob, int parm[1+15])
{     int k;
      if (!(101 <= nprob && nprob <= 150))
         xerror("glp_netgen_prob: nprob = %d; invalid problem instance "
            "number\n", nprob);
      for (k = 1; k <= 15; k++)
         parm[k] = data[nprob-101][k];
      return;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
recv_response(struct ipmi_intf * intf, unsigned char *data, int len)
{
	char hex_rs[IPMI_SERIAL_MAX_RESPONSE * 3];
	int i, j, resp_len = 0;
	unsigned long rv;
	char *p, *pp;
	char ch, str_hex[3];
	p = hex_rs;
	while (1) {
		if ((rv = serial_read_line(intf, p, sizeof(hex_rs) - resp_len)) < 0) {
			/* error */
			return -1;
		}
		p += rv;
		resp_len += rv;
		if (*(p - 2) == ']' && (*(p - 1) == '\n' || *(p - 1) == '\r')) {
			*p = 0;
			break;
		}
	}
	p = strrchr(hex_rs, '[');
	if (!p) {
		lprintf(LOG_ERR, "Serial response is invalid");
		return -1;
	}
	p++;
	pp = strchr(p, ']');
	if (!pp) {
		lprintf(LOG_ERR, "Serial response is invalid");
		return -1;
	}
	*pp = 0;
	/* was it an error? */
	if (strncmp(p, "ERR ", 4) == 0) {
		serial_write_line(intf, "\r\r\r\r");
		sleep(1);
		serial_flush(intf);
		errno = 0;
		rv = strtoul(p + 4, &p, 16);
		if ((rv && rv < 0x100 && *p == '\0')
				|| (rv == 0 && !errno)) {
			/* The message didn't get it through. The upper
			   level will have to re-send */
			return 0;
		} else {
			lprintf(LOG_ERR, "Serial response is invalid");
			return -1;
		}
	}
	/* this is needed for correct string to long conversion */
	str_hex[2] = 0;
	/* parse the response */
	i = 0;
	j = 0;
	while (*p) {
		if (i >= len) {
			lprintf(LOG_ERR, "Serial response is too long(%d, %d)", i, len);
			return -1;
		}
		ch = *(p++);
		if (isxdigit(ch)) {
			str_hex[j++] = ch;
		} else {
			if (j == 1 || !isspace(ch)) {
				lprintf(LOG_ERR, "Serial response is invalid");
				return -1;
			}
		}
		if (j == 2) {
			unsigned long tmp;
			errno = 0;
			/* parse the hex number */
			tmp = strtoul(str_hex, NULL, 16);
			if ( tmp > 0xFF || ( !tmp && errno ) ) {
				lprintf(LOG_ERR, "Serial response is invalid");
				return -1;
			}
			data[i++] = tmp;
			j = 0;
		}
	}
	return i;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
tar_extract_glob(TAR *t, char *globname, char *prefix)
{
  char *filename;
  char buf[TAR_MAXPATHLEN];
  int i;
  char *pathname;
  while ((i = th_read(t)) == 0)
  {
    pathname = th_get_pathname(t);
    filename = pathname;
    if (fnmatch(globname, filename, FNM_PATHNAME | FNM_PERIOD))
    {
      if (pathname)
        {
        free(pathname);
        }
      if (TH_ISREG(t) && tar_skip_regfile(t))
        return -1;
      continue;
    }
    if (t->options & TAR_VERBOSE)
      th_print_long_ls(t);
    if (prefix != NULL)
      snprintf(buf, sizeof(buf), "%s/%s", prefix, filename);
    else
      strlcpy(buf, filename, sizeof(buf));
    if (tar_extract_file(t, filename) != 0)
      {
      if (pathname)
        {
        free(pathname);
        }
      return -1;
      }
    if (pathname)
      {
      free(pathname);
      }
  }
  return (i == 1 ? 0 : -1);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
krb5_pac_get_types(krb5_context context,
                   krb5_pac pac,
                   size_t *len,
                   krb5_ui_4 **types)
{
    size_t i;
    *types = (krb5_ui_4 *)malloc(pac->pac->cBuffers * sizeof(krb5_ui_4));
    if (*types == NULL)
        return ENOMEM;
    *len = pac->pac->cBuffers;
    for (i = 0; i < pac->pac->cBuffers; i++)
        (*types)[i] = pac->pac->Buffers[i].ulType;
    return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
check_and_set_new_selection (GthImageSelector      *self,
			     cairo_rectangle_int_t  new_selection)
{
	new_selection.width = MAX (0, new_selection.width);
	new_selection.height = MAX (0, new_selection.height);
	if (self->priv->bind_dimensions && (self->priv->bind_factor > 1)) {
		new_selection.width = bind_dimension (new_selection.width, self->priv->bind_factor);
		new_selection.height = bind_dimension (new_selection.height, self->priv->bind_factor);
	}
	if (((self->priv->current_area == NULL)
	     || (self->priv->current_area->id != C_SELECTION_AREA))
	    && self->priv->use_ratio)
	{
		if (! rectangle_in_rectangle (new_selection, self->priv->surface_area))
			return FALSE;
		set_selection (self, new_selection, FALSE);
		return TRUE;
	}
	/* self->priv->current_area->id == C_SELECTION_AREA */
	if (new_selection.x < 0)
		new_selection.x = 0;
	if (new_selection.y < 0)
		new_selection.y = 0;
	if (new_selection.width > self->priv->surface_area.width)
		new_selection.width = self->priv->surface_area.width;
	if (new_selection.height > self->priv->surface_area.height)
		new_selection.height = self->priv->surface_area.height;
	if (new_selection.x + new_selection.width > self->priv->surface_area.width)
		new_selection.x = self->priv->surface_area.width - new_selection.width;
	if (new_selection.y + new_selection.height > self->priv->surface_area.height)
		new_selection.y = self->priv->surface_area.height - new_selection.height;
	set_selection (self, new_selection, FALSE);
	return TRUE;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
store( QDomNode & node, QDomDocument & document ) const
{
    // store base annotation properties
    storeBaseAnnotationProperties( node, document );
    // create [line] element
    QDomElement lineElement = document.createElement( "line" );
    node.appendChild( lineElement );
    // store the attributes
    if ( lineStartStyle() != None )
        lineElement.setAttribute( "startStyle", (int)lineStartStyle() );
    if ( lineEndStyle() != None )
        lineElement.setAttribute( "endStyle", (int)lineEndStyle() );
    if ( isLineClosed() )
        lineElement.setAttribute( "closed", isLineClosed() );
    if ( lineInnerColor().isValid() )
        lineElement.setAttribute( "innerColor", lineInnerColor().name() );
    if ( lineLeadingForwardPoint() != 0.0 )
        lineElement.setAttribute( "leadFwd", QString::number( lineLeadingForwardPoint() ) );
    if ( lineLeadingBackPoint() != 0.0 )
        lineElement.setAttribute( "leadBack", QString::number( lineLeadingBackPoint() ) );
    if ( lineShowCaption() )
        lineElement.setAttribute( "showCaption", lineShowCaption() );
    if ( lineIntent() != Unknown )
        lineElement.setAttribute( "intent", lineIntent() );
    // append the list of points
    const QLinkedList<QPointF> points = linePoints();
    if ( points.count() > 1 )
    {
        QLinkedList<QPointF>::const_iterator it = points.begin(), end = points.end();
        while ( it != end )
        {
            const QPointF & p = *it;
            QDomElement pElement = document.createElement( "point" );
            lineElement.appendChild( pElement );
            pElement.setAttribute( "x", QString::number( p.x() ) );
            pElement.setAttribute( "y", QString::number( p.y() ) );
            ++it;
        }
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ldapu_propval_alloc (const char *prop, const char *val,
				      LDAPUPropVal_t **propval)
{
    *propval = (LDAPUPropVal_t *)malloc(sizeof(LDAPUPropVal_t));
    if (!*propval) return LDAPU_ERR_OUT_OF_MEMORY;
    (*propval)->prop = prop ? strdup(prop) : 0;
    (*propval)->val = val ? strdup(val) : 0;
    if ((!prop || (*propval)->prop) && (!val || (*propval)->val)) {
	/* strdup worked */
	return LDAPU_SUCCESS;
    }
    else {
	return LDAPU_ERR_OUT_OF_MEMORY;
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
register_isdn(isdn_if *i)
{
	isdn_driver_t *d;
	int j;
	ulong flags;
	int drvidx;
	if (dev->drivers >= ISDN_MAX_DRIVERS) {
		printk(KERN_WARNING "register_isdn: Max. %d drivers supported\n",
		       ISDN_MAX_DRIVERS);
		return 0;
	}
	if (!i->writebuf_skb) {
		printk(KERN_WARNING "register_isdn: No write routine given.\n");
		return 0;
	}
	if (!(d = kzalloc(sizeof(isdn_driver_t), GFP_KERNEL))) {
		printk(KERN_WARNING "register_isdn: Could not alloc driver-struct\n");
		return 0;
	}
	d->maxbufsize = i->maxbufsize;
	d->pktcount = 0;
	d->stavail = 0;
	d->flags = DRV_FLAG_LOADED;
	d->online = 0;
	d->interface = i;
	d->channels = 0;
	spin_lock_irqsave(&dev->lock, flags);
	for (drvidx = 0; drvidx < ISDN_MAX_DRIVERS; drvidx++)
		if (!dev->drv[drvidx])
			break;
	if (isdn_add_channels(d, drvidx, i->channels, 0)) {
		spin_unlock_irqrestore(&dev->lock, flags);
		kfree(d);
		return 0;
	}
	i->channels = drvidx;
	i->rcvcallb_skb = isdn_receive_skb_callback;
	i->statcallb = isdn_status_callback;
	if (!strlen(i->id))
		sprintf(i->id, "line%d", drvidx);
	for (j = 0; j < drvidx; j++)
		if (!strcmp(i->id, dev->drvid[j]))
			sprintf(i->id, "line%d", drvidx);
	dev->drv[drvidx] = d;
	strcpy(dev->drvid[drvidx], i->id);
	isdn_info_update();
	dev->drivers++;
	set_global_features();
	spin_unlock_irqrestore(&dev->lock, flags);
	return 1;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
modem_check_result(char *have, char *need)
{
	char	line[MODEM_BUFFER_LEN + 1];
	char *word;
	char *more;
	int	nr;
	log_line(L_DEBUG, "Waiting for \"");
	log_code(L_DEBUG, need);
	log_text(L_DEBUG, "\"... ");
	xstrncpy(line, need, MODEM_BUFFER_LEN);
	more	= strchr(line, '|');
	word	= strtok(line, "|");
	nr		= 0;
	while (word)
	{
		nr++;
		if (strncmp(have, word, strlen(word)) == 0)
		{
			if (more)
			{
				log_text(L_DEBUG, "Got \"");
				log_code(L_DEBUG, word);
				log_text(L_DEBUG, "\" (%d).\n", nr);
			}
			else log_text(L_DEBUG, "Got it.\n");
			return(nr);
		}
		word = strtok(NULL, "|");
	}
	log_text(L_DEBUG, "Oops!\n");
	return(0);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
port_parser(struct nv_pair *nv, int line, plugin_conf_t * c)
{
        const char *ptr = nv->value;
        unsigned long i;
        /* check that all chars are numbers */
        for (i = 0; ptr[i]; i++) {
                if (!isdigit(ptr[i])) {
                        log_err("Value %s should only be numbers - line %d", nv->value, line);
                        return 1;
                }
        }
        /* convert to unsigned long */
        errno = 0;
        i = strtoul(nv->value, NULL, 10);
        if (errno) {
                log_err("Error converting string to a number (%s) - line %d", strerror(errno), line);
                return 1;
        }
        c->port = i;
        return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
write_attr_value (struct attr_desc *attr, rtx value)
{
  int op;
  switch (GET_CODE (value))
    {
    case CONST_STRING:
      write_attr_valueq (attr, XSTR (value, 0));
      break;
    case CONST_INT:
      printf (HOST_WIDE_INT_PRINT_DEC, INTVAL (value));
      break;
    case SYMBOL_REF:
      fputs (XSTR (value, 0), stdout);
      break;
    case ATTR:
      {
	struct attr_desc *attr2 = find_attr (&XSTR (value, 0), 0);
	printf ("get_attr_%s (%s)", attr2->name,
		(attr2->is_const ? "" : "insn"));
      }
      break;
    case PLUS:
      op = '+';
      goto do_operator;
    case MINUS:
      op = '-';
      goto do_operator;
    case MULT:
      op = '*';
      goto do_operator;
    case DIV:
      op = '/';
      goto do_operator;
    case MOD:
      op = '%';
      goto do_operator;
    do_operator:
      write_attr_value (attr, XEXP (value, 0));
      putchar (' ');
      putchar (op);
      putchar (' ');
      write_attr_value (attr, XEXP (value, 1));
      break;
    default:
      abort ();
    }
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
ec_GFp_mont_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
	{
	if (group->field_data1 == NULL)
		{
		ECerr(EC_F_EC_GFP_MONT_FIELD_MUL, EC_R_NOT_INITIALIZED);
		return 0;
		}
	return BN_mod_mul_montgomery(r, a, b, group->field_data1, ctx);
	}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
param_extract(Table *tb, char *line)
{
  //tb->theta0 = 180.0; <- equilibrium angles not supported
  tb->ninput = 0;
  tb->f_unspecified = false; //default
  tb->use_degrees   = true;  //default
  char *word = strtok(line," \t\n\r\f");
  while (word) {
    if (strcmp(word,"N") == 0) {
      word = strtok(NULL," \t\n\r\f");
      tb->ninput = atoi(word);
    }
    else if (strcmp(word,"NOF") == 0) {
      tb->f_unspecified = true;
    }
    else if ((strcmp(word,"DEGREES") == 0) || (strcmp(word,"degrees") == 0)) {
      tb->use_degrees = true;
    }
    else if ((strcmp(word,"RADIANS") == 0) || (strcmp(word,"radians") == 0)) {
      tb->use_degrees = false;
    }
    else if (strcmp(word,"CHECKU") == 0) {
      word = strtok(NULL," \t\n\r\f");
      memory->sfree(checkU_fname);
      memory->create(checkU_fname,strlen(word),"dihedral_table:checkU");
      strcpy(checkU_fname, word);
    }
    else if (strcmp(word,"CHECKF") == 0) {
      word = strtok(NULL," \t\n\r\f");
      memory->sfree(checkF_fname);
      memory->create(checkF_fname,strlen(word),"dihedral_table:checkF");
      strcpy(checkF_fname, word);
    }
    // COMMENTING OUT:  equilibrium angles are not supported
    //else if (strcmp(word,"EQ") == 0) {
    //  word = strtok(NULL," \t\n\r\f");
    //  tb->theta0 = atof(word);
    //}
    else {
      string err_msg("Invalid keyword in dihedral angle table parameters");
      err_msg += string(" (") + string(word) + string(")");
      error->one(FLERR,err_msg.c_str());
    }
    word = strtok(NULL," \t\n\r\f");
  }
  if (tb->ninput == 0)
    error->one(FLERR,"Dihedral table parameters did not set N");
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
map_get_key(struct battery_property_map *map, int value,
				const char *def_key)
{
	while (map->key) {
		if (map->value == value)
			return map->key;
		map++;
	}
	return def_key;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
changeCoordinatesReference( const CPose3D &newReferenceBase )
{
	MRPT_START
	switch (m_typePDF)
	{
	case pdfMonteCarlo:	m_locationMC.changeCoordinatesReference(newReferenceBase);		break;
	case pdfGauss:		m_locationGauss.changeCoordinatesReference(newReferenceBase);	break;
	case pdfSOG:		m_locationSOG.changeCoordinatesReference(newReferenceBase);		break;
	default:			THROW_EXCEPTION("ERROR: Invalid 'm_typePDF' value");
	};
	MRPT_END
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
describe_origin(textblock *tb, const object_type *o_ptr)
{
	char origin_text[80];
	if (o_ptr->origin_depth)
		strnfmt(origin_text, sizeof(origin_text), "%d feet (level %d)",
		        o_ptr->origin_depth * 50, o_ptr->origin_depth);
	else
		my_strcpy(origin_text, "town", sizeof(origin_text));
	switch (o_ptr->origin)
	{
		case ORIGIN_NONE:
		case ORIGIN_MIXED:
		case ORIGIN_STOLEN:
			return FALSE;
		case ORIGIN_BIRTH:
			textblock_append(tb, "An inheritance from your family.\n");
			break;
		case ORIGIN_STORE:
			textblock_append(tb, "Bought from a store.\n");
			break;
		case ORIGIN_FLOOR:
			textblock_append(tb, "Found lying on the floor %s %s.\n",
			         (o_ptr->origin_depth ? "at" : "in"),
			         origin_text);
 			break;
		case ORIGIN_PIT:
			textblock_append(tb, "Found lying on the floor in a pit at %s.\n",
			         origin_text);
 			break;
		case ORIGIN_VAULT:
			textblock_append(tb, "Found lying on the floor in a vault at %s.\n",
			         origin_text);
 			break;
		case ORIGIN_SPECIAL:
			textblock_append(tb, "Found lying on the floor of a special room at %s.\n",
			         origin_text);
 			break;
		case ORIGIN_LABYRINTH:
			textblock_append(tb, "Found lying on the floor of a labyrinth at %s.\n",
			         origin_text);
 			break;
		case ORIGIN_CAVERN:
			textblock_append(tb, "Found lying on the floor of a cavern at %s.\n",
			         origin_text);
 			break;
		case ORIGIN_RUBBLE:
			textblock_append(tb, "Found under some rubble at %s.\n",
			         origin_text);
 			break;
		case ORIGIN_DROP:
		case ORIGIN_DROP_SPECIAL:
		case ORIGIN_DROP_PIT:
		case ORIGIN_DROP_VAULT:
		case ORIGIN_DROP_SUMMON:
		case ORIGIN_DROP_BREED:
		case ORIGIN_DROP_POLY:
		case ORIGIN_DROP_WIZARD:
		{
			const char *name;
			if (r_info[o_ptr->origin_xtra].ridx)
				name = r_info[o_ptr->origin_xtra].name;
			else
				name = "monster lost to history";
			textblock_append(tb, "Dropped by ");
			if (rf_has(r_info[o_ptr->origin_xtra].flags, RF_UNIQUE))
				textblock_append(tb, "%s", name);
			else
				textblock_append(tb, "%s%s",
						is_a_vowel(name[0]) ? "an " : "a ", name);
			textblock_append(tb, " %s %s.\n",
					(o_ptr->origin_depth ? "at" : "in"),
					origin_text);
 			break;
		}
		case ORIGIN_DROP_UNKNOWN:
			textblock_append(tb, "Dropped by an unknown monster %s %s.\n",
					(o_ptr->origin_depth ? "at" : "in"),
					origin_text);
			break;
		case ORIGIN_ACQUIRE:
			textblock_append(tb, "Conjured forth by magic %s %s.\n",
					(o_ptr->origin_depth ? "at" : "in"),
					origin_text);
 			break;
		case ORIGIN_CHEAT:
			textblock_append(tb, "Created by debug option.\n");
 			break;
		case ORIGIN_CHEST:
			textblock_append(tb, "Found in a chest from %s.\n",
			         origin_text);
			break;
	}
	textblock_append(tb, "\n");
	return TRUE;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
fdisk_sun_set_xcyl(struct fdisk_context *cxt)
{
	struct sun_disklabel *sunlabel = self_disklabel(cxt);
	uintmax_t res;
	int rc = fdisk_ask_number(cxt, 0,			/* low */
			be16_to_cpu(sunlabel->apc),		/* default */
			cxt->geom.sectors,			/* high */
			_("Extra sectors per cylinder"),	/* query */
			&res);					/* result */
	if (rc)
		return rc;
	sunlabel->apc = cpu_to_be16(res);
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
mb862xx_pci_remove(struct pci_dev *pdev)
{
	struct fb_info *fbi = pci_get_drvdata(pdev);
	struct mb862xxfb_par *par = fbi->par;
	unsigned long reg;
	dev_dbg(fbi->dev, "%s release\n", fbi->fix.id);
	/* display off */
	reg = inreg(disp, GC_DCM1);
	reg &= ~(GC_DCM01_DEN | GC_DCM01_L0E);
	outreg(disp, GC_DCM1, reg);
	if (par->type == BT_CARMINE) {
		outreg(ctrl, GC_CTRL_INT_MASK, 0);
		outreg(ctrl, GC_CTRL_CLK_ENABLE, 0);
	} else {
		outreg(host, GC_IMASK, 0);
	}
	mb862xx_i2c_exit(par);
	device_remove_file(&pdev->dev, &dev_attr_dispregs);
	unregister_framebuffer(fbi);
	fb_dealloc_cmap(&fbi->cmap);
	free_irq(par->irq, (void *)par);
	iounmap(par->mmio_base);
	iounmap(par->fb_base);
	pci_release_regions(pdev);
	framebuffer_release(fbi);
	pci_disable_device(pdev);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,
				 void (*work_func)(struct work_struct *work))
{
	acpi_status status = AE_ALREADY_EXISTS;
	if (!dev && !work_func)
		return AE_BAD_PARAMETER;
	mutex_lock(&acpi_pm_notifier_lock);
	if (adev->wakeup.flags.notifier_present)
		goto out;
	adev->wakeup.ws = wakeup_source_register(dev_name(&adev->dev));
	adev->wakeup.context.dev = dev;
	if (work_func)
		INIT_WORK(&adev->wakeup.context.work, work_func);
	status = acpi_install_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,
					     acpi_pm_notify_handler, NULL);
	if (ACPI_FAILURE(status))
		goto out;
	adev->wakeup.flags.notifier_present = true;
 out:
	mutex_unlock(&acpi_pm_notifier_lock);
	return status;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
shutdown(){
  if (started) {
    mutex_data.lock();
    flags|=FLAG_SHUTDOWN;
    mutex_data.unlock();
    wakeup();
    join();
    started=false;
    }
  /// Save Session
  FXApp::instance()->reg().writeStringEntry("LastFM","session",session.text());
  FXApp::instance()->reg().writeBoolEntry("LastFM","client-banned",(flags&FLAG_BANNED));
  }
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
amdgpu_uvd_resume(struct amdgpu_device *adev)
{
	unsigned size;
	void *ptr;
	const struct common_firmware_header *hdr;
	unsigned offset;
	if (adev->uvd.vcpu_bo == NULL)
		return -EINVAL;
	hdr = (const struct common_firmware_header *)adev->uvd.fw->data;
	offset = le32_to_cpu(hdr->ucode_array_offset_bytes);
	memcpy(adev->uvd.cpu_addr, (adev->uvd.fw->data) + offset,
		(adev->uvd.fw->size) - offset);
	cancel_delayed_work_sync(&adev->uvd.idle_work);
	size = amdgpu_bo_size(adev->uvd.vcpu_bo);
	size -= le32_to_cpu(hdr->ucode_size_bytes);
	ptr = adev->uvd.cpu_addr;
	ptr += le32_to_cpu(hdr->ucode_size_bytes);
	memset(ptr, 0, size);
	return 0;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
guilddb_txt_delete_sub(void *key, void *data, va_list ap)
{
	struct guild *g = (struct guild *)data;
	int guild_id = va_arg(ap, int);
	int i;
	for(i = 0; i < MAX_GUILDALLIANCE; i++) {
		if(g->alliance[i].guild_id == guild_id)
		{
			g->alliance[i].guild_id = 0;
#ifdef TXT_JOURNAL
			if( guild_journal_enable )
				journal_write( &guild_journal, g->guild_id, g );
#endif
		}
	}
	return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
is_dhcp_discover(void *wh, int len)
{
    if( (memcmp(wh+4, BROADCAST, 6) == 0 || memcmp(wh+16, BROADCAST, 6) == 0) && (len >= 360 - 24 - 4 - 4 && len <= 380 - 24 - 4 - 4 )  )
        return 1;
    return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
Pop(vtkIdType location, double &priority)
{
  vtkIdType id, i, j, idx;
  vtkPriorityQueue::Item temp;
  if ( this->MaxId < 0 )
    {
    return -1;
    }
  id = this->Array[location].id;
  priority = this->Array[location].priority;
  // move the last item to the location specified and push into the tree
  this->Array[location].id = this->Array[this->MaxId].id;
  this->Array[location].priority = this->Array[this->MaxId].priority;
  this->ItemLocation->SetValue(this->Array[location].id,location);
  this->ItemLocation->SetValue(id,-1);
  if ( --this->MaxId <= 0 )
    {
    return id;
    }
  // percolate down the tree from the specified location
  int lastNodeToCheck = (this->MaxId-1)/2;
  for ( j=0, i=location; i <= lastNodeToCheck; i=j )
    {
    idx = 2*i + 1;
    if ( this->Array[idx].priority < this->Array[idx+1].priority || 
         idx == this->MaxId )
      {
      j = idx;
      }
    else
      {
      j = idx + 1;
      }
    if ( this->Array[i].priority > this->Array[j].priority )
      {
      temp = this->Array[i];
      this->ItemLocation->SetValue(temp.id,j);
      this->Array[i] = this->Array[j];
      this->ItemLocation->SetValue(this->Array[j].id,i);
      this->Array[j] = temp;
      }
    else
      {
      break;
      }
    }
  // percolate up the tree from the specified location
  for ( idx=0, i=location; i > 0; i=idx )
    {
    idx = (i-1)/2;
    if ( this->Array[i].priority < this->Array[idx].priority )
      {
      temp = this->Array[i];
      this->ItemLocation->SetValue(temp.id,idx);
      this->Array[i] = this->Array[idx];
      this->ItemLocation->SetValue(this->Array[idx].id,i);
      this->Array[idx] = temp;
      }
    else
      {
      break;
      }
    }
  return id;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
width(bool constrained)
{
    unsigned int sz = 0;
    if (constrained) {
    	if (d_array_var->send_p())
    		sz = d_array_var->width(constrained);
    }
    else {
    	sz = d_array_var->width(constrained);
    }
    for (Map_iter i = d_map_vars.begin(); i != d_map_vars.end(); i++) {
    	if (constrained) {
    		if ((*i)->send_p())
    			sz += (*i)->width(constrained);
    	}
    	else {
    		sz += (*i)->width(constrained);
    	}
    }
    return sz;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
AnalyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,
                              MachineBasicBlock *&FBB,
                              SmallVectorImpl<MachineOperand> &Cond,
                              bool AllowModify) const {
  // If the block has no terminators, it just falls into the block after it.
  MachineBasicBlock::iterator I = MBB.getLastNonDebugInstr();
  if (I == MBB.end())
    return false;
  if (!isUnpredicatedTerminator(I))
    return false;
  // Get the last instruction in the block.
  MachineInstr *LastInst = I;
  // If there is only one terminator instruction, process it.
  if (I == MBB.begin() || !isUnpredicatedTerminator(--I)) {
    if (IsBRU(LastInst->getOpcode())) {
      TBB = LastInst->getOperand(0).getMBB();
      return false;
    }
    XCore::CondCode BranchCode = GetCondFromBranchOpc(LastInst->getOpcode());
    if (BranchCode == XCore::COND_INVALID)
      return true;  // Can't handle indirect branch.
    // Conditional branch
    // Block ends with fall-through condbranch.
    TBB = LastInst->getOperand(1).getMBB();
    Cond.push_back(MachineOperand::CreateImm(BranchCode));
    Cond.push_back(LastInst->getOperand(0));
    return false;
  }
  // Get the instruction before it if it's a terminator.
  MachineInstr *SecondLastInst = I;
  // If there are three terminators, we don't know what sort of block this is.
  if (SecondLastInst && I != MBB.begin() &&
      isUnpredicatedTerminator(--I))
    return true;
  unsigned SecondLastOpc    = SecondLastInst->getOpcode();
  XCore::CondCode BranchCode = GetCondFromBranchOpc(SecondLastOpc);
  // If the block ends with conditional branch followed by unconditional,
  // handle it.
  if (BranchCode != XCore::COND_INVALID
    && IsBRU(LastInst->getOpcode())) {
    TBB = SecondLastInst->getOperand(1).getMBB();
    Cond.push_back(MachineOperand::CreateImm(BranchCode));
    Cond.push_back(SecondLastInst->getOperand(0));
    FBB = LastInst->getOperand(0).getMBB();
    return false;
  }
  // If the block ends with two unconditional branches, handle it.  The second
  // one is not executed, so remove it.
  if (IsBRU(SecondLastInst->getOpcode()) && 
      IsBRU(LastInst->getOpcode())) {
    TBB = SecondLastInst->getOperand(0).getMBB();
    I = LastInst;
    if (AllowModify)
      I->eraseFromParent();
    return false;
  }
  // Likewise if it ends with a branch table followed by an unconditional branch.
  if (IsBR_JT(SecondLastInst->getOpcode()) && IsBRU(LastInst->getOpcode())) {
    I = LastInst;
    if (AllowModify)
      I->eraseFromParent();
    return true;
  }
  // Otherwise, can't handle this.
  return true;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
MG_s_free_mem(MG_S_INFO *mg_s_info)
{
  FUNCNAME("MG_s_free_mem");
  MULTI_GRID_INFO  *mg_info = NULL;
  int levels, i, *dofs_per_level;
  TEST_EXIT(mg_s_info && (mg_info = mg_s_info->mg_info),
    "no mg_s_info or mg_info\n");
  TEST_EXIT(dofs_per_level = mg_s_info->dofs_per_level,
    "no dofs_per_level\n");
  levels = mg_info->mg_levels;
  /* fine grid matrix uses rows from mg_s_info->mat */
  for (i=0; i<mg_s_info->matrix[levels-1]->size; i++)
    mg_s_info->matrix[levels-1]->matrix_row[i] = nil;
  for (i = levels-1; i >= 0; i--)
  {
    MEM_FREE(mg_s_info->r_h[i], dofs_per_level[i], REAL);
    MEM_FREE(mg_s_info->u_h[i], dofs_per_level[i], REAL);
    MEM_FREE(mg_s_info->f_h[i], dofs_per_level[i], REAL);
    free_dof_matrix(mg_s_info->matrix[i]);
  }
  MEM_FREE(mg_s_info->dofs_per_level, mg_s_info->size, int);
  MEM_FREE(mg_s_info->r_h, mg_s_info->size, REAL *);
  MEM_FREE(mg_s_info->u_h, mg_s_info->size, REAL *);
  MEM_FREE(mg_s_info->f_h, mg_s_info->size, REAL *);
  MEM_FREE(mg_s_info->matrix, mg_s_info->size, DOF_MATRIX *);
  MEM_FREE(mg_s_info->sort_dof_invers, mg_s_info->sort_invers_size, int);
  MEM_FREE(mg_s_info->sort_bound, mg_s_info->sort_size, S_CHAR);
  MEM_FREE(mg_s_info->dof_level, mg_s_info->sort_size, U_CHAR);
  MEM_FREE(mg_s_info->dof_parent[1], mg_s_info->sort_size, DOF);
  MEM_FREE(mg_s_info->dof_parent[0], mg_s_info->sort_size, DOF);
  MEM_FREE(mg_s_info->sort_dof, mg_s_info->sort_size, int);
  mg_s_info->sort_dof_invers = nil;
  mg_s_info->dofs_per_level = nil;
  mg_s_info->f_h = mg_s_info->u_h = mg_s_info->r_h = nil;
  mg_s_info->matrix = nil;
  mg_s_info->sort_dof_invers = nil;
  mg_s_info->sort_bound = nil;
  mg_s_info->dof_level = nil;
  mg_s_info->dof_parent[0] = mg_s_info->dof_parent[1] = nil;
  mg_s_info->sort_dof = nil;
  mg_s_info->size = 0;
  mg_s_info->sort_size = 0;
  mg_s_info->sort_invers_size = 0;
  return;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
est_border_str(void){
  static int first = TRUE;
  static char border[ESTPATHBUFSIZ];
  int t, p;
  if(first){
    t = (int)(time(NULL) + est_random() * INT_MAX);
    p = (int)(getpid() + est_random() * INT_MAX);
    sprintf(border, "--------[%08X%08X]--------",
            dpouterhash((char *)&t, sizeof(int)), dpouterhash((char *)&p, sizeof(int)));
    first = FALSE;
  }
  return border;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
repo_init_structure(const char *git_dir, int is_bare)
{
	const int mode = 0755; /* or 0777 ? */
	int error;
	char temp_path[GIT_PATH_MAX];
	if (git_futils_mkdir_r(git_dir, mode))
		return git__throw(GIT_ERROR, "Failed to initialize repository structure. Could not mkdir");
	/* Hides the ".git" directory */
	if (!is_bare) {
#ifdef GIT_WIN32
		error = p_hide_directory__w32(git_dir);
		if (error < GIT_SUCCESS)
			return git__rethrow(error, "Failed to initialize repository structure");
#endif
	}
	/* Creates the '/objects/info/' directory */
	git_path_join(temp_path, git_dir, GIT_OBJECTS_INFO_DIR);
	error = git_futils_mkdir_r(temp_path, mode);
	if (error < GIT_SUCCESS)
		return git__rethrow(error, "Failed to initialize repository structure");
	/* Creates the '/objects/pack/' directory */
	git_path_join(temp_path, git_dir, GIT_OBJECTS_PACK_DIR);
	error = p_mkdir(temp_path, mode);
	if (error < GIT_SUCCESS)
		return git__throw(error, "Unable to create `%s` folder", temp_path);
	/* Creates the '/refs/heads/' directory */
	git_path_join(temp_path, git_dir, GIT_REFS_HEADS_DIR);
	error = git_futils_mkdir_r(temp_path, mode);
	if (error < GIT_SUCCESS)
		return git__rethrow(error, "Failed to initialize repository structure");
	/* Creates the '/refs/tags/' directory */
	git_path_join(temp_path, git_dir, GIT_REFS_TAGS_DIR);
	error = p_mkdir(temp_path, mode);
	if (error < GIT_SUCCESS)
		return git__throw(error, "Unable to create `%s` folder", temp_path);
	/* TODO: what's left? templates? */
	return GIT_SUCCESS;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
isUpper(const std::string &str)
{
    for (unsigned int i = 0; i < str.length(); ++i)
    {
        if (str[i] >= 'a' && str[i] <= 'z')
            return false;
    }
    return true;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
glmWeld(GLMmodel* model, float epsilon)
{
  float* vectors;
  float* copies;
  unsigned int   numvectors;
  unsigned int   i, welded;
  /* vertices */
  numvectors = model->numvertices;
  vectors    = model->vertices;
  copies = glmWeldVectors(vectors, &numvectors, epsilon);
  welded = model->numvertices - numvectors - 1;
  for (i = 0; i < model->numtriangles; i++) {
    T(i).vindices[0] = (unsigned int)vectors[3 * T(i).vindices[0] + 0];
    T(i).vindices[1] = (unsigned int)vectors[3 * T(i).vindices[1] + 0];
    T(i).vindices[2] = (unsigned int)vectors[3 * T(i).vindices[2] + 0];
  }
  /* free space for old vertices */
  free(vectors);
  /* allocate space for the new vertices */
  model->numvertices = numvectors;
  model->vertices = (float*)malloc(sizeof(float) *
				     3 * (model->numvertices + 1));
  /* copy the optimized vertices into the actual vertex list */
  for (i = 1; i <= model->numvertices; i++) {
    model->vertices[3 * i + 0] = copies[3 * i + 0];
    model->vertices[3 * i + 1] = copies[3 * i + 1];
    model->vertices[3 * i + 2] = copies[3 * i + 2];
  }
  free(copies);
  return welded;
}
CWE-119  False
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
on_key_press_event(GtkWidget* widget, GdkEventKey* evt)
{
    GtkTreeView* tree_view = GTK_TREE_VIEW(widget);
    GtkTreeSelection* tree_sel;
    GtkTreeModel* model;
    GtkTreeIter it;
    GtkTreePath* tp;
//    int modifier = (evt->state & gtk_accelerator_get_default_mod_mask());
    switch(evt->keyval)
    {
    case GDK_KEY_Left:
        tree_sel = gtk_tree_view_get_selection(tree_view);
        if(gtk_tree_selection_get_selected(tree_sel, &model, &it))
        {
            tp = gtk_tree_model_get_path(model, &it);
            if(gtk_tree_view_row_expanded(tree_view, tp))
                gtk_tree_view_collapse_row(tree_view, tp);
            else
            {
                gtk_tree_path_up(tp);
                gtk_tree_view_set_cursor(tree_view, tp, NULL, FALSE);
                gtk_tree_selection_select_path(tree_sel, tp);
            }
            gtk_tree_path_free(tp);
        }
        break;
    case GDK_KEY_Right:
        tree_sel = gtk_tree_view_get_selection(tree_view);
        if(gtk_tree_selection_get_selected(tree_sel, &model, &it))
        {
            tp = gtk_tree_model_get_path(model, &it);
            gtk_tree_view_expand_row(tree_view, tp, FALSE);
            gtk_tree_path_free(tp);
        }
        break;
#if 0
    /* if we support Menu key then we should also position the menu right at item */
    case GDK_KEY_Menu:
        if (modifier)
            break;
        tree_sel = gtk_tree_view_get_selection(tree_view);
        if(gtk_tree_selection_get_selected(tree_sel, &model, &it))
            fm_dir_tree_view_item_popup(widget, model, &it, evt->time);
        break;
    case GDK_KEY_F10:
        if (modifier != GDK_SHIFT_MASK)
            break;
        tree_sel = gtk_tree_view_get_selection(tree_view);
        if(gtk_tree_selection_get_selected(tree_sel, &model, &it))
            fm_dir_tree_view_item_popup(widget, model, &it, evt->time);
        break;
#endif
    }
    return GTK_WIDGET_CLASS(fm_dir_tree_view_parent_class)->key_press_event(widget, evt);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
pdb_read_rec_by_id(pdbfile *fin, const gbuint32 rec_id, gbuint8 *flags, gbuint8 *category, void **data)
{
  pdbrec_t *rec;
  for (rec = fin->rec_list; rec; rec = rec->next) {
    if (rec->id == rec_id) {
      if (data) {
        *data = rec->data;
      }
      if (flags) {
        *flags = rec->flags;
      }
      if (category) {
        *category = rec->category;
      }
      return rec->size;
    }
  }
  return -1;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
findVariable(const char *line)
{
	/* Parse global and class variable names (C.x) from assignment statements.
	 * Object attributes (obj.x) are ignored.
	 * Assignment to a tuple 'x, y = 2, 3' not supported.
	 * TODO: ignore duplicate tags from reassignment statements. */
	const char *cp, *sp, *eq, *start;
	cp = strstr(line, "=");
	if (!cp)
		return NULL;
	eq = cp + 1;
	while (*eq)
	{
		if (*eq == '=')
			return NULL;	/* ignore '==' operator and 'x=5,y=6)' function lines */
		if (*eq == '(' || *eq == '#')
			break;	/* allow 'x = func(b=2,y=2,' lines and comments at the end of line */
		eq++;
	}
	/* go backwards to the start of the line, checking we have valid chars */
	start = cp - 1;
	while (start >= line && isspace ((int) *start))
		--start;
	while (start >= line && isIdentifierCharacter ((int) *start))
		--start;
	if (!isIdentifierFirstCharacter(*(start + 1)))
		return NULL;
	sp = start;
	while (sp >= line && isspace ((int) *sp))
		--sp;
	if ((sp + 1) != line)	/* the line isn't a simple variable assignment */
		return NULL;
	/* the line is valid, parse the variable name */
	++start;
	return start;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
event_whois_oper(IRC_SERVER_REC *server, const char *data)
{
	char *params, *nick, *type;
	g_return_if_fail(data != NULL);
	params = event_get_params(data, 3, NULL, &nick, &type);
	/* Bugfix: http://bugs.irssi.org/?do=details&id=99
	 * Author: Geert Hauwaerts <geert@irssi.org>
	 * Date:   Wed Sep 15 20:17:24 CEST 2004
	 */
	if ((!strncmp(type, "is an ", 6)) || (!strncmp(type, "is a ", 5))) {
		type += 5;
		if (*type == ' ') type++;
	}
	if (*type == '\0')
		type = "IRC Operator";
	printformat(server, nick, MSGLEVEL_CRAP,
		IRCTXT_WHOIS_OPER, nick, type);
	g_free(params);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
cli_scanmschm(cli_ctx *ctx)
{
	int ret = CL_CLEAN, rc;
	chm_metadata_t metadata;
	char *dir;
	unsigned int viruses_found = 0;
    cli_dbgmsg("in cli_scanmschm()\n");
     /* generate the temporary directory */
    if(!(dir = cli_gentemp(ctx->engine->tmpdir)))
	return CL_EMEM;
    if(mkdir(dir, 0700)) {
	cli_dbgmsg("CHM: Can't create temporary directory %s\n", dir);
	free(dir);
	return CL_ETMPDIR;
    }
    ret = cli_chm_open(dir, &metadata, ctx);
    if (ret != CL_SUCCESS) {
	if(!ctx->engine->keeptmp)
	    cli_rmdirs(dir);
	free(dir);
	cli_dbgmsg("CHM: Error: %s\n", cl_strerror(ret));
	return ret;
    }
   do {
	ret = cli_chm_prepare_file(&metadata);
	if (ret != CL_SUCCESS) {
	   break;
	}
	ret = cli_chm_extract_file(dir, &metadata, ctx);
	if (ret == CL_SUCCESS) {
	    rc = cli_magic_scandesc(metadata.ofd, ctx);
	    close(metadata.ofd);
	    if (rc == CL_VIRUS) {
		cli_dbgmsg("CHM: infected with %s\n", cli_get_last_virus(ctx));
		if (SCAN_ALL)
		    viruses_found++;
		else {
		    ret = CL_VIRUS;
		    break;
		}
	    }
	}
    } while(ret == CL_SUCCESS);
    cli_chm_close(&metadata);
    if(!ctx->engine->keeptmp)
	cli_rmdirs(dir);
    free(dir);
    cli_dbgmsg("CHM: Exit code: %d\n", ret);
    if (ret == CL_BREAK)
	ret = CL_CLEAN;
    if (SCAN_ALL && viruses_found)
	return CL_VIRUS;
    return ret;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
upload_firmware(struct zd_usb *usb)
{
	int r;
	u16 fw_bcdDevice;
	u16 bcdDevice;
	struct usb_device *udev = zd_usb_to_usbdev(usb);
	const struct firmware *ub_fw = NULL;
	const struct firmware *uph_fw = NULL;
	char fw_name[128];
	bcdDevice = get_bcdDevice(udev);
	r = request_fw_file(&ub_fw,
		get_fw_name(usb, fw_name, sizeof(fw_name), "ub"),
		&udev->dev);
	if (r)
		goto error;
	fw_bcdDevice = get_word(ub_fw->data, E2P_DATA_OFFSET);
	if (fw_bcdDevice != bcdDevice) {
		dev_info(&udev->dev,
			"firmware version %#06x and device bootcode version "
			"%#06x differ\n", fw_bcdDevice, bcdDevice);
		if (bcdDevice <= 0x4313)
			dev_warn(&udev->dev, "device has old bootcode, please "
				"report success or failure\n");
		r = handle_version_mismatch(usb, ub_fw);
		if (r)
			goto error;
	} else {
		dev_dbg_f(&udev->dev,
			"firmware device id %#06x is equal to the "
			"actual device id\n", fw_bcdDevice);
	}
	r = request_fw_file(&uph_fw,
		get_fw_name(usb, fw_name, sizeof(fw_name), "uphr"),
		&udev->dev);
	if (r)
		goto error;
	r = upload_code(udev, uph_fw->data, uph_fw->size, FW_START, REBOOT);
	if (r) {
		dev_err(&udev->dev,
			"Could not upload firmware code uph. Error number %d\n",
			r);
	}
	/* FALL-THROUGH */
error:
	release_firmware(ub_fw);
	release_firmware(uph_fw);
	return r;
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
LUsolve(const MAT *LU, PERM *pivot, const VEC *b, VEC *x)
#endif
{
	if ( ! LU || ! b || ! pivot )
		error(E_NULL,"LUsolve");
	if ( LU->m != LU->n || LU->n != b->dim )
		error(E_SIZES,"LUsolve");
	x = v_resize(x,b->dim);
	px_vec(pivot,b,x);	/* x := P.b */
	Lsolve(LU,x,x,1.0);	/* implicit diagonal = 1 */
	Usolve(LU,x,x,0.0);	/* explicit diagonal */
	return (x);
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
copy_from_filestruct(filestruct *file_top, filestruct *file_bot)
{
    filestruct *top_save;
    size_t current_x_save = openfile->current_x;
    bool edittop_inside;
#ifndef NANO_TINY
    bool right_side_up = FALSE, single_line = FALSE;
#endif
    assert(file_top != NULL && file_bot != NULL);
#ifndef NANO_TINY
    /* Keep track of whether the mark begins inside the partition and
     * will need adjustment. */
    if (openfile->mark_set) {
	filestruct *top, *bot;
	size_t top_x, bot_x;
	mark_order((const filestruct **)&top, &top_x,
		(const filestruct **)&bot, &bot_x, &right_side_up);
	single_line = (top == bot);
    }
#endif
    /* Partition the filestruct so that it contains no text, and keep
     * track of whether the top of the edit window is inside the
     * partition. */
    filepart = partition_filestruct(openfile->current,
	openfile->current_x, openfile->current, openfile->current_x);
    edittop_inside = (openfile->edittop == openfile->fileage);
    /* Put the top and bottom of the filestruct at copies of file_top
     * and file_bot. */
    openfile->fileage = copy_filestruct(file_top);
    openfile->filebot = openfile->fileage;
    while (openfile->filebot->next != NULL)
	openfile->filebot = openfile->filebot->next;
    /* Restore the current line and cursor position.  If the mark begins
     * inside the partition, adjust the mark coordinates to compensate
     * for the change in the current line. */
    openfile->current = openfile->filebot;
    openfile->current_x = strlen(openfile->filebot->data);
    if (openfile->fileage == openfile->filebot) {
#ifndef NANO_TINY
	if (openfile->mark_set) {
	    openfile->mark_begin = openfile->current;
	    if (!right_side_up)
		openfile->mark_begin_x += openfile->current_x;
	}
#endif
	openfile->current_x += current_x_save;
    }
#ifndef NANO_TINY
    else if (openfile->mark_set) {
	if (!right_side_up) {
	    if (single_line) {
		openfile->mark_begin = openfile->current;
		openfile->mark_begin_x -= current_x_save;
	    } else
		openfile->mark_begin_x -= openfile->current_x;
	}
    }
#endif
    /* Get the number of characters in the copied text, and add it to
     * totsize. */
    openfile->totsize += get_totsize(openfile->fileage,
	openfile->filebot);
    /* Update the current y-coordinate to account for the number of
     * lines the copied text has, less one since the first line will be
     * tacked onto the current line. */
    openfile->current_y += openfile->filebot->lineno - 1;
    top_save = openfile->fileage;
    /* If the top of the edit window is inside the partition, set it to
     * where the copied text now starts. */
    if (edittop_inside)
	openfile->edittop = openfile->fileage;
    /* Unpartition the filestruct so that it contains all the text
     * again, plus the copied text. */
    unpartition_filestruct(&filepart);
    /* Renumber starting with the beginning line of the old
     * partition. */
    renumber(top_save);
    /* If the NO_NEWLINES flag isn't set, and the text doesn't end with
     * a magicline, add a new magicline. */
    if (!ISSET(NO_NEWLINES) && openfile->filebot->data[0] != '\0')
	new_magicline();
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
stripe_getxattr_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
                     int op_ret, int op_errno, dict_t *xattr)
{
        int                     call_cnt = 0;
        stripe_local_t         *local = NULL;
        VALIDATE_OR_GOTO (frame, out);
        VALIDATE_OR_GOTO (frame->local, out);
        local = frame->local;
        LOCK (&frame->lock);
        {
                call_cnt = --local->wind_count;
        }
        UNLOCK (&frame->lock);
        if (!xattr || (op_ret < 0))
                goto out;
        local->op_ret = 0;
        if (!local->xattr) {
                local->xattr = dict_ref (xattr);
        } else {
                stripe_aggregate_xattr (local->xattr, xattr);
        }
out:
        if (!call_cnt) {
                STRIPE_STACK_UNWIND (getxattr, frame, local->op_ret, op_errno,
                                     local->xattr);
        }
        return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  True
CWE-other  True
--------------------------
p_is_debug_feature_item_enabled(const char *debug_item)
{
  gboolean enable;
  char *filename;
  enable = FALSE;
  filename = p_get_gapdebug_storyboard_config_file();
  if(filename)
  {
    if(gap_debug)
    {
        printf("debug feature filename:'%s'\n", filename);
    }
    if(g_file_test(filename, G_FILE_TEST_EXISTS))
    {
      FILE *l_fp;
      char         l_buf[400];
      if(gap_debug)
      {
        printf("check for item:'%s'\n", debug_item);
      }
      l_fp = g_fopen(filename, "r");
      if(l_fp)
      {
        while (NULL != fgets (l_buf, sizeof(l_buf)-1, l_fp))
        {
          l_buf[sizeof(l_buf)-1] = '\0';
          gap_file_chop_trailingspace_and_nl(&l_buf[0]);
          if(gap_debug)
          {
            printf("  CFG:'%s'\n", l_buf);
          }
          if (strcmp(l_buf, debug_item) == 0)
          {
            enable = TRUE;
            break;
          }
        }
        fclose(l_fp);
      }
    }
    g_free(filename);
  }
  return(enable);
}
CWE-119  True
CWE-120  True
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
strtoll_or_err(const char *str, const char *errmesg)
{
       long long num;
       char *end = NULL;
       if (str == NULL || *str == '\0')
               goto err;
       errno = 0;
       num = strtoll(str, &end, 10);
       if (errno || str == end || (end && *end))
               goto err;
       return num;
err:
       if (errno)
               err(EXIT_FAILURE, "%s: '%s'", errmesg, str);
       else
               errx(EXIT_FAILURE, "%s: '%s'", errmesg, str);
       return 0;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
DoOpenProject(const wxString& filename, bool addToHistory)
{
//    Manager::Get()->GetLogManager()->DebugLog(_T("Opening project '%s'"), filename.wx_str());
    if (!wxFileExists(filename))
    {
        cbMessageBox(_("The project file does not exist..."), _("Error"), wxICON_ERROR);
        return false;
    }
    ShowHideStartPage(true); // hide startherepage, so we can use full tab-range
    cbProject* prj = Manager::Get()->GetProjectManager()->LoadProject(filename, true);
    if (prj)
    {
        if (addToHistory)
            m_projectsHistory.AddToHistory(prj->GetFilename());
        return true;
    }
    ShowHideStartPage(); // show/hide startherepage, dependant of settings, if loading failed
    return false;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
SMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,
		     u64 persistent_fid, u64 volatile_fid)
{
	int rc;
	struct  compress_ioctl fsctl_input;
	char *ret_data = NULL;
	fsctl_input.CompressionState =
			cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);
	rc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,
			FSCTL_SET_COMPRESSION, true /* is_fsctl */,
			(char *)&fsctl_input /* data input */,
			2 /* in data len */, &ret_data /* out data */, NULL);
	cifs_dbg(FYI, "set compression rc %d\n", rc);
	return rc;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
brasero_volume_source_open_device_handle (BraseroDeviceHandle *handle,
					  GError **error)
{
	int size;
	BraseroVolSrc *src;
	BraseroScsiResult result;
	BraseroScsiGetConfigHdr *hdr = NULL;
	g_return_val_if_fail (handle != NULL, NULL);
	src = g_new0 (BraseroVolSrc, 1);
	src->ref = 1;
	src->data = handle;
	src->seek = brasero_volume_source_seek_device_handle;
	/* check which read function should be used. */
	result = brasero_mmc2_get_configuration_feature (handle,
							 BRASERO_SCSI_FEAT_RD_CD,
							 &hdr,
							 &size,
							 NULL);
	if (result == BRASERO_SCSI_OK && hdr->desc->current) {
		BRASERO_MEDIA_LOG ("READ CD current. Using READCD");
		src->read = brasero_volume_source_readcd_device_handle;
		g_free (hdr);
		return src;
	}
	/* clean and retry */
	g_free (hdr);
	hdr = NULL;
	result = brasero_mmc2_get_configuration_feature (handle,
							 BRASERO_SCSI_FEAT_RD_RANDOM,
							 &hdr,
							 &size,
							 NULL);
	if (result == BRASERO_SCSI_OK && hdr->desc->current) {
		BRASERO_MEDIA_LOG ("READ DVD current. Using READ10");
		src->read = brasero_volume_source_read10_device_handle;
		g_free (hdr);
	}
	else {
		BRASERO_MEDIA_LOG ("READ DVD not current. Using READCD.");
		src->read = brasero_volume_source_readcd_device_handle;
		g_free (hdr);
	}
	return src;
}
CWE-119  False
CWE-120  False
CWE-469  False
CWE-476  False
CWE-other  False
--------------------------
